===== FILE: ./client/include/ConnectionHandler.h =====
     1	#pragma once
     2	
     3	#include <string>
     4	#include <iostream>
     5	#include <boost/asio.hpp>
     6	#include "StompProtocol.h"
     7	#include <mutex>
     8	
     9	using boost::asio::ip::tcp;
    10	
    11	class ConnectionHandler {
    12	private:
    13		const std::string host_;
    14		const short port_;
    15		boost::asio::io_service io_service_;   // Provides core I/O functionality
    16		tcp::socket socket_;
    17	
    18		StompProtocol protocol_;
    19	    
    20	    std::mutex socketMutex_;
    21	    bool connected_;
    22	
    23	public:
    24		ConnectionHandler(std::string host, short port);
    25	
    26		virtual ~ConnectionHandler();
    27	
    28		// Connect to the remote machine
    29		bool connect();
    30	
    31		// Read a fixed number of bytes from the server - blocking.
    32		// Returns false in case the connection is closed before bytesToRead bytes can be read.
    33		bool getBytes(char bytes[], unsigned int bytesToRead);
    34	
    35		// Send a fixed number of bytes from the client - blocking.
    36		// Returns false in case the connection is closed before all the data is sent.
    37		bool sendBytes(const char bytes[], int bytesToWrite);
    38	
    39		// Read an ascii line from the server
    40		// Returns false in case connection closed before a newline can be read.
    41		bool getLine(std::string &line);
    42	
    43		// Send an ascii line from the server
    44		// Returns false in case connection closed before all the data is sent.
    45		bool sendLine(std::string &line);
    46	
    47		// Get Ascii data from the server until the delimiter character
    48		// Returns false in case connection closed before null can be read.
    49		bool getFrameAscii(std::string &frame, char delimiter);
    50	
    51		// Send a message to the remote host.
    52		// Returns false in case connection is closed before all the data is sent.
    53		bool sendFrameAscii(const std::string &frame, char delimiter);
    54	
    55		// Close down the connection properly.
    56		void close();
    57		bool isConnected() const { return connected_; }
    58	    StompProtocol& getProtocol() { return protocol_; }
    59	}; //class ConnectionHandler



===== FILE: ./client/include/StompProtocol.h =====
     1	#ifndef STOMP_PROTOCOL_H
     2	#define STOMP_PROTOCOL_H
     3	
     4	#include <string>
     5	#include <map>
     6	#include <vector>
     7	#include <mutex>
     8	#include "event.h"
     9	
    10	using namespace std;
    11	
    12	class StompProtocol {
    13	private:
    14	    string username;
    15	    string password;
    16	    int receiptIdCounter;
    17	    int subscriptionIdCounter;
    18	    bool loggedIn;
    19	    mutex mtx;
    20	    
    21	    // Maps subscription ID to topic
    22	    map<string, string> subscriptions;
    23	    
    24	
    25	    // Map: user -> game -> events
    26	    map<string, map<string, names_and_events>> gameReports;
    27	    
    28	    string generateReceiptId();
    29	    string generateSubscriptionId();
    30	    
    31	public:
    32	    StompProtocol();
    33	    
    34	    // Frame builders
    35	    string buildConnectFrame(const string& host, 
    36	                                  const string& user, 
    37	                                  const string& pass);
    38	    
    39	    string buildSubscribeFrame(const string& topic);
    40	    
    41	    string buildUnsubscribeFrame(const string& subscriptionId);
    42	    
    43	    string buildSendFrame(const string& topic, 
    44	                               const Event& event, 
    45	                               const string& user);
    46	    
    47	    string buildDisconnectFrame();
    48	    
    49	    // Frame handlers
    50	    void handleMessageFrame(const string& frame);
    51	    
    52	    // Game data management
    53	    void saveGameEvent(const string& user, 
    54	                      const string& gameName, 
    55	                      const Event& event);
    56	    
    57	    void generateSummary(const string& gameName, 
    58	                        const string& user, 
    59	                        const string& outputFile);
    60	    
    61	    // State
    62	    bool isLoggedIn() const { return loggedIn; }
    63	    void setLoggedIn(bool status) { loggedIn = status; }
    64	
    65	    string getSubscriptionIdByTopic(const string& topic);
    66	    string getCurrentUsername() const { return username; }
    67	
    68	};
    69	
    70	#endif



===== FILE: ./client/include/event.h =====
     1	#pragma once
     2	
     3	#include <string>
     4	#include <iostream>
     5	#include <map>
     6	#include <vector>
     7	
     8	class Event
     9	{
    10	private:
    11	    // name of team a
    12	    std::string team_a_name;
    13	    // name of team b
    14	    std::string team_b_name;
    15	    // name of the event
    16	    std::string name;
    17	    // time of the event in seconds
    18	    int time;
    19	    // map of all the general game updates
    20	    std::map<std::string, std::string> game_updates;
    21	    // map of all team a updates the second type can be a string bool or int
    22	    std::map<std::string, std::string> team_a_updates;
    23	    // map of all team b updates
    24	    std::map<std::string, std::string> team_b_updates;
    25	    // description of the event
    26	    std::string description;
    27	
    28	public:
    29	    Event(std::string name, std::string team_a_name, std::string team_b_name, int time, std::map<std::string, std::string> game_updates, std::map<std::string, std::string> team_a_updates, std::map<std::string, std::string> team_b_updates, std::string discription);
    30	    Event(const std::string & frame_body);
    31	    virtual ~Event();
    32	    const std::string &get_team_a_name() const;
    33	    const std::string &get_team_b_name() const;
    34	    const std::string &get_name() const;
    35	    int get_time() const;
    36	    const std::map<std::string, std::string> &get_game_updates() const;
    37	    const std::map<std::string, std::string> &get_team_a_updates() const;
    38	    const std::map<std::string, std::string> &get_team_b_updates() const;
    39	    const std::string &get_discription() const;
    40	};
    41	
    42	// an object that holds the names of the teams and a vector of events, to be returned by the parseEventsFile function
    43	struct names_and_events {
    44	    std::string team_a_name;
    45	    std::string team_b_name;
    46	    std::vector<Event> events;
    47	};
    48	
    49	// function that parses the json file and returns a names_and_events object
    50	names_and_events parseEventsFile(std::string json_path);



===== FILE: ./client/makefile =====
     1	CFLAGS:=-c -Wall -Weffc++ -g -std=c++11 -Iinclude
     2	LDFLAGS:=-lboost_system -lpthread
     3	
     4	all: StompClient
     5	
     6	StompClient: bin/ConnectionHandler.o bin/StompClient.o bin/StompProtocol.o bin/event.o
     7		g++ -o bin/StompClient bin/ConnectionHandler.o bin/StompClient.o bin/StompProtocol.o bin/event.o $(LDFLAGS)
     8	
     9	bin/ConnectionHandler.o: src/ConnectionHandler.cpp
    10		g++ $(CFLAGS) -o bin/ConnectionHandler.o src/ConnectionHandler.cpp
    11	
    12	bin/StompClient.o: src/StompClient.cpp
    13		g++ $(CFLAGS) -o bin/StompClient.o src/StompClient.cpp
    14	
    15	bin/StompProtocol.o: src/StompProtocol.cpp
    16		g++ $(CFLAGS) -o bin/StompProtocol.o src/StompProtocol.cpp
    17	
    18	bin/event.o: src/event.cpp
    19		g++ $(CFLAGS) -o bin/event.o src/event.cpp
    20	
    21	.PHONY: clean
    22	clean:
    23		rm -f bin/*



===== FILE: ./client/src/ConnectionHandler.cpp =====
     1	#include "../include/ConnectionHandler.h"
     2	
     3	using boost::asio::ip::tcp;
     4	
     5	using std::cin;
     6	using std::cout;
     7	using std::cerr;
     8	using std::endl;
     9	using std::string;
    10	
    11	// constructor: initializes the 'io_service' (the engine) and the 'socket' (the connection object).
    12	ConnectionHandler::ConnectionHandler(string host, short port) 
    13	    : host_(host), port_(port), io_service_(), socket_(io_service_), connected_(false) {}
    14	
    15	// destructor: ensures the connection is closed when the object is destroyed.
    16	ConnectionHandler::~ConnectionHandler() {
    17	    close();
    18	}
    19	
    20	// attempts to connect to the server.
    21	bool ConnectionHandler::connect() {
    22	    std::cout << "Starting connect to " << host_ << ":" << port_ << std::endl;
    23	    try {
    24	        // Create an endpoint (IP + port) - The "address" of the server application.
    25	        tcp::endpoint endpoint(boost::asio::ip::address::from_string(host_), port_); 
    26	        
    27	        boost::system::error_code error;
    28	        
    29	        // try to connect the socket to the endpoint.
    30	        socket_.connect(endpoint, error);
    31	        
    32	        // if the socket reports an error (e.g., server unreachable), throw an exception.
    33	        if (error)
    34	            throw boost::system::system_error(error);
    35	            
    36	        connected_ = true;
    37	    }
    38	    catch (std::exception &e) {
    39	        std::cerr << "Connection failed (Error: " << e.what() << ')' << std::endl;
    40	        return false;
    41	    }
    42	    return true;
    43	}
    44	
    45	// reads'bytesToRead' bytes from the network.
    46	// TCP is a stream, we might not get all bytes in one shot, so we loop.
    47	
    48	bool ConnectionHandler::getBytes(char bytes[], unsigned int bytesToRead) {
    49	    size_t tmp = 0; // counts how many bytes we have read so far OUR PROGRESS*****
    50	    boost::system::error_code error;
    51	    try {
    52	        // We lock specifically for reading if multiple threads share this handler (safety)
    53	        // lock_guard<std::mutex> lock(socketMutex_); 
    54	        
    55	        // loop until we have read exactly the amount requested
    56	        while (!error && bytesToRead > tmp) {
    57	            // read_some: Read whatever is available currently. 
    58	            // it puts it in the buffer at position 'bytes + tmp'.
    59	            // it asks to read 'bytesToRead - tmp' (REMAINING- THings to reads).
    60	            tmp += socket_.read_some(boost::asio::buffer(bytes + tmp, bytesToRead - tmp), error);
    61	        }
    62	        if (error)
    63	            throw boost::system::system_error(error);
    64	    } catch (std::exception &e) {
    65	        std::cerr << "recv failed (Error: " << e.what() << ')' << std::endl;
    66	        return false;
    67	    }
    68	    return true;
    69	}
    70	
    71	// Sends EXACTLY 'bytesToWrite' to the network.
    72	bool ConnectionHandler::sendBytes(const char bytes[], int bytesToWrite) {
    73	    int tmp = 0; // OUR PROGRESS****counts how many bytes sent so far*******
    74	    boost::system::error_code error;
    75	    try {
    76	        // lock_guard<std::mutex> lock(socketMutex_);
    77	        
    78	        // Loop until all data is sent
    79	        //meaning temp is <= bytesToWrite meaning we still have more to send
    80	        while (!error && bytesToWrite > tmp) {
    81	            // write_some: Sends a chunk of data returns how much was actually sent.
    82	            //add to temp what we manged to send in this iteration
    83	            tmp += socket_.write_some(boost::asio::buffer(bytes + tmp, bytesToWrite - tmp), error);
    84	        }
    85	        if (error)
    86	            throw boost::system::system_error(error);
    87	    } catch (std::exception &e) {
    88	        std::cerr << "recv failed (Error: " << e.what() << ')' << std::endl;
    89	        return false;
    90	    }
    91	    return true;
    92	}
    93	
    94	//read until '\n' (New Line).
    95	
    96	bool ConnectionHandler::getLine(std::string &line) {
    97	    return getFrameAscii(line, '\n');
    98	}
    99	
   100	// send a string followed by '\n'.
   101	bool ConnectionHandler::sendLine(std::string &line) {
   102	    return sendFrameAscii(line, '\n');
   103	}
   104	
   105	// CRITICAL FOR STOMP: Reads byte by byte until it finds the 'delimiter'.
   106	//  frames end with a null character ('\0').
   107	bool ConnectionHandler::getFrameAscii(std::string &frame, char delimiter) {
   108	    char ch;
   109	    // Try to read 1 byte at a time until we hit the delimiter.
   110	    try {
   111	        do {
   112	            // read 1 byte into 'ch'
   113	            if (!getBytes(&ch, 1)) {
   114	                return false; // connection closed or error
   115	            }
   116	            // if it's not the delimiter, append it to our result string
   117	            if (ch != delimiter) 
   118	                frame.append(1, ch);
   119	        } while (delimiter != ch);
   120	    } catch (std::exception &e) {
   121	        std::cerr << "recv failed2 (Error: " << e.what() << ')' << std::endl;
   122	        return false;
   123	    }
   124	    return true;
   125	}
   126	
   127	//  stomp sends the frame string and appends the delimiter.
   128	//  send the frame content, then send '\0' .
   129	bool ConnectionHandler::sendFrameAscii(const std::string &frame, char delimiter) {
   130	    // Send the actual content
   131	    bool result = sendBytes(frame.c_str(), frame.length());
   132	    if (!result) return false;
   133	    
   134	    // send the delimiter \0
   135	    return sendBytes(&delimiter, 1);
   136	}
   137	
   138	//  closes the socket connection.
   139	void ConnectionHandler::close() {
   140	    try {
   141	        connected_ = false;
   142	        socket_.close();
   143	    } catch (...) {
   144	        std::cout << "closing failed: connection already closed" << std::endl;
   145	    }
   146	}



===== FILE: ./client/src/StompClient.cpp =====
     1	#include <iostream>
     2	#include <thread>
     3	#include <string>
     4	#include <sstream>
     5	#include <vector>
     6	#include "../include/ConnectionHandler.h"
     7	#include "event.h"
     8	
     9	void socketReaderThread(ConnectionHandler* handler) {
    10	    while (handler->isConnected()) {
    11	        std::string frame;
    12	        
    13	        if (!handler->getFrameAscii(frame, '\0')) {
    14	            break;
    15	        }
    16	        //std::cout << "DEBUG === RECEIVED FRAME ===\n" << frame << "\n==================\n";
    17	
    18	        if (frame.substr(0, 9) == "CONNECTED") {
    19	            std::cout << "Login successful" << std::endl;
    20	            handler->getProtocol().setLoggedIn(true);
    21	            
    22	        } else if (frame.substr(0, 5) == "ERROR") {
    23	            std::cerr << "Error from server:\n" << frame << std::endl;
    24	            handler->close();
    25	            break;
    26	            
    27	        } else if (frame.substr(0, 7) == "RECEIPT") {
    28	            size_t pos = frame.find("receipt-id:");
    29	            if (pos != std::string::npos) {
    30	                std::string receiptId = frame.substr(pos + 11);
    31	                receiptId = receiptId.substr(0, receiptId.find('\n'));
    32	            }
    33	            
    34	        } else if (frame.substr(0, 7) == "MESSAGE") {
    35	            handler->getProtocol().handleMessageFrame(frame);
    36	        }
    37	    }
    38	}
    39	
    40	std::vector<std::string> split(const std::string& str, char delimiter) {
    41	    std::vector<std::string> tokens;
    42	    std::string token;
    43	    std::istringstream tokenStream(str);
    44	    
    45	    while (std::getline(tokenStream, token, delimiter)) {
    46	        tokens.push_back(token);
    47	    }
    48	    
    49	    return tokens;
    50	}
    51	
    52	int main(int argc, char* argv[]) {
    53	    ConnectionHandler* handler = nullptr;
    54	    std::thread* readerThread = nullptr;
    55	    
    56	    std::string line;
    57	    
    58	    while (std::getline(std::cin, line)) {
    59	        std::vector<std::string> tokens = split(line, ' ');
    60	        
    61	        if (tokens.empty()) continue;
    62	        
    63	        std::string command = tokens[0];
    64	        
    65	        if (command == "login") {
    66	            //cout << "DEBUG Attempting to log in..." << std::endl;
    67	            if (tokens.size() != 4) {
    68	                std::cerr << "Usage: login host:port username password" << std::endl;
    69	                continue;
    70	            }
    71	            
    72	            if (handler != nullptr && handler->isConnected()) {
    73	                std::cerr << "The client is already logged in, log out before trying again" << std::endl;
    74	                continue;
    75	            }
    76	            
    77	            std::string hostPort = tokens[1];
    78	            size_t colonPos = hostPort.find(':');
    79	            
    80	            if (colonPos == std::string::npos) {
    81	                std::cerr << "Invalid host:port format" << std::endl;
    82	                continue;
    83	            }
    84	            
    85	            std::string host = hostPort.substr(0, colonPos);
    86	            short port = std::stoi(hostPort.substr(colonPos + 1));
    87	            
    88	            std::string username = tokens[2];
    89	            std::string password = tokens[3];
    90	            
    91	            handler = new ConnectionHandler(host, port);
    92	            
    93	            if (!handler->connect()) {
    94	                delete handler;
    95	                handler = nullptr;
    96	                continue;
    97	            }
    98	            readerThread = new std::thread(socketReaderThread, handler);
    99	
   100	            std::string connectFrame = handler->getProtocol().buildConnectFrame(host, username, password);
   101	            handler->sendFrameAscii(connectFrame, '\0');            
   102	        }
   103	        else if (command == "join") {
   104	            //std::cout << "DEBUG Processing join command" << std::endl;  
   105	
   106	            if (tokens.size() != 2) {
   107	                std::cerr << "Usage: join game_name" << std::endl;
   108	                continue;
   109	            }
   110	            
   111	            if (handler == nullptr || !handler->isConnected()) {
   112	                std::cerr << "Not connected to server" << std::endl;
   113	                continue;
   114	            }
   115	            if (!handler->getProtocol().isLoggedIn()) {
   116	                std::cerr << "Not logged in. Please wait for login to complete." << std::endl;
   117	                continue;
   118	            }
   119	            std::string gameName = tokens[1];
   120	            std::string topic = "/" + gameName;
   121	            
   122	            std::string subscribeFrame = handler->getProtocol().buildSubscribeFrame(topic);
   123	            //std::cout << "DEBUG === SENDING SUBSCRIBE ===\n" << subscribeFrame << "\n==================\n";
   124	
   125	            handler->sendFrameAscii(subscribeFrame, '\0');
   126	            
   127	            std::cout << "Joined channel " << gameName << std::endl;
   128	        }
   129	        
   130	        else if (command == "exit") {
   131	            if (tokens.size() != 2) {
   132	                std::cerr << "Usage: exit game_name" << std::endl;
   133	                continue;
   134	            }
   135	            
   136	            if (handler == nullptr || !handler->isConnected()) {
   137	                std::cerr << "Not connected to server" << std::endl;
   138	                continue;
   139	            }
   140	            
   141	            std::string gameName = tokens[1];
   142	            
   143	            std::string topic = "/" + gameName;
   144	            std::string subId = handler->getProtocol().getSubscriptionIdByTopic(topic);
   145	            if (subId == "") {
   146	                std::cerr << "Error: You are not subscribed to " << gameName << std::endl;
   147	                continue;
   148	            }
   149	            std::string unsubscribeFrame = handler->getProtocol().buildUnsubscribeFrame(subId);
   150	            handler->sendFrameAscii(unsubscribeFrame, '\0');
   151	            
   152	            std::cout << "Exited channel " << gameName << std::endl;
   153	        }
   154	        
   155	        else if (command == "report") {
   156	            if (tokens.size() != 2) {
   157	                std::cerr << "Usage: report filename" << std::endl;
   158	                continue;
   159	            }
   160	            
   161	            if (handler == nullptr || !handler->isConnected()) {
   162	                std::cerr << "Not connected to server" << std::endl;
   163	                continue;
   164	            }
   165	            
   166	            std::string filename = tokens[1];
   167	            
   168	            names_and_events nae = parseEventsFile(filename);
   169	            
   170	            std::string gameName = nae.team_a_name + "_" + nae.team_b_name;
   171	            std::string topic = "/" + gameName;
   172	            
   173	            for (const Event& event : nae.events) {
   174	                std::string sendFrame = handler->getProtocol().buildSendFrame(
   175	                    topic, event, handler->getProtocol().getCurrentUsername()
   176	                );
   177	                handler->sendFrameAscii(sendFrame, '\0');
   178	                
   179	                handler->getProtocol().saveGameEvent(handler->getProtocol().getCurrentUsername(), gameName, event);
   180	            }
   181	        }
   182	        else if (command == "summary") {
   183	            if (tokens.size() != 4) {
   184	                std::cerr << "Usage: summary game_name user outputfile" << std::endl;
   185	                continue;
   186	            }
   187	            
   188	            std::string gameName = tokens[1];
   189	            std::string user = tokens[2];
   190	            std::string outputFile = tokens[3];
   191	            
   192	            handler->getProtocol().generateSummary(gameName, user, outputFile);
   193	        }
   194	        else if (command == "logout") {
   195	            if (handler == nullptr || !handler->isConnected()) {
   196	                std::cerr << "Not connected to server" << std::endl;
   197	                continue;
   198	            }
   199	            
   200	            std::string disconnectFrame = handler->getProtocol().buildDisconnectFrame();
   201	            handler->sendFrameAscii(disconnectFrame, '\0');
   202	            
   203	            std::this_thread::sleep_for(std::chrono::milliseconds(500));
   204	            
   205	            handler->close();
   206	            
   207	            if (readerThread != nullptr) {
   208	                readerThread->join();
   209	                delete readerThread;
   210	                readerThread = nullptr;
   211	            }
   212	            
   213	            delete handler;
   214	            handler = nullptr;
   215	            
   216	            std::cout << "Logged out" << std::endl;
   217	        }
   218	        else {
   219	            std::cerr << "Unknown command: " << command << std::endl;
   220	        }
   221	    }
   222	    
   223	    if (handler != nullptr) {
   224	        handler->close();
   225	        if (readerThread != nullptr) {
   226	            readerThread->join();
   227	            delete readerThread;
   228	        }
   229	        delete handler;
   230	    }
   231	    
   232	    return 0;
   233	}



===== FILE: ./client/src/StompProtocol.cpp =====
     1	#include "StompProtocol.h"
     2	#include <fstream>
     3	#include <iostream>
     4	#include <algorithm>
     5	#include <vector>
     6	
     7	using namespace std;
     8	
     9	//initializes the protocol state and counters
    10	StompProtocol::StompProtocol() 
    11	    : username(""), password(""), receiptIdCounter(0), 
    12	      subscriptionIdCounter(0), loggedIn(false) {}
    13	
    14	//ID Generation Helpers
    15	
    16	string StompProtocol::generateReceiptId() {
    17	    lock_guard<mutex> lock(mtx); //  thread safety
    18	    return to_string(++receiptIdCounter);
    19	}
    20	
    21	string StompProtocol::generateSubscriptionId() {
    22	    lock_guard<mutex> lock(mtx); //  thread safety
    23	    return to_string(++subscriptionIdCounter);
    24	}
    25	
    26	// Frame Builders 
    27	
    28	string StompProtocol::buildConnectFrame(const string& host, 
    29	                                        const string& user, 
    30	                                        const string& pass) {
    31	    username = user;
    32	    password = pass;
    33	    
    34	    // Building the frame 
    35	    string frame = "CONNECT\n";
    36	    frame += "accept-version:1.2\n";
    37	    frame += "host:stomp.cs.bgu.ac.il\n";
    38	    frame += "login:" + user + "\n";
    39	    frame += "passcode:" + pass + "\n";
    40	    frame += "\n"; // Empty line marks end of headers
    41	    
    42	    return frame;
    43	}
    44	
    45	string StompProtocol::buildSubscribeFrame(const string& topic) {
    46	    string subId = generateSubscriptionId();
    47	    string receiptId = generateReceiptId();
    48	    
    49	    // Map the subscription ID to the topic (Thread Safe)
    50	    {
    51	        lock_guard<mutex> lock(mtx);
    52	        subscriptions[subId] = topic;
    53	    }
    54	    
    55	    string frame = "SUBSCRIBE\n";
    56	    frame += "destination:" + topic + "\n";
    57	    frame += "id:" + subId + "\n";
    58	    frame += "receipt:" + receiptId + "\n";
    59	    frame += "\n";
    60	    
    61	    return frame;
    62	}
    63	
    64	string StompProtocol::buildUnsubscribeFrame(const string& subId) {
    65	    string receiptId = generateReceiptId();
    66	    
    67	    string frame = "UNSUBSCRIBE\n";
    68	    frame += "id:" + subId + "\n";
    69	    frame += "receipt:" + receiptId + "\n";
    70	    frame += "\n";
    71	    
    72	    // remove the subscription from our local map
    73	    {
    74	        lock_guard<mutex> lock(mtx);
    75	        subscriptions.erase(subId);
    76	    }
    77	    
    78	    return frame;
    79	}
    80	
    81	string StompProtocol::buildSendFrame(const string& topic, 
    82	                                     const Event& event, 
    83	                                     const string& user) {
    84	    string frame = "SEND\n";
    85	    frame += "destination:" + topic + "\n";
    86	    frame += "\n"; // end of Headers
    87	    
    88	    // start of Body (Assignment format)
    89	    frame += "user: " + user + "\n";
    90	    frame += "team a: " + event.get_team_a_name() + "\n";
    91	    frame += "team b: " + event.get_team_b_name() + "\n";
    92	    frame += "event name: " + event.get_name() + "\n";
    93	    frame += "time: " + to_string(event.get_time()) + "\n";
    94	    
    95	    // add General Updates
    96	    frame += "general game updates:\n";
    97	    for (auto& kv : event.get_game_updates()) {
    98	        frame += kv.first + ": " + kv.second + "\n";
    99	    }
   100	    
   101	    // add Team A Updates
   102	    frame += "team a updates:\n";
   103	    for (auto& kv : event.get_team_a_updates()) {
   104	        frame += kv.first + ": " + kv.second + "\n";
   105	    }
   106	    
   107	    // add Team B Updates
   108	    frame += "team b updates:\n";
   109	    for (auto& kv : event.get_team_b_updates()) {
   110	        frame += kv.first + ": " + kv.second + "\n";
   111	    }
   112	    
   113	    // Add Description
   114	    frame += "description:\n" + event.get_discription() + "\n";
   115	    
   116	    return frame;
   117	}
   118	
   119	string StompProtocol::buildDisconnectFrame() {
   120	    string receiptId = generateReceiptId();
   121	    
   122	    string frame = "DISCONNECT\n";
   123	    frame += "receipt:" + receiptId + "\n";
   124	    frame += "\n";
   125	    
   126	    return frame;
   127	}
   128	
   129	//frame procceing logic
   130	
   131	void StompProtocol::handleMessageFrame(const string& frame) {
   132	    // Variables to store parsed data
   133	    string user, teamA, teamB, eventName, description;
   134	    int time = 0;
   135	    map<string, string> gameUpdates, teamAUpdates, teamBUpdates;
   136	    
   137	    string section = ""; // tracks if we are in "general", "team a", or "description"
   138	    bool inBody = false; // tracks if we passed the headers
   139	    
   140	    // manual line splitting using string::find
   141	    size_t startPos = 0;
   142	    size_t endPos = frame.find('\n');
   143	    
   144	    //until we reach the end of the frame - >endPos != no position
   145	    while (endPos != string::npos) {
   146	        // Extract the current line
   147	        string line = frame.substr(startPos, endPos - startPos);
   148	        
   149	        // --- FIX FOR \r (Carriage Return) ---
   150	        // Windows/Network lines often end in \r\n. We must remove \r 
   151	        // otherwise comparisons like (line == "description:") will fail.
   152	        if (!line.empty() && line.back() == '\r') {
   153	            line.pop_back();
   154	        }
   155	        
   156	        // --- HEADER SKIP LOGIC ---
   157	        // The body starts after the first empty line.
   158	        if (!inBody) {
   159	            if (line.empty()) {
   160	                inBody = true; // Found the empty line, Body starts next
   161	            }
   162	            // Move to next line
   163	            startPos = endPos + 1;
   164	            endPos = frame.find('\n', startPos);
   165	            continue; 
   166	        }
   167	        
   168	        // --- BODY PARSING LOGIC ---
   169	        
   170	        //  data Fields
   171	        if (line.find("user: ") == 0) user = line.substr(6);
   172	        else if (line.find("team a: ") == 0) teamA = line.substr(8);
   173	        else if (line.find("team b: ") == 0) teamB = line.substr(8);
   174	        else if (line.find("event name: ") == 0) eventName = line.substr(12);
   175	        else if (line.find("time: ") == 0) {
   176	            try { time = stoi(line.substr(6)); } catch (...) { time = 0; }
   177	        }
   178	        
   179	        // Section Detection
   180	        else if (line == "general game updates:") section = "general";
   181	        else if (line == "team a updates:") section = "team_a";
   182	        else if (line == "team b updates:") section = "team_b";
   183	        else if (line == "description:") {
   184	            section = "description";
   185	            // Once we hit description, everything else is the description text.
   186	            // We read until the end of the frame string manually.
   187	            if (endPos + 1 < frame.length()) {
   188	                description = frame.substr(endPos + 1);
   189	                // Clean \r from description if needed (optional but good practice)
   190	                // Note: This takes the rest of the frame as description.
   191	            }
   192	            break; // Stop loop, we handled the rest as description
   193	        }
   194	        
   195	        // 3. Key-Value Parsing (inside a section)
   196	        else if (!line.empty()) {
   197	            size_t colonPos = line.find(':');
   198	            if (colonPos != string::npos) {
   199	                string key = line.substr(0, colonPos);
   200	                string value = line.substr(colonPos + 1);
   201	                
   202	                // Trim leading space from value
   203	                if (!value.empty() && value[0] == ' ') value = value.substr(1);
   204	                
   205	                if (section == "general") gameUpdates[key] = value;
   206	                else if (section == "team_a") teamAUpdates[key] = value;
   207	                else if (section == "team_b") teamBUpdates[key] = value;
   208	            }
   209	        }
   210	        
   211	        // Move to next line
   212	        startPos = endPos + 1;
   213	        endPos = frame.find('\n', startPos);
   214	    }
   215	    
   216	    // save and display
   217	    string gameName = teamA + "_" + teamB;
   218	    Event event(teamA, teamB, eventName, time, 
   219	                gameUpdates, teamAUpdates, teamBUpdates, description);
   220	    
   221	    saveGameEvent(user, gameName, event);
   222	    
   223	    // Output to console
   224	    cout << "Displaying update from user: " << user << "\n";
   225	    cout << "Game: " << gameName << "\n";
   226	    cout << "Event: " << eventName << "\n";
   227	    cout << description << "\n" << endl;
   228	}
   229	
   230	// data Management: Saves the event to the map
   231	void StompProtocol::saveGameEvent(const string& user, 
   232	                                  const string& gameName, 
   233	                                  const Event& event) {
   234	    lock_guard<mutex> lock(mtx); // Critical section: protecting the map
   235	    
   236	    // If the game entry doesn't exist for this user, CREATE it
   237	    if (gameReports[user].find(gameName) == gameReports[user].end()) {
   238	        gameReports[user][gameName] = names_and_events();
   239	        gameReports[user][gameName].team_a_name = event.get_team_a_name();
   240	        gameReports[user][gameName].team_b_name = event.get_team_b_name();
   241	    }
   242	    
   243	    // Add the event to the list
   244	    gameReports[user][gameName].events.push_back(event);
   245	}
   246	
   247	// generates the final summary file
   248	void StompProtocol::generateSummary(const string& gameName, 
   249	                                    const string& user, 
   250	                                    const string& outputFile) {
   251	    // Check if data exists
   252	    if (gameReports.find(user) == gameReports.end() || 
   253	        gameReports[user].find(gameName) == gameReports[user].end()) {
   254	        cerr << "No reports found for game " << gameName << endl;
   255	        return;
   256	    }
   257	    
   258	    names_and_events& reportData = gameReports[user][gameName];
   259	    
   260	    // Open File
   261	    ofstream out(outputFile);
   262	    if (!out.is_open()) {
   263	        cerr << "Cannot open file: " << outputFile << endl;
   264	        return;
   265	    }
   266	    
   267	    //Statistics 
   268	    map<string, string> generalStats;
   269	    map<string, string> teamAStats;
   270	    map<string, string> teamBStats;
   271	    
   272	    for (const Event& event : reportData.events) {
   273	        for (auto& kv : event.get_game_updates()) generalStats[kv.first] = kv.second;
   274	        for (auto& kv : event.get_team_a_updates()) teamAStats[kv.first] = kv.second;
   275	        for (auto& kv : event.get_team_b_updates()) teamBStats[kv.first] = kv.second;
   276	    }
   277	    
   278	    // Write to File
   279	    out << reportData.team_a_name << " vs " << reportData.team_b_name << "\n";
   280	    out << "Game stats:\n";
   281	    
   282	    out << "General stats:\n";
   283	    for (auto& kv : generalStats) out << kv.first << ": " << kv.second << "\n";
   284	    
   285	    out << reportData.team_a_name << " stats:\n";
   286	    for (auto& kv : teamAStats) out << kv.first << ": " << kv.second << "\n";
   287	    
   288	    out << reportData.team_b_name << " stats:\n";
   289	    for (auto& kv : teamBStats) out << kv.first << ": " << kv.second << "\n";
   290	    
   291	    out << "Game event reports:\n";
   292	    // (Ideally, sort events by time here before printing, 
   293	    // keeping simplistic as per request for "simplification")
   294	    for (const Event& event : reportData.events) {
   295	        out << event.get_time() << " - " << event.get_name() << ":\n\n";
   296	        out << event.get_discription() << "\n\n\n";
   297	    }
   298	    
   299	    out.close();
   300	    cout << "Summary written to " << outputFile << endl;
   301	}
   302	
   303	// Utility: Find Subscription ID by Topic
   304	string StompProtocol::getSubscriptionIdByTopic(const string& topic) {
   305	    lock_guard<mutex> lock(mtx);
   306	
   307	    for(auto const& [id,subTopic]: subscriptions) {
   308	        if(subTopic == topic) {
   309	            return id;
   310	        }
   311	    }
   312	    return "";
   313	}



===== FILE: ./client/src/echoClient.cpp =====
     1	#include <stdlib.h>
     2	#include "../include/ConnectionHandler.h"
     3	
     4	
     5	/**
     6	* this code assumes that the server replies the exact text the client sent it
     7	*/
     8	int main (int argc, char *argv[]) {
     9	   
    10	    //check if user sended enough arguments
    11	    if (argc < 3) {
    12	        cerr << "Usage: " << argv[0] << " host port" << endl << endl;
    13	        return -1;
    14	    }
    15	    //saving host and port from arguments
    16	    string host = argv[1];
    17	    short port = atoi(argv[2]); //use atoi to convert from string to short
    18	    
    19	
    20	    //createing connection handler to talk with the server
    21	    ConnectionHandler connectionHandler(host, port);
    22	
    23	    //trying to connect to server
    24	    if (!connectionHandler.connect()) {
    25	        cerr << "Cannot connect to " << host << ":" << port << endl;
    26	        return 1;
    27	    }
    28		
    29		//from here we will see the rest of the ehco client implementation:
    30	    while (1) {
    31	        const short bufsize = 1024;
    32	        char buf[bufsize];
    33	
    34	
    35	        //read a line from the keyboard and puts \0 at the end of buf (without \n becuse we use getline and not cin)
    36	        cin.getline(buf, bufsize);
    37			string line(buf); //create line from buf
    38			int len=line.length();
    39	
    40	
    41	
    42	        //send the line to the server with the \n at the end (Automaticlly added in sendLine() function)
    43	        if (!connectionHandler.sendLine(line)) {
    44	            cout << "Disconnected. Exiting...\n" << endl;
    45	            break;
    46	        }
    47			//again connectionHandler.sendLine(line) appends '\n' to the message. Therefor we send len+1 bytes.
    48	        cout << "Sent " << len+1 << " bytes to server" << endl;
    49	
    50	        
    51	        // we can use one of three options to read data from the server:
    52	        //  read a fixed number of characters
    53	        //  read a line (up to the newline character using the getline() buffered reader
    54	        //  read up to the null character
    55	        string answer;
    56	        // get back an answer: by using the expected number of bytes (len bytes + newline delimiter)
    57	        // we could also use: connectionHandler.getline(answer) and then get the answer without the newline char at the end
    58	        
    59	        //Waiting for the answer from the server blocking the client until we get the answer
    60	        if (!connectionHandler.getLine(answer)) {
    61	            cout << "Disconnected. Exiting...\n" << std::endl;
    62	            break;
    63	        }
    64	        
    65			len=answer.length();
    66			// a C string must end with a 0 char delimiter.  When we filled the answer buffer from the socket
    67			// we filled up to the \n char - we must make sure now that a 0 char is also present. So we truncate last character.
    68	        answer.resize(len-1);
    69	        cout << "Reply: " << answer << " " << len << " bytes " << std::endl << std::endl;
    70	        if (answer == "bye") {
    71	            cout << "Exiting...\n" << std::endl;
    72	            break;
    73	        }
    74	    }
    75	    return 0;
    76	}



===== FILE: ./client/src/event.cpp =====
     1	#include "../include/event.h"
     2	#include "../include/json.hpp"
     3	#include <iostream>
     4	#include <fstream>
     5	#include <string>
     6	#include <map>
     7	#include <vector>
     8	#include <sstream>
     9	using json = nlohmann::json;
    10	
    11	Event::Event(std::string team_a_name, std::string team_b_name, std::string name, int time,
    12	             std::map<std::string, std::string> game_updates, std::map<std::string, std::string> team_a_updates,
    13	             std::map<std::string, std::string> team_b_updates, std::string discription)
    14	    : team_a_name(team_a_name), team_b_name(team_b_name), name(name),
    15	      time(time), game_updates(game_updates), team_a_updates(team_a_updates),
    16	      team_b_updates(team_b_updates), description(discription)
    17	{
    18	}
    19	
    20	Event::~Event()
    21	{
    22	}
    23	
    24	const std::string &Event::get_team_a_name() const
    25	{
    26	    return this->team_a_name;
    27	}
    28	
    29	const std::string &Event::get_team_b_name() const
    30	{
    31	    return this->team_b_name;
    32	}
    33	
    34	const std::string &Event::get_name() const
    35	{
    36	    return this->name;
    37	}
    38	
    39	int Event::get_time() const
    40	{
    41	    return this->time;
    42	}
    43	
    44	const std::map<std::string, std::string> &Event::get_game_updates() const
    45	{
    46	    return this->game_updates;
    47	}
    48	
    49	const std::map<std::string, std::string> &Event::get_team_a_updates() const
    50	{
    51	    return this->team_a_updates;
    52	}
    53	
    54	const std::map<std::string, std::string> &Event::get_team_b_updates() const
    55	{
    56	    return this->team_b_updates;
    57	}
    58	
    59	const std::string &Event::get_discription() const
    60	{
    61	    return this->description;
    62	}
    63	
    64	Event::Event(const std::string &frame_body) : team_a_name(""), team_b_name(""), name(""), time(0), game_updates(), team_a_updates(), team_b_updates(), description("")
    65	{
    66	}
    67	
    68	names_and_events parseEventsFile(std::string json_path)
    69	{
    70	    std::ifstream f(json_path);
    71	    json data = json::parse(f);
    72	
    73	    std::string team_a_name = data["team a"];
    74	    std::string team_b_name = data["team b"];
    75	
    76	    // run over all the events and convert them to Event objects
    77	    std::vector<Event> events;
    78	    for (auto &event : data["events"])
    79	    {
    80	        std::string name = event["event name"];
    81	        int time = event["time"];
    82	        std::string description = event["description"];
    83	        std::map<std::string, std::string> game_updates;
    84	        std::map<std::string, std::string> team_a_updates;
    85	        std::map<std::string, std::string> team_b_updates;
    86	        for (auto &update : event["general game updates"].items())
    87	        {
    88	            if (update.value().is_string())
    89	                game_updates[update.key()] = update.value();
    90	            else
    91	                game_updates[update.key()] = update.value().dump();
    92	        }
    93	
    94	        for (auto &update : event["team a updates"].items())
    95	        {
    96	            if (update.value().is_string())
    97	                team_a_updates[update.key()] = update.value();
    98	            else
    99	                team_a_updates[update.key()] = update.value().dump();
   100	        }
   101	
   102	        for (auto &update : event["team b updates"].items())
   103	        {
   104	            if (update.value().is_string())
   105	                team_b_updates[update.key()] = update.value();
   106	            else
   107	                team_b_updates[update.key()] = update.value().dump();
   108	        }
   109	        
   110	        events.push_back(Event(team_a_name, team_b_name, name, time, game_updates, team_a_updates, team_b_updates, description));
   111	    }
   112	    names_and_events events_and_names{team_a_name, team_b_name, events};
   113	
   114	    return events_and_names;
   115	}



===== FILE: ./data/sql_server.py =====
     1	#!/usr/bin/env python3
     2	"""
     3	Basic Python Server for STOMP Assignment â€“ Stage 3.3
     4	
     5	IMPORTANT:
     6	DO NOT CHANGE the server name or the basic protocol.
     7	Students should EXTEND this server by implementing
     8	the methods below.
     9	"""
    10	
    11	import socket
    12	import sys
    13	import threading
    14	
    15	
    16	SERVER_NAME = "STOMP_PYTHON_SQL_SERVER"  # DO NOT CHANGE!
    17	DB_FILE = "stomp_server.db"              # DO NOT CHANGE!
    18	
    19	
    20	def recv_null_terminated(sock: socket.socket) -> str:
    21	    data = b""
    22	    while True:
    23	        chunk = sock.recv(1024)
    24	        if not chunk:
    25	            return ""
    26	        data += chunk
    27	        if b"\0" in data:
    28	            msg, _ = data.split(b"\0", 1)
    29	            return msg.decode("utf-8", errors="replace")
    30	
    31	
    32	def init_database():
    33	    global db_conn
    34	     
    35	    db_conn = sqlite3.connect(DB_FILE, check_same_thread=False)
    36	    cursor = db_conn.cursor()
    37	    
    38	    # Table Users
    39	    cursor.execute('''
    40	        CREATE TABLE IF NOT EXISTS users (
    41	            username TEXT PRIMARY KEY,
    42	            password TEXT NOT NULL,
    43	            registration_date TEXT NOT NULL
    44	        )
    45	    ''')
    46	    
    47	    # Table login history
    48	    cursor.execute('''
    49	        CREATE TABLE IF NOT EXISTS login_history (
    50	            id INTEGER PRIMARY KEY AUTOINCREMENT,
    51	            username TEXT NOT NULL,
    52	            login_time TEXT NOT NULL,
    53	            logout_time TEXT,
    54	            FOREIGN KEY (username) REFERENCES users(username)
    55	        )
    56	    ''')
    57	    
    58	    # Table file tracking
    59	    cursor.execute('''
    60	        CREATE TABLE IF NOT EXISTS file_tracking (
    61	            id INTEGER PRIMARY KEY AUTOINCREMENT,
    62	            username TEXT NOT NULL,
    63	            filename TEXT NOT NULL,
    64	            upload_time TEXT NOT NULL,
    65	            game_channel TEXT,
    66	            FOREIGN KEY (username) REFERENCES users(username)
    67	        )
    68	    ''')
    69	    
    70	    db_conn.commit()
    71	    print(f"[{SERVER_NAME}] Database initialized")
    72	
    73	
    74	def execute_sql_command(sql_command: str) -> str:
    75	    global db_conn
    76	    
    77	    try:
    78	        with db_lock:
    79	            cursor = db_conn.cursor()
    80	            cursor.execute(sql_command)
    81	            db_conn.commit()
    82	            return "SUCCESS"
    83	    except Exception as e:
    84	        return f"ERROR:{str(e)}"
    85	
    86	
    87	def execute_sql_query(sql_query: str) -> str:
    88	    global db_conn
    89	    
    90	    try:
    91	        with db_lock:
    92	            cursor = db_conn.cursor()
    93	            cursor.execute(sql_query)
    94	            rows = cursor.fetchall()
    95	            
    96	            if not rows:
    97	                return "SUCCESS|"
    98	            
    99	            result = "SUCCESS|" + "|".join(str(row) for row in rows)
   100	            return result
   101	    except Exception as e:
   102	        return f"ERROR:{str(e)}"
   103	
   104	
   105	def handle_client(client_socket: socket.socket, addr):
   106	    print(f"[{SERVER_NAME}] Client connected from {addr}")
   107	
   108	    try:
   109	        while True:
   110	            message = recv_null_terminated(client_socket)
   111	            if message == "":
   112	                break
   113	
   114	            print(f"[{SERVER_NAME}] Received:")
   115	            print(message)
   116	
   117	            client_socket.sendall(b"done\0")
   118	
   119	    except Exception as e:
   120	        print(f"[{SERVER_NAME}] Error handling client {addr}: {e}")
   121	    finally:
   122	        try:
   123	            client_socket.close()
   124	        except Exception:
   125	            pass
   126	        print(f"[{SERVER_NAME}] Client {addr} disconnected")
   127	
   128	
   129	def start_server(host="127.0.0.1", port=7778):
   130	    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   131	    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
   132	
   133	    try:
   134	        server_socket.bind((host, port))
   135	        server_socket.listen(5)
   136	        print(f"[{SERVER_NAME}] Server started on {host}:{port}")
   137	        print(f"[{SERVER_NAME}] Waiting for connections...")
   138	
   139	        while True:
   140	            client_socket, addr = server_socket.accept()
   141	            t = threading.Thread(
   142	                target=handle_client,
   143	                args=(client_socket, addr),
   144	                daemon=True
   145	            )
   146	            t.start()
   147	
   148	    except KeyboardInterrupt:
   149	        print(f"\n[{SERVER_NAME}] Shutting down server...")
   150	    finally:
   151	        try:
   152	            server_socket.close()
   153	        except Exception:
   154	            pass
   155	
   156	
   157	if __name__ == "__main__":
   158	    port = 7778
   159	    if len(sys.argv) > 1:
   160	        raw_port = sys.argv[1].strip()
   161	        try:
   162	            port = int(raw_port)
   163	        except ValueError:
   164	            print(f"Invalid port '{raw_port}', falling back to default {port}")
   165	
   166	    start_server(port=port)



===== FILE: ./server/pom.xml =====
     1	<?xml version="1.0" encoding="UTF-8"?>
     2	<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
     3	         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     4	    <modelVersion>4.0.0</modelVersion>
     5	    <groupId>bgu.spl</groupId>
     6	    <artifactId>server</artifactId>
     7	    <version>1.0</version>
     8	    <packaging>jar</packaging>
     9	    <properties>
    10	        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    11	        <maven.compiler.source>1.8</maven.compiler.source>
    12	        <maven.compiler.target>1.8</maven.compiler.target>
    13	    </properties>
    14	    <name>server</name>
    15	</project>



===== FILE: ./server/src/main/java/bgu/spl/net/api/MessageEncoderDecoder.java =====
     1	package bgu.spl.net.api;
     2	
     3	public interface MessageEncoderDecoder<T> {
     4	
     5	    /**
     6	     * add the next byte to the decoding process
     7	     *
     8	     * @param nextByte the next byte to consider for the currently decoded
     9	     * message
    10	     * @return a message if this byte completes one or null if it doesnt.
    11	     */
    12	    T decodeNextByte(byte nextByte);
    13	
    14	    /**
    15	     * encodes the given message to bytes array
    16	     *
    17	     * @param message the message to encode
    18	     * @return the encoded bytes
    19	     */
    20	    byte[] encode(T message);
    21	
    22	}



===== FILE: ./server/src/main/java/bgu/spl/net/api/MessagingProtocol.java =====
     1	package bgu.spl.net.api;
     2	
     3	public interface MessagingProtocol<T> {
     4	 
     5	    /**
     6	     * process the given message 
     7	     * @param msg the received message
     8	     * @return the response to send or null if no response is expected by the client
     9	     */
    10	    T process(T msg);
    11	 
    12	    /**
    13	     * @return true if the connection should be terminated
    14	     */
    15	    boolean shouldTerminate();
    16	 
    17	}



===== FILE: ./server/src/main/java/bgu/spl/net/api/StompMessagingProtocol.java =====
     1	package bgu.spl.net.api;
     2	
     3	import bgu.spl.net.srv.Connections;
     4	
     5	public interface StompMessagingProtocol<T> extends MessagingProtocol<T> {
     6		/**
     7		 * Used to initiate the current client protocol with it's personal connection ID and the connections implementation
     8		**/
     9	    void start(int connectionId, Connections<T> connections);
    10	    
    11	    //void process(T message);
    12		
    13		/**
    14	     * @return true if the connection should be terminated
    15	     */
    16	    boolean shouldTerminate();
    17	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/data/Database.java =====
     1	package bgu.spl.net.impl.data;
     2	
     3	import java.io.BufferedReader;
     4	import java.io.InputStreamReader;
     5	import java.io.PrintWriter;
     6	import java.net.Socket;
     7	import java.util.concurrent.ConcurrentHashMap;
     8	
     9	public class Database {
    10		private final ConcurrentHashMap<String, User> userMap;
    11		private final ConcurrentHashMap<Integer, User> connectionsIdMap;
    12		private final String sqlHost;
    13		private final int sqlPort;
    14	
    15		private Database() {
    16			userMap = new ConcurrentHashMap<>();
    17			connectionsIdMap = new ConcurrentHashMap<>();
    18			// SQL server connection details
    19			this.sqlHost = "127.0.0.1";
    20			this.sqlPort = 7778;
    21		}
    22	
    23		public static Database getInstance() {
    24			return Instance.instance;
    25		}
    26	
    27		/**
    28		 * Execute SQL query and return result
    29		 * @param sql SQL query string
    30		 * @return Result string from SQL server
    31		 */
    32		private String executeSQL(String sql) {
    33			try (Socket socket = new Socket(sqlHost, sqlPort);
    34				 PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
    35				 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {
    36				
    37				// Send SQL with null terminator
    38				out.print(sql + '\0');
    39				out.flush();
    40				
    41				// Read response until null terminator
    42				StringBuilder response = new StringBuilder();
    43				int ch;
    44				while ((ch = in.read()) != -1 && ch != '\0') {
    45					response.append((char) ch);
    46				}
    47				
    48				return response.toString();
    49				
    50			} catch (Exception e) {
    51				System.err.println("SQL Error: " + e.getMessage());
    52				return "ERROR:" + e.getMessage();
    53			}
    54		}
    55	
    56		/**
    57		 * Escape SQL special characters to prevent SQL injection
    58		 */
    59		private String escapeSql(String str) {
    60			if (str == null) return "";
    61			return str.replace("'", "''");
    62		}
    63	
    64		public void addUser(User user) {
    65			userMap.putIfAbsent(user.name, user);
    66			connectionsIdMap.putIfAbsent(user.getConnectionId(), user);
    67		}
    68	
    69		public LoginStatus login(int connectionId, String username, String password) {
    70			if (connectionsIdMap.containsKey(connectionId)) {
    71				return LoginStatus.CLIENT_ALREADY_CONNECTED;
    72			}
    73			if (addNewUserCase(connectionId, username, password)) {
    74				// Log new user registration in SQL
    75				String sql = String.format(
    76					"INSERT INTO users (username, password, registration_date) VALUES ('%s', '%s', datetime('now'))",
    77					escapeSql(username), escapeSql(password)
    78				);
    79				executeSQL(sql);
    80				
    81				// Log login
    82				logLogin(username);
    83				return LoginStatus.ADDED_NEW_USER;
    84			} else {
    85				LoginStatus status = userExistsCase(connectionId, username, password);
    86				if (status == LoginStatus.LOGGED_IN_SUCCESSFULLY) {
    87					// Log successful login in SQL
    88					logLogin(username);
    89				}
    90				return status;
    91			}
    92		}
    93	
    94		private void logLogin(String username) {
    95			String sql = String.format(
    96				"INSERT INTO login_history (username, login_time) VALUES ('%s', datetime('now'))",
    97				escapeSql(username)
    98			);
    99			executeSQL(sql);
   100		}
   101	
   102		private LoginStatus userExistsCase(int connectionId, String username, String password) {
   103			User user = userMap.get(username);
   104			synchronized (user) {
   105				if (user.isLoggedIn()) {
   106					return LoginStatus.ALREADY_LOGGED_IN;
   107				} else if (!user.password.equals(password)) {
   108					return LoginStatus.WRONG_PASSWORD;
   109				} else {
   110					user.login();
   111					user.setConnectionId(connectionId);
   112					connectionsIdMap.put(connectionId, user);
   113					return LoginStatus.LOGGED_IN_SUCCESSFULLY;
   114				}
   115			}
   116		}
   117	
   118		private boolean addNewUserCase(int connectionId, String username, String password) {
   119			if (!userMap.containsKey(username)) {
   120				synchronized (userMap) {
   121					if (!userMap.containsKey(username)) {
   122						User user = new User(connectionId, username, password);
   123						user.login();
   124						addUser(user);
   125						return true;
   126					}
   127				}
   128			}
   129			return false;
   130		}
   131	
   132		public void logout(int connectionsId) {
   133			User user = connectionsIdMap.get(connectionsId);
   134			if (user != null) {
   135				// Log logout in SQL
   136				String sql = String.format(
   137					"UPDATE login_history SET logout_time=datetime('now') " +
   138					"WHERE username='%s' AND logout_time IS NULL " +
   139					"ORDER BY login_time DESC LIMIT 1",
   140					escapeSql(user.name)
   141				);
   142				executeSQL(sql);
   143				
   144				user.logout();
   145				connectionsIdMap.remove(connectionsId);
   146			}
   147		}
   148	
   149		/**
   150		 * Track file upload in SQL database
   151		 * @param username User who uploaded the file
   152		 * @param filename Name of the file
   153		 * @param gameChannel Game channel the file was reported to
   154		 */
   155		public void trackFileUpload(String username, String filename, String gameChannel) {
   156			String sql = String.format(
   157				"INSERT INTO file_tracking (username, filename, upload_time, game_channel) " +
   158				"VALUES ('%s', '%s', datetime('now'), '%s')",
   159				escapeSql(username), escapeSql(filename), escapeSql(gameChannel)
   160			);
   161			executeSQL(sql);
   162		}
   163	
   164		/**
   165		 * Generate and print server report using SQL queries
   166		 */
   167		public void printReport() {
   168			System.out.println(repeat("=", 80));
   169			System.out.println("SERVER REPORT - Generated at: " + java.time.LocalDateTime.now());
   170			System.out.println(repeat("=", 80));
   171			
   172			// List all users
   173			System.out.println("\n1. REGISTERED USERS:");
   174			System.out.println(repeat("-", 80));
   175			String usersSQL = "SELECT username, registration_date FROM users ORDER BY registration_date";
   176			String usersResult = executeSQL(usersSQL);
   177			if (usersResult.startsWith("SUCCESS")) {
   178				String[] parts = usersResult.split("\\|");
   179				if (parts.length > 1) {
   180					for (int i = 1; i < parts.length; i++) {
   181						System.out.println("   " + parts[i]);
   182					}
   183				} else {
   184					System.out.println("   No users registered");
   185				}
   186			}
   187			
   188			// Login history for each user
   189			System.out.println("\n2. LOGIN HISTORY:");
   190			System.out.println(repeat("-", 80));
   191			String loginSQL = "SELECT username, login_time, logout_time FROM login_history ORDER BY username, login_time DESC";
   192			String loginResult = executeSQL(loginSQL);
   193			if (loginResult.startsWith("SUCCESS")) {
   194				String[] parts = loginResult.split("\\|");
   195				if (parts.length > 1) {
   196					String currentUser = "";
   197					for (int i = 1; i < parts.length; i++) {
   198						String[] fields = parts[i].replace("(", "").replace(")", "").replace("'", "").split(", ");
   199						if (fields.length >= 3) {
   200							if (!fields[0].equals(currentUser)) {
   201								currentUser = fields[0];
   202								System.out.println("\n   User: " + currentUser);
   203							}
   204							System.out.println("      Login:  " + fields[1]);
   205							System.out.println("      Logout: " + (fields[2].equals("None") ? "Still logged in" : fields[2]));
   206						}
   207					}
   208				} else {
   209					System.out.println("   No login history");
   210				}
   211			}
   212			
   213			// File uploads for each user
   214			System.out.println("\n3. FILE UPLOADS:");
   215			System.out.println(repeat("-", 80));
   216			String filesSQL = "SELECT username, filename, upload_time, game_channel FROM file_tracking ORDER BY username, upload_time DESC";
   217			String filesResult = executeSQL(filesSQL);
   218			if (filesResult.startsWith("SUCCESS")) {
   219				String[] parts = filesResult.split("\\|");
   220				if (parts.length > 1) {
   221					String currentUser = "";
   222					for (int i = 1; i < parts.length; i++) {
   223						String[] fields = parts[i].replace("(", "").replace(")", "").replace("'", "").split(", ");
   224						if (fields.length >= 4) {
   225							if (!fields[0].equals(currentUser)) {
   226								currentUser = fields[0];
   227								System.out.println("\n   User: " + currentUser);
   228							}
   229							System.out.println("      File: " + fields[1]);
   230							System.out.println("      Time: " + fields[2]);
   231							System.out.println("      Game: " + fields[3]);
   232							System.out.println();
   233						}
   234					}
   235				} else {
   236					System.out.println("   No files uploaded");
   237				}
   238			}
   239			
   240		System.out.println(repeat("=", 80));
   241	}
   242	
   243	private String repeat(String str, int times) {
   244		StringBuilder sb = new StringBuilder();
   245		for (int i = 0; i < times; i++) {
   246			sb.append(str);
   247		}
   248		return sb.toString();
   249	}
   250	
   251	private static class Instance {
   252		static Database instance = new Database();
   253	}}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/data/LoginStatus.java =====
     1	package bgu.spl.net.impl.data;
     2	
     3	public enum LoginStatus {
     4		CLIENT_ALREADY_CONNECTED, ADDED_NEW_USER, ALREADY_LOGGED_IN, LOGGED_IN_SUCCESSFULLY, WRONG_PASSWORD
     5	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/data/User.java =====
     1	package bgu.spl.net.impl.data;
     2	
     3	public class User {
     4		public final String name;
     5		public final String password;
     6		private int connectionId;
     7		private boolean isLoggedIn = false;
     8	
     9		public User(int connectionId, String name, String password) {
    10			this.connectionId = connectionId;
    11			this.name = name;
    12			this.password = password;
    13		}
    14	
    15		public boolean isLoggedIn() {
    16			return isLoggedIn;
    17		}
    18	
    19		public void login() {
    20			isLoggedIn = true;
    21		}
    22	
    23		public void logout() {
    24			isLoggedIn = false;
    25		}
    26	
    27		public int getConnectionId() {
    28			return connectionId;
    29		}
    30	
    31		public void setConnectionId(int connectionId) {
    32			this.connectionId = connectionId;
    33		}
    34	
    35	
    36	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/echo/EchoClient.java =====
     1	package bgu.spl.net.impl.echo;
     2	
     3	import java.io.BufferedReader;
     4	import java.io.BufferedWriter;
     5	import java.io.IOException;
     6	import java.io.InputStreamReader;
     7	import java.io.OutputStreamWriter;
     8	import java.net.Socket;
     9	
    10	public class EchoClient {
    11	
    12	    public static void main(String[] args) throws IOException {
    13	
    14	        if (args.length == 0) {
    15	            args = new String[]{"localhost", "hello"};
    16	        }
    17	
    18	        if (args.length < 2) {
    19	            System.out.println("you must supply two arguments: host, message");
    20	            System.exit(1);
    21	        }
    22	
    23	        //BufferedReader and BufferedWriter automatically using UTF-8 encoding
    24	        try (Socket sock = new Socket(args[0], 7777);
    25	                BufferedReader in = new BufferedReader(new InputStreamReader(sock.getInputStream()));
    26	                BufferedWriter out = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()))) {
    27	
    28	            System.out.println("sending message to server");
    29	            out.write(args[1]);
    30	            out.newLine();
    31	            out.flush();
    32	
    33	            System.out.println("awaiting response");
    34	            String line = in.readLine();
    35	            System.out.println("message from server: " + line);
    36	        }
    37	    }
    38	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/echo/EchoProtocol.java =====
     1	package bgu.spl.net.impl.echo;
     2	
     3	import bgu.spl.net.api.MessagingProtocol;
     4	import java.time.LocalDateTime;
     5	
     6	public class EchoProtocol implements MessagingProtocol<String> {
     7	
     8	    private boolean shouldTerminate = false;
     9	
    10	    @Override
    11	    public String process(String msg) {
    12	        shouldTerminate = "bye".equals(msg);
    13	        System.out.println("[" + LocalDateTime.now() + "]: " + msg);
    14	        return createEcho(msg);
    15	    }
    16	
    17	    private String createEcho(String message) {
    18	        String echoPart = message.substring(Math.max(message.length() - 2, 0), message.length());
    19	        return message + " .. " + echoPart + " .. " + echoPart + " ..";
    20	    }
    21	
    22	    @Override
    23	    public boolean shouldTerminate() {
    24	        return shouldTerminate;
    25	    }
    26	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/echo/EchoServer.java =====
     1	package bgu.spl.net.impl.echo;
     2	
     3	import bgu.spl.net.srv.Server;
     4	
     5	public class EchoServer {
     6	
     7	    public static void main(String[] args) {
     8	
     9	        // you can use any server... 
    10	        Server.threadPerClient(
    11	                7777, //port
    12	                () -> new EchoProtocol(), //protocol factory
    13	                LineMessageEncoderDecoder::new //message encoder decoder factory
    14	        ).serve();
    15	
    16	        // Server.reactor(
    17	        //         Runtime.getRuntime().availableProcessors(),
    18	        //         7777, //port
    19	        //         () -> new EchoProtocol<>(), //protocol factory
    20	        //         LineMessageEncoderDecoder::new //message encoder decoder factory
    21	        // ).serve();
    22	    }
    23	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/echo/LineMessageEncoderDecoder.java =====
     1	package bgu.spl.net.impl.echo;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	import java.nio.charset.StandardCharsets;
     5	import java.util.Arrays;
     6	
     7	public class LineMessageEncoderDecoder implements MessageEncoderDecoder<String> {
     8	
     9	    private byte[] bytes = new byte[1 << 10]; //start with 1k
    10	    private int len = 0;
    11	
    12	    @Override
    13	    public String decodeNextByte(byte nextByte) {
    14	        //notice that the top 128 ascii characters have the same representation as their utf-8 counterparts
    15	        //this allow us to do the following comparison
    16	        if (nextByte == '\n') {
    17	            return popString();
    18	        }
    19	
    20	        pushByte(nextByte);
    21	        return null; //not a line yet
    22	    }
    23	
    24	    @Override
    25	    public byte[] encode(String message) {
    26	        return (message + "\n").getBytes(); //uses utf8 by default
    27	    }
    28	
    29	    private void pushByte(byte nextByte) {
    30	        if (len >= bytes.length) {
    31	            bytes = Arrays.copyOf(bytes, len * 2);
    32	        }
    33	
    34	        bytes[len++] = nextByte;
    35	    }
    36	
    37	    private String popString() {
    38	        //notice that we explicitly requesting that the string will be decoded from UTF-8
    39	        //this is not actually required as it is the default encoding in java.
    40	        String result = new String(bytes, 0, len, StandardCharsets.UTF_8);
    41	        len = 0;
    42	        return result;
    43	    }
    44	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/newsfeed/FetchNewsCommand.java =====
     1	package bgu.spl.net.impl.newsfeed;
     2	
     3	import bgu.spl.net.impl.rci.Command;
     4	import java.io.Serializable;
     5	
     6	public class FetchNewsCommand implements Command<NewsFeed> {
     7	
     8	    private String channel;
     9	
    10	    public FetchNewsCommand(String channel) {
    11	        this.channel = channel;
    12	    }
    13	
    14	    @Override
    15	    public Serializable execute(NewsFeed feed) {
    16	        return feed.fetch(channel);
    17	    }
    18	
    19	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/newsfeed/NewsFeed.java =====
     1	package bgu.spl.net.impl.newsfeed;
     2	
     3	import java.util.ArrayList;
     4	import java.util.concurrent.ConcurrentHashMap;
     5	import java.util.concurrent.ConcurrentLinkedQueue;
     6	
     7	public class NewsFeed {
     8	
     9	    private ConcurrentHashMap<String, ConcurrentLinkedQueue<String>> channels = new ConcurrentHashMap<>();
    10	
    11	    public ArrayList<String> fetch(String channel) {
    12	        ConcurrentLinkedQueue<String> queue = channels.get(channel);
    13	        if (queue == null) {
    14	            return new ArrayList<>(0); //empty
    15	        } else {
    16	            return new ArrayList<>(queue); //copy of the queue, arraylist is serializable
    17	        }
    18	    }
    19	
    20	    public void publish(String channel, String news) {
    21	        ConcurrentLinkedQueue<String> queue = channels.computeIfAbsent(channel, k -> new ConcurrentLinkedQueue<>());
    22	        queue.add(news);
    23	    }
    24	
    25	    public void clear() {
    26	        channels.clear();
    27	    }
    28	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/newsfeed/NewsFeedClientMain.java =====
     1	package bgu.spl.net.impl.newsfeed;
     2	
     3	import bgu.spl.net.impl.rci.RCIClient;
     4	
     5	public class NewsFeedClientMain {
     6	
     7	    public static void main(String[] args) throws Exception {
     8	        if (args.length == 0) {
     9	            args = new String[]{"127.0.0.1"};
    10	        }
    11	
    12	//        System.out.println("running clients");
    13	        runFirstClient(args[0]);
    14	        runSecondClient(args[0]);
    15	        runThirdClient(args[0]);
    16	    }
    17	
    18	    private static void runFirstClient(String host) throws Exception {
    19	        try (RCIClient c = new RCIClient(host, 7777)) {
    20	            c.send(new PublishNewsCommand(
    21	                    "jobs",
    22	                    "System Programmer, knowledge in C++, Java and Python required. call 0x134693F"));
    23	
    24	            c.receive(); //ok
    25	
    26	            c.send(new PublishNewsCommand(
    27	                    "headlines",
    28	                    "new SPL assignment is out soon!!"));
    29	
    30	            c.receive(); //ok
    31	
    32	            c.send(new PublishNewsCommand(
    33	                    "headlines",
    34	                    "THE CAKE IS A LIE!"));
    35	
    36	            c.receive(); //ok
    37	        }
    38	
    39	    }
    40	
    41	    private static void runSecondClient(String host) throws Exception {
    42	        try (RCIClient c = new RCIClient(host, 7777)) {
    43	            c.send(new FetchNewsCommand("jobs"));
    44	            System.out.println("second client received: " + c.receive());
    45	        }
    46	    }
    47	
    48	    private static void runThirdClient(String host) throws Exception {
    49	        try (RCIClient c = new RCIClient(host, 7777)) {
    50	            c.send(new FetchNewsCommand("headlines"));
    51	            System.out.println("third client received: " + c.receive());
    52	        }
    53	    }
    54	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/newsfeed/NewsFeedServerMain.java =====
     1	package bgu.spl.net.impl.newsfeed;
     2	
     3	import bgu.spl.net.impl.rci.ObjectEncoderDecoder;
     4	import bgu.spl.net.impl.rci.RemoteCommandInvocationProtocol;
     5	import bgu.spl.net.srv.Server;
     6	
     7	public class NewsFeedServerMain {
     8	
     9	    public static void main(String[] args) {
    10	        NewsFeed feed = new NewsFeed(); //one shared object
    11	
    12	        // you can use any server... 
    13	        Server.threadPerClient(
    14	                7777, //port
    15	                () -> new RemoteCommandInvocationProtocol<>(feed), //protocol factory
    16	                ObjectEncoderDecoder::new //message encoder decoder factory
    17	        ).serve();
    18	
    19	        // Server.reactor(
    20	        //         Runtime.getRuntime().availableProcessors(),
    21	        //         7777, //port
    22	        //         () ->  new RemoteCommandInvocationProtocol<>(feed), //protocol factory
    23	        //         ObjectEncoderDecoder::new //message encoder decoder factory
    24	        // ).serve();
    25	    }
    26	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/newsfeed/PublishNewsCommand.java =====
     1	package bgu.spl.net.impl.newsfeed;
     2	
     3	import bgu.spl.net.impl.rci.Command;
     4	import java.io.Serializable;
     5	
     6	public class PublishNewsCommand implements Command<NewsFeed> {
     7	 
     8	    private String channel;
     9	    private String news;
    10	 
    11	    public PublishNewsCommand(String channel, String news) {
    12	        this.channel = channel;
    13	        this.news = news;
    14	    }
    15	 
    16	    @Override
    17	    public Serializable execute(NewsFeed feed) {
    18	        feed.publish(channel, news);
    19	        return "OK";
    20	    }
    21	 
    22	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/rci/Command.java =====
     1	package bgu.spl.net.impl.rci;
     2	
     3	import java.io.Serializable;
     4	
     5	public interface Command<T> extends Serializable {
     6	
     7	    Serializable execute(T arg);
     8	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/rci/ObjectEncoderDecoder.java =====
     1	package bgu.spl.net.impl.rci;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	import java.io.ByteArrayInputStream;
     5	import java.io.ByteArrayOutputStream;
     6	import java.io.ObjectInput;
     7	import java.io.ObjectInputStream;
     8	import java.io.ObjectOutput;
     9	import java.io.ObjectOutputStream;
    10	import java.io.Serializable;
    11	import java.nio.ByteBuffer;
    12	
    13	public class ObjectEncoderDecoder implements MessageEncoderDecoder<Serializable> {
    14	
    15	    private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);
    16	    private byte[] objectBytes = null;
    17	    private int objectBytesIndex = 0;
    18	
    19	    @Override
    20	    public Serializable decodeNextByte(byte nextByte) {
    21	        if (objectBytes == null) { //indicates that we are still reading the length
    22	            lengthBuffer.put(nextByte);
    23	            if (!lengthBuffer.hasRemaining()) { //we read 4 bytes and therefore can take the length
    24	                lengthBuffer.flip();
    25	                objectBytes = new byte[lengthBuffer.getInt()];
    26	                objectBytesIndex = 0;
    27	                lengthBuffer.clear();
    28	            }
    29	        } else {
    30	            objectBytes[objectBytesIndex] = nextByte;
    31	            if (++objectBytesIndex == objectBytes.length) {
    32	                Serializable result = deserializeObject();
    33	                objectBytes = null;
    34	                return result;
    35	            }
    36	        }
    37	
    38	        return null;
    39	    }
    40	
    41	    @Override
    42	    public byte[] encode(Serializable message) {
    43	        return serializeObject(message);
    44	    }
    45	
    46	    private Serializable deserializeObject() {
    47	        try {
    48	            ObjectInput in = new ObjectInputStream(new ByteArrayInputStream(objectBytes));
    49	            return (Serializable) in.readObject();
    50	        } catch (Exception ex) {
    51	            throw new IllegalArgumentException("cannot desrialize object", ex);
    52	        }
    53	
    54	    }
    55	
    56	    private byte[] serializeObject(Serializable message) {
    57	        try {
    58	            ByteArrayOutputStream bytes = new ByteArrayOutputStream();
    59	
    60	            //placeholder for the object size
    61	            for (int i = 0; i < 4; i++) {
    62	                bytes.write(0);
    63	            }
    64	
    65	            ObjectOutput out = new ObjectOutputStream(bytes);
    66	            out.writeObject(message);
    67	            out.flush();
    68	            byte[] result = bytes.toByteArray();
    69	
    70	            //now write the object size
    71	            ByteBuffer.wrap(result).putInt(result.length - 4);
    72	            return result;
    73	
    74	        } catch (Exception ex) {
    75	            throw new IllegalArgumentException("cannot serialize object", ex);
    76	        }
    77	    }
    78	
    79	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/rci/RCIClient.java =====
     1	package bgu.spl.net.impl.rci;
     2	
     3	import java.io.BufferedInputStream;
     4	import java.io.BufferedOutputStream;
     5	import java.io.Closeable;
     6	import java.io.IOException;
     7	import java.io.Serializable;
     8	import java.net.Socket;
     9	
    10	public class RCIClient implements Closeable {
    11	
    12	    private final ObjectEncoderDecoder encdec;
    13	    private final Socket sock;
    14	    private final BufferedInputStream in;
    15	    private final BufferedOutputStream out;
    16	
    17	    public RCIClient(String host, int port) throws IOException {
    18	        sock = new Socket(host, port);
    19	        encdec = new ObjectEncoderDecoder();
    20	        in = new BufferedInputStream(sock.getInputStream());
    21	        out = new BufferedOutputStream(sock.getOutputStream());
    22	    }
    23	
    24	    public void send(Command<?> cmd) throws IOException {
    25	        out.write(encdec.encode(cmd));
    26	        out.flush();
    27	    }
    28	
    29	    public Serializable receive() throws IOException {
    30	        int read;
    31	        while ((read = in.read()) >= 0) {
    32	            Serializable msg = encdec.decodeNextByte((byte) read);
    33	            if (msg != null) {
    34	                return msg;
    35	            }
    36	        }
    37	
    38	        throw new IOException("disconnected before complete reading message");
    39	    }
    40	
    41	    @Override
    42	    public void close() throws IOException {
    43	        out.close();
    44	        in.close();
    45	        sock.close();
    46	    }
    47	
    48	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/rci/RemoteCommandInvocationProtocol.java =====
     1	package bgu.spl.net.impl.rci;
     2	
     3	import bgu.spl.net.api.MessagingProtocol;
     4	import java.io.Serializable;
     5	
     6	public class RemoteCommandInvocationProtocol<T> implements MessagingProtocol<Serializable> {
     7	
     8	    private T arg;
     9	
    10	    public RemoteCommandInvocationProtocol(T arg) {
    11	        this.arg = arg;
    12	    }
    13	
    14	    @Override
    15	    public Serializable process(Serializable msg) {
    16	        return ((Command) msg).execute(arg);
    17	    }
    18	
    19	    @Override
    20	    public boolean shouldTerminate() {
    21	        return false;
    22	    }
    23	
    24	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/stomp/StompFrame.java =====
     1	package bgu.spl.net.impl.stomp;
     2	
     3	import java.util.HashMap;
     4	import java.util.Map;
     5	
     6	public class StompFrame {
     7	    private String command;
     8	    private Map<String,String> headers = new HashMap<>();
     9	    private String body;
    10	
    11	    public StompFrame(String commands) {
    12	        this.command = commands;
    13	    }
    14	    public StompFrame(StompFrame other) {
    15	        this.command = other.command;
    16	        this.headers = new HashMap<>(other.headers);
    17	        this.body = other.body;
    18	    }
    19	    public String getCommand() {
    20	        return command;
    21	    }
    22	    public void addHeader(String key, String value) {
    23	        headers.put(key, value);
    24	    }
    25	    public String getHeader(String key) {
    26	        return headers.get(key);
    27	    }
    28	    public void setBody(String body) {
    29	        this.body = body;
    30	    }
    31	    public String getBody() {
    32	        return this.body;
    33	    }
    34	
    35	    public static StompFrame fromString(String rawMessage) {
    36	        StompFrame ret = null;
    37	        int i = 0;
    38	
    39	        if (rawMessage == null || rawMessage.length() == 0) {
    40	            return null;
    41	        }
    42	
    43	        String[] lines = rawMessage.split("\n");
    44	
    45	        // COMMAND
    46	        ret = new StompFrame(lines[i].trim());
    47	        i++;
    48	
    49	        // HEADERS - until end of lines or an empty line
    50	        for (i = 1; i < lines.length && !lines[i].isEmpty(); i++) {
    51	            String[] parts = lines[i].split(":", 2);
    52	            // Add new Header to frame
    53	            if (parts.length == 2) {
    54	                ret.addHeader(parts[0].trim(), parts[1].trim());
    55	            }
    56	        }
    57	
    58	        // BODY - build body until end of message
    59	        StringBuilder bodyBuilder = new StringBuilder();
    60	
    61	        // if we got to an empty line
    62	        if (i != lines.length) {
    63	            i++; // continuing after empty line
    64	            for (; i < lines.length; i++) {
    65	                bodyBuilder.append(lines[i]);
    66	
    67	                // add new line
    68	                if (i < lines.length - 1) {
    69	                    bodyBuilder.append("\n");
    70	                }
    71	            }
    72	        }
    73	
    74	        ret.setBody(bodyBuilder.toString());
    75	
    76	        return ret;
    77	    }
    78	
    79	    @Override
    80	    public String toString() {
    81	        StringBuilder sb = new StringBuilder();
    82	
    83	        // 1. Command
    84	        sb.append(command).append("\n");
    85	
    86	        // 2. Headers
    87	        for (Map.Entry<String, String> header : headers.entrySet()) {
    88	            sb.append(header.getKey())
    89	                    .append(":")
    90	                    .append(header.getValue())
    91	                    .append("\n");
    92	        }
    93	
    94	        // 3. Empty Line - SEPARATION
    95	        sb.append("\n");
    96	
    97	        // 4. Body
    98	        if (body != null && !body.isEmpty()) {
    99	            sb.append(body);
   100	        }
   101	
   102	        return sb.toString();
   103	    }
   104	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/stomp/StompMessageEncoderDecoder.java =====
     1	package bgu.spl.net.impl.stomp;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	
     5	public class StompMessageEncoderDecoder implements MessageEncoderDecoder<StompFrame> {
     6	    private byte[] bytes = new byte[1024];
     7	    private int len = 0;
     8	    private static final int MAX_MESSAGE_SIZE = 1 << 20;
     9	    @Override
    10	    public StompFrame decodeNextByte(byte nextByte) {
    11	        if(nextByte == '\0'){
    12	            System.err.println("\n DEBUG: Decoder found NULL char. Buffer len: " + len);
    13	            return popMessage();
    14	        }
    15	        pushByte(nextByte);
    16	        return null;
    17	    }
    18	
    19	    private void pushByte(byte nextByte) {
    20	        if (len >= MAX_MESSAGE_SIZE) {
    21	            throw new RuntimeException("Message size limit exceeded");
    22	        }
    23	        // if needed, resize the array
    24	        if (len >= bytes.length) {
    25	            //double the size of the array
    26	            bytes = java.util.Arrays.copyOf(bytes, len * 2);
    27	        }
    28	        bytes[len++] = nextByte;   
    29	    }
    30	    // when we get here we have a full message
    31	    private StompFrame popMessage() {
    32	        String message = new String(bytes,0,len, java.nio.charset.StandardCharsets.UTF_8);
    33	        len = 0;
    34	        return StompFrame.fromString(message);
    35	    }
    36	
    37	    @Override
    38	    public byte[] encode(StompFrame message) {
    39	        StringBuilder strMessage = new StringBuilder(message.toString());
    40	        strMessage.append('\0');
    41	        return strMessage.toString().getBytes(java.nio.charset.StandardCharsets.UTF_8);
    42	    }
    43	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/stomp/StompMessagingProtocolImpl.java =====
     1	package bgu.spl.net.impl.stomp;
     2	
     3	import java.util.Map;
     4	import java.util.concurrent.ConcurrentHashMap;
     5	import java.util.concurrent.atomic.AtomicInteger;
     6	
     7	import bgu.spl.net.impl.data.Database;
     8	import bgu.spl.net.api.StompMessagingProtocol;
     9	import bgu.spl.net.impl.data.LoginStatus;
    10	import bgu.spl.net.srv.Connections;
    11	
    12	public class StompMessagingProtocolImpl implements StompMessagingProtocol<StompFrame> {
    13	    private int connectionId;
    14	    private Connections<StompFrame> connections;
    15	    private boolean shouldTerminate = false;
    16	    private boolean isLoggedIn = false;
    17	    private String currentUser = null;
    18	    private Map<String, String> subscriptions = new ConcurrentHashMap<>();
    19	    private static AtomicInteger messageIdCounter = new AtomicInteger(0);
    20	
    21	    @Override
    22	    public void start(int connectionId, Connections<StompFrame> connections) {
    23	        this.connectionId = connectionId;
    24	        this.connections = connections;
    25	    }
    26	    @Override
    27	    public StompFrame process(StompFrame frame) {
    28	        System.out.println(" DEBUG [SERVER RCV from " + connectionId + "]:\n" + frame.toString());
    29	        System.out.println("----------------------------------------");
    30	        String command = frame.getCommand();
    31	        // Check if user is logged in for commands other than CONNECT
    32	        if(!isLoggedIn && !command.equals("CONNECT")) {
    33	            sendError(frame, "User not logged in", "You must log in before sending other commands.");
    34	        }
    35	        else{
    36	            switch (command) {
    37	                case "CONNECT":
    38	                    handleConnect(frame);
    39	                    break;
    40	                case "SEND":
    41	                    handleSend(frame);
    42	                    break;
    43	                case "SUBSCRIBE":
    44	                    handleSubscribe(frame);
    45	                    break;
    46	                case "UNSUBSCRIBE":
    47	                    handleUnsubscribe(frame);
    48	                    break;
    49	                case "DISCONNECT":
    50	                    handleDisconnect(frame);
    51	                    break;
    52	                default:
    53	                    sendError(frame, "Unknown command", "The command '" + command + "' is not recognized.");
    54	                    shouldTerminate = true;
    55	                    break;
    56	        }
    57	    }
    58	    return null;
    59	}
    60	
    61	    private void handleDisconnect(StompFrame frame) {
    62	        if (!isLoggedIn) {
    63	            sendError(frame, "Not logged in", "You must be logged in to disconnect.");
    64	            return;
    65	        }
    66	
    67	        String receipt = frame.getHeader("receipt");
    68	        if (receipt != null) {
    69	            sendReceipt(receipt);
    70	        }
    71	
    72	        // Perform logout
    73	        Database.getInstance().logout(connectionId);
    74	        this.shouldTerminate = true;
    75	    }
    76	    private void handleUnsubscribe(StompFrame frame) {
    77	        if (!isLoggedIn) {
    78	            sendError(frame, "Not logged in", "You must be logged in to unsubscribe.");
    79	            return;
    80	        }
    81	
    82	        String requestId = frame.getHeader("id");
    83	
    84	        if (requestId == null || requestId.isEmpty()) {
    85	            sendError(frame, "Malformed UNSUBSCRIBE", "Missing 'id' header.");
    86	            return;
    87	        }
    88	        // Check if subscribed with the given id
    89	        String destination = subscriptions.remove(requestId);
    90	        if (destination == null) {
    91	            sendError(frame, "Subscription not found", "No active subscription found with ID: " + requestId);
    92	            return;
    93	        }
    94	
    95	        connections.unsubscribe(destination, connectionId, requestId);
    96	
    97	        // Handle receipt if requested
    98	        String receipt = frame.getHeader("receipt");
    99	        if (receipt != null) {
   100	            sendReceipt(receipt);
   101	        }
   102	    }
   103	    private void handleSubscribe(StompFrame frame) {
   104	        System.err.println("DEBUG Handling SUBSCRIBE frame");
   105	        if (!isLoggedIn) {
   106	            sendError(frame, "Not logged in", "You must be logged in to subscribe.");
   107	            return;
   108	        }
   109	
   110	        String destination = frame.getHeader("destination");
   111	        String requestId = frame.getHeader("id");
   112	
   113	        if (destination == null || destination.isEmpty() || requestId == null || requestId.isEmpty()) {
   114	            sendError(frame, "Malformed SUBSCRIBE", "Missing 'destination' or 'id' header.");            return;
   115	        }
   116	
   117	        // Check if already subscribed with the same id
   118	        if (subscriptions.containsKey(requestId)) {
   119	            sendError(frame, "Already subscribed", "You are already subscribed with id '" + requestId + "'.");
   120	            return;
   121	        }
   122	
   123	        subscriptions.put(requestId, destination);
   124	        
   125	        connections.subscribe(destination, connectionId, requestId);
   126	
   127	        // Handle receipt if requested
   128	        String receipt = frame.getHeader("receipt");
   129	        if (receipt != null) {
   130	            sendReceipt(receipt);
   131	        }
   132	    }
   133	    private void handleSend(StompFrame frame) {
   134	        if (!isLoggedIn) {
   135	            sendError(frame, "Not logged in", "You must be logged in to send messages.");
   136	            return;
   137	        }
   138	
   139	        String destination = frame.getHeader("destination");
   140	        if (destination == null || destination.isEmpty()) {
   141	            sendError(frame, "Missing destination", "SEND frame must include a destination header.");
   142	            return;
   143	        }
   144	
   145	        if (!subscriptions.containsValue(destination)) {
   146	            sendError(frame, "Not subscribed", "You cannot send to '" + destination + "' without subscribing first.");
   147	            return;
   148	        }
   149	
   150	        /*// Track file upload if 'file-name' header is present
   151	        String filename = frame.getHeader("file-name"); 
   152	        if (filename != null) {
   153	            Database.getInstance().trackFileUpload(currentUser, filename, destination);
   154	        }*/
   155	
   156	        StompFrame messageFrame = new StompFrame("MESSAGE");
   157	        messageFrame.addHeader("destination", destination);
   158	        messageFrame.addHeader("message-id", String.valueOf(messageIdCounter.incrementAndGet()));
   159	        // Copy the body and content (Game updates, user, team names, etc.)
   160	        // We don't validate them, we just pass them through.
   161	        messageFrame.setBody(frame.getBody());
   162	
   163	        // Send the MESSAGE frame (not the SEND frame)
   164	        connections.send(destination, messageFrame);
   165	
   166	        // Handle receipt if requested
   167	        String receipt = frame.getHeader("receipt");
   168	        if (receipt != null) {
   169	            sendReceipt(receipt);
   170	        }
   171	}
   172	    private void handleConnect(StompFrame frame) {
   173	        if(isLoggedIn) {
   174	            sendError(frame, "Already logged in", "You are already logged in.");
   175	            return;
   176	        }
   177	        String username = frame.getHeader("login");
   178	        String passcode = frame.getHeader("passcode");
   179	        String acceptVersion = frame.getHeader("accept-version");
   180	        String host = frame.getHeader("host");
   181	
   182	        if (username == null || passcode == null || host == null) {
   183	            sendError(frame, "Missing credentials", "Login or passcode header is missing.");
   184	            return;
   185	        }
   186	        
   187	        LoginStatus status = Database.getInstance().login(connectionId, username, passcode);
   188	        switch (status) {
   189	            case LOGGED_IN_SUCCESSFULLY:
   190	            case ADDED_NEW_USER:
   191	                this.currentUser = username;
   192	                sendConnectedFrame();
   193	                break;
   194	            case CLIENT_ALREADY_CONNECTED:
   195	                sendError(frame, "Client already connected", "This client is already connected.");
   196	                break;
   197	            case ALREADY_LOGGED_IN:
   198	                sendError(frame, "Already logged in", "This user is already logged in.");
   199	                break;
   200	            case WRONG_PASSWORD:
   201	                sendError(frame, "Wrong password", "The passcode you entered is incorrect.");
   202	                break;
   203	            default:
   204	                sendError(frame, "Login failed", "Login failed due to unknown reasons.");
   205	                break;
   206	        }
   207	    }
   208	    @Override
   209	    public boolean shouldTerminate() {
   210	        return shouldTerminate;
   211	    }
   212	    private void sendConnectedFrame() {
   213	        this.isLoggedIn = true;
   214	        StompFrame connectedFrame = new StompFrame("CONNECTED");
   215	        connectedFrame.addHeader("version", "1.2");
   216	        connections.send(connectionId, connectedFrame);
   217	    }
   218	/**
   219	 * Sends a RECEIPT frame to acknowledge that a command with a receipt header was processed.
   220	 * @param receiptId The receipt ID from the original frame's receipt header.
   221	 */
   222	private void sendReceipt(String receiptId) {
   223	    StompFrame receiptFrame = new StompFrame("RECEIPT");
   224	    receiptFrame.addHeader("receipt-id", receiptId);
   225	    connections.send(connectionId, receiptFrame);
   226	}
   227	
   228	/**
   229	 * Sends an ERROR frame in the specific format required by the assignment and closes the connection.
   230	 * * @param faultyFrame The original frame that caused the error (used to extract receipt-id and print in body).
   231	 * @param messageHeader A short description of the error (goes into the 'message' header).
   232	 * @param detailedInfo A detailed explanation (goes into the body).
   233	 */
   234	private void sendError(StompFrame faultyFrame, String messageHeader, String detailedInfo) {
   235	    StompFrame errorFrame = new StompFrame("ERROR");
   236	
   237	    errorFrame.addHeader("message", messageHeader);
   238	
   239	    if (faultyFrame != null) {
   240	        String receipt = faultyFrame.getHeader("receipt");
   241	        if (receipt != null) {
   242	            errorFrame.addHeader("receipt-id", receipt);
   243	        }
   244	    }
   245	
   246	    // Construct the body in the requested format
   247	    StringBuilder body = new StringBuilder();
   248	    body.append("The message:\n");
   249	    body.append("-----\n");
   250	    
   251	    if (faultyFrame != null) {
   252	        // Assuming your StompFrame.toString() returns the frame representation (Command + Headers + Body)
   253	        body.append(faultyFrame.toString()); 
   254	    } else {
   255	        body.append("(No frame content available)");
   256	    }
   257	    
   258	    body.append("\n-----\n");
   259	    body.append(detailedInfo);
   260	    errorFrame.setBody(body.toString());
   261	    connections.send(connectionId, errorFrame);
   262	    
   263	    if (isLoggedIn) {
   264	        Database.getInstance().logout(connectionId);
   265	        isLoggedIn = false;
   266	        currentUser = null;
   267	    }
   268	    this.shouldTerminate = true;
   269	    connections.disconnect(connectionId);
   270	}
   271	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/stomp/StompServer.java =====
     1	package bgu.spl.net.impl.stomp;
     2	
     3	import bgu.spl.net.srv.Server;
     4	
     5	public class StompServer {
     6	
     7	    public static void main(String[] args) {
     8	        if (args.length < 2) {
     9	            System.out.println("Usage: StompServer <port> <server-type>");
    10	            System.out.println("server-type: tpc (Thread Per Client) or reactor");
    11	            return;
    12	        }
    13	
    14	        int port = 0;
    15	        try {
    16	            port = Integer.parseInt(args[0]);
    17	        } catch (NumberFormatException e) {
    18	            System.out.println("Error: Port must be a number.");
    19	            return;
    20	        }
    21	
    22	        String serverType = args[1];
    23	
    24	        if (serverType.equals("tpc")) {
    25	            System.err.println("DEBUG Starting Stomp Server in Thread Per Client mode");
    26	            Server.threadPerClient(
    27	                    port,
    28	                    () -> new StompMessagingProtocolImpl(), // Protocol Factory 
    29	                    () -> new StompMessageEncoderDecoder()         // Encoder Factory
    30	            ).serve();
    31	
    32	        } else if (serverType.equals("reactor")) {
    33	            Server.reactor(
    34	                    Runtime.getRuntime().availableProcessors(),
    35	                    port,
    36	                    () -> new StompMessagingProtocolImpl(), // Protocol Factory (Lambda)
    37	                    () -> new StompMessageEncoderDecoder()         // Encoder Factory (Lambda)
    38	            ).serve();
    39	
    40	        } else {
    41	            System.out.println("Unknown server type: " + serverType);
    42	            System.out.println("Please use 'tpc' or 'reactor'.");
    43	        }
    44	    }
    45	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/stomp/StompTestClient.java =====
     1	import java.io.OutputStream;
     2	import java.net.Socket;
     3	import java.nio.charset.StandardCharsets;
     4	
     5	public class StompTestClient {
     6	    public static void main(String[] args) throws Exception {
     7	        Socket socket = new Socket("localhost", 7777);
     8	        OutputStream out = socket.getOutputStream();
     9	
    10	        String frame =
    11	                "CONNECT\n" +
    12	                "accept-version :1.2\n" +
    13	                "host:stomp.cs.bgu.ac.il\n" +
    14	                "login:alice\n" +
    15	                "passcode:123\n" +
    16	                "\n";
    17	
    18	        out.write(frame.getBytes(StandardCharsets.UTF_8));
    19	        out.write(0); // STOMP null character
    20	        out.flush();
    21	
    22	        Thread.sleep(5000);
    23	        socket.close();
    24	    }
    25	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/ActorThreadPool.java =====
     1	package bgu.spl.net.srv;
     2	
     3	import java.util.LinkedList;
     4	import java.util.Map;
     5	import java.util.Queue;
     6	import java.util.Set;
     7	import java.util.WeakHashMap;
     8	import java.util.concurrent.ConcurrentHashMap;
     9	import java.util.concurrent.ExecutorService;
    10	import java.util.concurrent.Executors;
    11	import java.util.concurrent.locks.ReadWriteLock;
    12	import java.util.concurrent.locks.ReentrantReadWriteLock;
    13	
    14	public class ActorThreadPool {
    15	
    16	    private final Map<Object, Queue<Runnable>> acts;
    17	    private final ReadWriteLock actsRWLock;
    18	    private final Set<Object> playingNow;
    19	    private final ExecutorService threads;
    20	
    21	    public ActorThreadPool(int threads) {
    22	        this.threads = Executors.newFixedThreadPool(threads);
    23	        acts = new WeakHashMap<>();
    24	        playingNow = ConcurrentHashMap.newKeySet();
    25	        actsRWLock = new ReentrantReadWriteLock();
    26	    }
    27	
    28	    public void submit(Object act, Runnable r) {
    29	        synchronized (act) {
    30	            if (!playingNow.contains(act)) {
    31	                playingNow.add(act);
    32	                execute(r, act);
    33	            } else {
    34	                pendingRunnablesOf(act).add(r);
    35	            }
    36	        }
    37	    }
    38	
    39	    public void shutdown() {
    40	        threads.shutdownNow();
    41	    }
    42	
    43	    private Queue<Runnable> pendingRunnablesOf(Object act) {
    44	
    45	        actsRWLock.readLock().lock();
    46	        Queue<Runnable> pendingRunnables = acts.get(act);
    47	        actsRWLock.readLock().unlock();
    48	
    49	        if (pendingRunnables == null) {
    50	            actsRWLock.writeLock().lock();
    51	            acts.put(act, pendingRunnables = new LinkedList<>());
    52	            actsRWLock.writeLock().unlock();
    53	        }
    54	        return pendingRunnables;
    55	    }
    56	
    57	    private void execute(Runnable r, Object act) {
    58	        threads.execute(() -> {
    59	            try {
    60	                r.run();
    61	            } finally {
    62	                complete(act);
    63	            }
    64	        });
    65	    }
    66	
    67	    private void complete(Object act) {
    68	        synchronized (act) {
    69	            Queue<Runnable> pending = pendingRunnablesOf(act);
    70	            if (pending.isEmpty()) {
    71	                playingNow.remove(act);
    72	            } else {
    73	                execute(pending.poll(), act);
    74	            }
    75	        }
    76	    }
    77	
    78	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/BaseServer.java =====
     1	package bgu.spl.net.srv;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	import bgu.spl.net.api.MessagingProtocol;
     5	import java.io.IOException;
     6	import java.net.ServerSocket;
     7	import java.net.Socket;
     8	import java.util.function.Supplier;
     9	import java.util.concurrent.atomic.AtomicInteger;
    10	
    11	public abstract class BaseServer<T> implements Server<T> {
    12	
    13	    private final int port;
    14	    private final Supplier<MessagingProtocol<T>> protocolFactory;
    15	    private final Supplier<MessageEncoderDecoder<T>> encdecFactory;
    16	    private ServerSocket sock;
    17	    private final ConnectionsImpl<T> connections = new ConnectionsImpl<>();
    18	    private final AtomicInteger connectionIdCounter = new AtomicInteger(0);
    19	
    20	    public BaseServer(
    21	            int port,
    22	            Supplier<MessagingProtocol<T>> protocolFactory,
    23	            Supplier<MessageEncoderDecoder<T>> encdecFactory) {
    24	
    25	        this.port = port;
    26	        this.protocolFactory = protocolFactory;
    27	        this.encdecFactory = encdecFactory;
    28			this.sock = null;
    29	    }
    30	
    31	    @Override
    32	    public void serve() {
    33	
    34	        try (ServerSocket serverSock = new ServerSocket(port)) {
    35				System.out.println("Server started");
    36	
    37	            this.sock = serverSock; //just to be able to close
    38	
    39	            while (!Thread.currentThread().isInterrupted()) {
    40	
    41	                Socket clientSock = serverSock.accept();
    42	                int connectionId = connectionIdCounter.incrementAndGet();
    43	
    44	                BlockingConnectionHandler<T> handler = new BlockingConnectionHandler<>(
    45	                        clientSock,
    46	                        encdecFactory.get(),
    47	                        protocolFactory.get(),
    48	                        connectionId,
    49	                        connections
    50	                );
    51	                
    52	                connections.addConnection(connectionId, handler);
    53	                execute(handler);
    54	            }
    55	        } catch (IOException ex) {
    56	        }
    57	
    58	        System.out.println("server closed!!!");
    59	    }
    60	
    61	    @Override
    62	    public void close() throws IOException {
    63			if (sock != null)
    64				sock.close();
    65	    }
    66	
    67	    protected abstract void execute(BlockingConnectionHandler<T>  handler);
    68	
    69	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/BlockingConnectionHandler.java =====
     1	package bgu.spl.net.srv;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	import bgu.spl.net.api.StompMessagingProtocol;
     5	import bgu.spl.net.api.MessagingProtocol;
     6	
     7	import java.io.BufferedInputStream;
     8	import java.io.BufferedOutputStream;
     9	import java.io.IOException;
    10	import java.net.Socket;
    11	
    12	public class BlockingConnectionHandler<T> implements Runnable, ConnectionHandler<T> {
    13	
    14	    private final StompMessagingProtocol<T> protocol;
    15	    private final MessageEncoderDecoder<T> encdec;
    16	    private final Socket sock;
    17	    private BufferedInputStream in;
    18	    private BufferedOutputStream out;
    19	    private volatile boolean connected = true;
    20	
    21	    private final int connectionId;
    22	    private final ConnectionsImpl<T> connections;
    23	
    24	    public BlockingConnectionHandler(Socket sock, MessageEncoderDecoder<T> reader, MessagingProtocol<T> protocol, int connectionId, ConnectionsImpl<T> connections) {
    25	        this.sock = sock;
    26	        this.encdec = reader;
    27	
    28	        // Cast to StompMessagingProtocol
    29	        if (protocol instanceof StompMessagingProtocol) {
    30	            this.protocol = (StompMessagingProtocol<T>) protocol;
    31	        } else {
    32	            throw new IllegalArgumentException("Protocol must implement StompMessagingProtocol");
    33	        }
    34	        
    35	        this.connectionId = connectionId;
    36	        this.connections = connections;
    37	    }
    38	
    39	    @Override
    40	    public void run() {
    41	        try (Socket sock = this.sock) { //just for automatic closing
    42	            int read;
    43	
    44	            in = new BufferedInputStream(sock.getInputStream());
    45	            out = new BufferedOutputStream(sock.getOutputStream());
    46	
    47	            // Initialize protocol with connectionId and connections
    48	            protocol.start(connectionId, connections);
    49	            System.err.println("DEBUG: Handler started for ID " + connectionId);
    50	
    51	            while (!protocol.shouldTerminate() && connected && (read = in.read()) >= 0) {
    52	                // --- DEBUG: Stampa ogni byte ricevuto ---
    53	                // Se il byte Ã¨ \0 scriviamo [NULL], se Ã¨ \n scriviamo [LF], altrimenti il char
    54	                if (read == 0) System.err.print("[NULL]");//DEBUG
    55	                else if (read == 10) System.err.print("[LF]");//DEBUG
    56	                else if (read == 13) System.err.print("[CR]");//DEBUG
    57	                else System.err.print((char)read);//DEBUG
    58	                // ----------------------------------------
    59	                T nextMessage = encdec.decodeNextByte((byte) read);
    60	                if (nextMessage != null) {
    61	                    // Process message (no response needed - protocol uses connections.send())
    62	                    protocol.process(nextMessage);
    63	                    /*if (response != null) {
    64	                        out.write(encdec.encode(response));
    65	                        out.flush();
    66	                    }*/
    67	                }
    68	            }
    69	
    70	        } catch (IOException ex) {
    71	            ex.printStackTrace();
    72	        }
    73	        catch(RuntimeException ex){
    74	            System.err.println("\nCRITICAL ERROR in Handler: " + ex.getMessage());
    75	            ex.printStackTrace();
    76	        }
    77	
    78	    }
    79	
    80	    @Override
    81	    public void close() throws IOException {
    82	        connected = false;
    83	        sock.close();
    84	    }
    85	
    86	    @Override
    87	    public void send(T msg) {
    88	         try {
    89	            if (out != null && connected) {
    90	                synchronized (out) {
    91	                    System.out.println(" DEBUG [SERVER SND]: " + msg.toString());
    92	                    out.write(encdec.encode(msg));
    93	                    out.flush();
    94	                }
    95	            }
    96	        } catch (IOException e) {
    97	            e.printStackTrace();
    98	        }
    99	    }
   100	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/ConnectionHandler.java =====
     1	/*
     2	 * To change this license header, choose License Headers in Project Properties.
     3	 * To change this template file, choose Tools | Templates
     4	 * and open the template in the editor.
     5	 */
     6	package bgu.spl.net.srv;
     7	
     8	import java.io.Closeable;
     9	
    10	/**
    11	 * The ConnectionHandler interface for Message of type T
    12	 */
    13	public interface ConnectionHandler<T> extends Closeable {
    14	
    15	    /**
    16	     * Comment the following lines (both send methods) for the existing implentations to work.
    17	     *
    18	     */
    19	
    20	    void send(T msg);
    21	
    22	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/Connections.java =====
     1	package bgu.spl.net.srv;
     2	
     3	import java.io.IOException;
     4	
     5	public interface Connections<T> {
     6	
     7	    boolean send(int connectionId, T msg);
     8	
     9	    void send(String channel, T msg);
    10	
    11	    void disconnect(int connectionId);
    12	
    13	    //new methods for subscribe and unsubscribe
    14	    void subscribe(String channel, int connectionId, String subscriptionId);
    15	    void unsubscribe(String channel, int connectionId, String subscriptionId);
    16	    void addConnection(int connectionId, ConnectionHandler<T> handler);
    17	
    18	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/ConnectionsImpl.java =====
     1	package bgu.spl.net.srv;
     2	import java.io.IOException;
     3	import java.util.Map;
     4	import java.util.Set;
     5	import java.util.concurrent.ConcurrentHashMap;
     6	import java.util.concurrent.atomic.AtomicInteger;
     7	
     8	import bgu.spl.net.impl.stomp.StompFrame;
     9	
    10	public class ConnectionsImpl<T> implements Connections<T> {
    11	    private Map<Integer, ConnectionHandler<T>> connections = new ConcurrentHashMap<>();
    12	    //Map <"Topic" <ConnectionId, SubscriptionId>>
    13	    private Map<String,ConcurrentHashMap<Integer, String>> topics = new ConcurrentHashMap<>();
    14	    private static final AtomicInteger messageIdCounter = new AtomicInteger(0);
    15	
    16	    @Override
    17	    public boolean send(int connectionId, T msg){
    18	        ConnectionHandler<T> handler = connections.get(connectionId);
    19	        if(handler != null){
    20	            handler.send(msg);
    21	            return true;
    22	        }
    23	        return false;
    24	    }
    25	
    26	    @Override
    27	    public void send(String channel, T msg){
    28	        ConcurrentHashMap<Integer, String> subscribers = topics.get(channel);
    29	        if(subscribers != null){
    30	            Set<Integer> connectionIds = subscribers.keySet();
    31	            for(Integer id : connectionIds){
    32	                T msgToSend = addsubscriptionToMsg(msg, id, channel);
    33	                send(id, msgToSend);
    34	            }
    35	        }
    36	    }
    37	
    38	    @Override
    39	    public void disconnect(int connectionId){
    40	        connections.remove(connectionId);//remove user from connections
    41	        for(ConcurrentHashMap<Integer, String> subscribers : topics.values()){ //remove user from all topics he subscribed to
    42	            subscribers.remove(connectionId);
    43	        }
    44	    }
    45	
    46	    @Override
    47	    public void subscribe(String channel, int connectionId, String subscriptionId){
    48	        topics.putIfAbsent(channel, new ConcurrentHashMap<>());
    49	        topics.get(channel).put(connectionId, subscriptionId);
    50	    }
    51	
    52	    @Override
    53	    public void unsubscribe(String channel, int connectionId, String subscriptionId)
    54	    {
    55	        ConcurrentHashMap<Integer, String> subscribers = topics.get(channel);
    56	        if(subscribers != null){
    57	            subscribers.remove(connectionId);
    58	            if (subscribers.isEmpty()) {
    59	                topics.remove(channel);
    60	            }
    61	        }
    62	    }
    63	    public void addConnection(int connectionId, ConnectionHandler<T> handler) {
    64	        System.err.println("DEBUG Adding connection with ID: " + connectionId);
    65	        connections.put(connectionId, handler);
    66	    }
    67	    private T addsubscriptionToMsg(T msg, int connectionId, String channel) {
    68	        if (msg instanceof StompFrame) {
    69	           
    70	            StompFrame cloned = new StompFrame((StompFrame) msg);
    71	            
    72	            ConcurrentHashMap<Integer, String> subscribers = topics.get(channel);
    73	            String subscriptionId = subscribers.get(connectionId);
    74	            if (subscriptionId != null) {
    75	                cloned.addHeader("subscription", subscriptionId);
    76	            }
    77	            
    78	            // Add message-id (server-unique)
    79	            cloned.addHeader("message-id", String.valueOf(messageIdCounter.incrementAndGet()));
    80	
    81	            return (T) cloned;
    82	        }
    83	        
    84	        return msg;
    85	    }
    86	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/NonBlockingConnectionHandler.java =====
     1	package bgu.spl.net.srv;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	import bgu.spl.net.api.MessagingProtocol;
     5	
     6	import java.io.IOException;
     7	import java.nio.ByteBuffer;
     8	import java.nio.channels.SelectionKey;
     9	import java.nio.channels.SocketChannel;
    10	import java.util.Queue;
    11	import java.util.concurrent.ConcurrentLinkedQueue;
    12	
    13	public class NonBlockingConnectionHandler<T> implements ConnectionHandler<T> {
    14	
    15	    private static final int BUFFER_ALLOCATION_SIZE = 1 << 13; //8k
    16	    private static final ConcurrentLinkedQueue<ByteBuffer> BUFFER_POOL = new ConcurrentLinkedQueue<>();
    17	
    18	    private final MessagingProtocol<T> protocol;
    19	    private final MessageEncoderDecoder<T> encdec;
    20	    private final Queue<ByteBuffer> writeQueue = new ConcurrentLinkedQueue<>();
    21	    private final SocketChannel chan;
    22	    private final Reactor reactor;
    23	
    24	    public NonBlockingConnectionHandler(
    25	            MessageEncoderDecoder<T> reader,
    26	            MessagingProtocol<T> protocol,
    27	            SocketChannel chan,
    28	            Reactor reactor) {
    29	        this.chan = chan;
    30	        this.encdec = reader;
    31	        this.protocol = protocol;
    32	        this.reactor = reactor;
    33	    }
    34	
    35	    public Runnable continueRead() {
    36	        ByteBuffer buf = leaseBuffer();
    37	
    38	        boolean success = false;
    39	        try {
    40	            success = chan.read(buf) != -1;
    41	        } catch (IOException ex) {
    42	            ex.printStackTrace();
    43	        }
    44	
    45	        if (success) {
    46	            buf.flip();
    47	            return () -> {
    48	                try {
    49	                    while (buf.hasRemaining()) {
    50	                        T nextMessage = encdec.decodeNextByte(buf.get());
    51	                        if (nextMessage != null) {
    52	                            T response = protocol.process(nextMessage);
    53	                            if (response != null) {
    54	                                writeQueue.add(ByteBuffer.wrap(encdec.encode(response)));
    55	                                reactor.updateInterestedOps(chan, SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    56	                            }
    57	                        }
    58	                    }
    59	                } finally {
    60	                    releaseBuffer(buf);
    61	                }
    62	            };
    63	        } else {
    64	            releaseBuffer(buf);
    65	            close();
    66	            return null;
    67	        }
    68	
    69	    }
    70	
    71	    public void close() {
    72	        try {
    73	            chan.close();
    74	        } catch (IOException ex) {
    75	            ex.printStackTrace();
    76	        }
    77	    }
    78	
    79	    public boolean isClosed() {
    80	        return !chan.isOpen();
    81	    }
    82	
    83	    public void continueWrite() {
    84	        while (!writeQueue.isEmpty()) {
    85	            try {
    86	                ByteBuffer top = writeQueue.peek();
    87	                chan.write(top);
    88	                if (top.hasRemaining()) {
    89	                    return;
    90	                } else {
    91	                    writeQueue.remove();
    92	                }
    93	            } catch (IOException ex) {
    94	                ex.printStackTrace();
    95	                close();
    96	            }
    97	        }
    98	
    99	        if (writeQueue.isEmpty()) {
   100	            if (protocol.shouldTerminate()) close();
   101	            else reactor.updateInterestedOps(chan, SelectionKey.OP_READ);
   102	        }
   103	    }
   104	
   105	    private static ByteBuffer leaseBuffer() {
   106	        ByteBuffer buff = BUFFER_POOL.poll();
   107	        if (buff == null) {
   108	            return ByteBuffer.allocateDirect(BUFFER_ALLOCATION_SIZE);
   109	        }
   110	
   111	        buff.clear();
   112	        return buff;
   113	    }
   114	
   115	    private static void releaseBuffer(ByteBuffer buff) {
   116	        BUFFER_POOL.add(buff);
   117	    }
   118	
   119	    @Override
   120	    public void send(T msg) {
   121	        //IMPLEMENT IF NEEDED
   122	    }
   123	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/Reactor.java =====
     1	package bgu.spl.net.srv;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	import bgu.spl.net.api.MessagingProtocol;
     5	import java.io.IOException;
     6	import java.net.InetSocketAddress;
     7	import java.nio.channels.ClosedSelectorException;
     8	import java.nio.channels.SelectionKey;
     9	import java.nio.channels.Selector;
    10	import java.nio.channels.ServerSocketChannel;
    11	import java.nio.channels.SocketChannel;
    12	import java.util.concurrent.ConcurrentLinkedQueue;
    13	import java.util.function.Supplier;
    14	
    15	public class Reactor<T> implements Server<T> {
    16	
    17	    private final int port;
    18	    private final Supplier<MessagingProtocol<T>> protocolFactory;
    19	    private final Supplier<MessageEncoderDecoder<T>> readerFactory;
    20	    private final ActorThreadPool pool;
    21	    private Selector selector;
    22	
    23	    private Thread selectorThread;
    24	    private final ConcurrentLinkedQueue<Runnable> selectorTasks = new ConcurrentLinkedQueue<>();
    25	
    26	    public Reactor(
    27	            int numThreads,
    28	            int port,
    29	            Supplier<MessagingProtocol<T>> protocolFactory,
    30	            Supplier<MessageEncoderDecoder<T>> readerFactory) {
    31	
    32	        this.pool = new ActorThreadPool(numThreads);
    33	        this.port = port;
    34	        this.protocolFactory = protocolFactory;
    35	        this.readerFactory = readerFactory;
    36	    }
    37	
    38	    @Override
    39	    public void serve() {
    40		selectorThread = Thread.currentThread();
    41	        try (Selector selector = Selector.open();
    42	                ServerSocketChannel serverSock = ServerSocketChannel.open()) {
    43	
    44	            this.selector = selector; //just to be able to close
    45	
    46	            serverSock.bind(new InetSocketAddress(port));
    47	            serverSock.configureBlocking(false);
    48	            serverSock.register(selector, SelectionKey.OP_ACCEPT);
    49				System.out.println("Server started");
    50	
    51	            while (!Thread.currentThread().isInterrupted()) {
    52	
    53	                selector.select();
    54	                runSelectionThreadTasks();
    55	
    56	                for (SelectionKey key : selector.selectedKeys()) {
    57	
    58	                    if (!key.isValid()) {
    59	                        continue;
    60	                    } else if (key.isAcceptable()) {
    61	                        handleAccept(serverSock, selector);
    62	                    } else {
    63	                        handleReadWrite(key);
    64	                    }
    65	                }
    66	
    67	                selector.selectedKeys().clear(); //clear the selected keys set so that we can know about new events
    68	
    69	            }
    70	
    71	        } catch (ClosedSelectorException ex) {
    72	            //do nothing - server was requested to be closed
    73	        } catch (IOException ex) {
    74	            //this is an error
    75	            ex.printStackTrace();
    76	        }
    77	
    78	        System.out.println("server closed!!!");
    79	        pool.shutdown();
    80	    }
    81	
    82	    /*package*/ void updateInterestedOps(SocketChannel chan, int ops) {
    83	        final SelectionKey key = chan.keyFor(selector);
    84	        if (Thread.currentThread() == selectorThread) {
    85	            key.interestOps(ops);
    86	        } else {
    87	            selectorTasks.add(() -> {
    88	                key.interestOps(ops);
    89	            });
    90	            selector.wakeup();
    91	        }
    92	    }
    93	
    94	
    95	    private void handleAccept(ServerSocketChannel serverChan, Selector selector) throws IOException {
    96	        SocketChannel clientChan = serverChan.accept();
    97	        clientChan.configureBlocking(false);
    98	        final NonBlockingConnectionHandler<T> handler = new NonBlockingConnectionHandler<>(
    99	                readerFactory.get(),
   100	                protocolFactory.get(),
   101	                clientChan,
   102	                this);
   103	        clientChan.register(selector, SelectionKey.OP_READ, handler);
   104	    }
   105	
   106	    private void handleReadWrite(SelectionKey key) {
   107	        @SuppressWarnings("unchecked")
   108	        NonBlockingConnectionHandler<T> handler = (NonBlockingConnectionHandler<T>) key.attachment();
   109	
   110	        if (key.isReadable()) {
   111	            Runnable task = handler.continueRead();
   112	            if (task != null) {
   113	                pool.submit(handler, task);
   114	            }
   115	        }
   116	
   117		    if (key.isValid() && key.isWritable()) {
   118	            handler.continueWrite();
   119	        }
   120	    }
   121	
   122	    private void runSelectionThreadTasks() {
   123	        while (!selectorTasks.isEmpty()) {
   124	            selectorTasks.remove().run();
   125	        }
   126	    }
   127	
   128	    @Override
   129	    public void close() throws IOException {
   130	        selector.close();
   131	    }
   132	
   133	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/Server.java =====
     1	package bgu.spl.net.srv;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	import bgu.spl.net.api.MessagingProtocol;
     5	import java.io.Closeable;
     6	import java.util.function.Supplier;
     7	
     8	public interface Server<T> extends Closeable {
     9	
    10	    /**
    11	     * The main loop of the server, Starts listening and handling new clients.
    12	     */
    13	    void serve();
    14	
    15	    /**
    16	     *This function returns a new instance of a thread per client pattern server
    17	     * @param port The port for the server socket
    18	     * @param protocolFactory A factory that creats new MessagingProtocols
    19	     * @param encoderDecoderFactory A factory that creats new MessageEncoderDecoder
    20	     * @param <T> The Message Object for the protocol
    21	     * @return A new Thread per client server
    22	     */
    23	    public static <T> Server<T>  threadPerClient(
    24	            int port,
    25	            Supplier<MessagingProtocol<T> > protocolFactory,
    26	            Supplier<MessageEncoderDecoder<T> > encoderDecoderFactory) {
    27	
    28	        return new BaseServer<T>(port, protocolFactory, encoderDecoderFactory) {
    29	            @Override
    30	            protected void execute(BlockingConnectionHandler<T>  handler) {
    31	                new Thread(handler).start();
    32	            }
    33	        };
    34	
    35	    }
    36	
    37	    /**
    38	     * This function returns a new instance of a reactor pattern server
    39	     * @param nthreads Number of threads available for protocol processing
    40	     * @param port The port for the server socket
    41	     * @param protocolFactory A factory that creats new MessagingProtocols
    42	     * @param encoderDecoderFactory A factory that creats new MessageEncoderDecoder
    43	     * @param <T> The Message Object for the protocol
    44	     * @return A new reactor server
    45	     */
    46	    public static <T> Server<T> reactor(
    47	            int nthreads,
    48	            int port,
    49	            Supplier<MessagingProtocol<T>> protocolFactory,
    50	            Supplier<MessageEncoderDecoder<T>> encoderDecoderFactory) {
    51	        return new Reactor<T>(nthreads, port, protocolFactory, encoderDecoderFactory);
    52	    }
    53	
    54	}



