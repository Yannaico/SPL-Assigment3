===== FILE: ./client/include/ConnectionHandler.h =====
     1	#pragma once
     2	
     3	#include <string>
     4	#include <iostream>
     5	#include <boost/asio.hpp>
     6	#include "StompProtocol.h"
     7	#include <mutex>
     8	
     9	using boost::asio::ip::tcp;
    10	
    11	class ConnectionHandler {
    12	private:
    13		const std::string host_;
    14		const short port_;
    15		boost::asio::io_service io_service_;   // Provides core I/O functionality
    16		tcp::socket socket_;
    17	
    18		StompProtocol protocol_;
    19	    
    20	    std::mutex socketMutex_;
    21	    bool connected_;
    22	
    23	public:
    24		ConnectionHandler(std::string host, short port);
    25	
    26		virtual ~ConnectionHandler();
    27	
    28		// Connect to the remote machine
    29		bool connect();
    30	
    31		// Read a fixed number of bytes from the server - blocking.
    32		// Returns false in case the connection is closed before bytesToRead bytes can be read.
    33		bool getBytes(char bytes[], unsigned int bytesToRead);
    34	
    35		// Send a fixed number of bytes from the client - blocking.
    36		// Returns false in case the connection is closed before all the data is sent.
    37		bool sendBytes(const char bytes[], int bytesToWrite);
    38	
    39		// Read an ascii line from the server
    40		// Returns false in case connection closed before a newline can be read.
    41		bool getLine(std::string &line);
    42	
    43		// Send an ascii line from the server
    44		// Returns false in case connection closed before all the data is sent.
    45		bool sendLine(std::string &line);
    46	
    47		// Get Ascii data from the server until the delimiter character
    48		// Returns false in case connection closed before null can be read.
    49		bool getFrameAscii(std::string &frame, char delimiter);
    50	
    51		// Send a message to the remote host.
    52		// Returns false in case connection is closed before all the data is sent.
    53		bool sendFrameAscii(const std::string &frame, char delimiter);
    54	
    55		// Close down the connection properly.
    56		void close();
    57		bool isConnected() const { return connected_; }
    58	    StompProtocol& getProtocol() { return protocol_; }
    59	}; //class ConnectionHandler



===== FILE: ./client/include/StompProtocol.h =====
     1	#ifndef STOMP_PROTOCOL_H
     2	#define STOMP_PROTOCOL_H
     3	
     4	#include <string>
     5	#include <map>
     6	#include <vector>
     7	#include <mutex>
     8	#include "event.h"
     9	
    10	using namespace std;
    11	
    12	class StompProtocol {
    13	private:
    14	    string username;
    15	    string password;
    16	    int receiptIdCounter;
    17	    int subscriptionIdCounter;
    18	    bool loggedIn;
    19	    mutex mtx;
    20	    
    21	    // Maps subscription ID to topic
    22	    map<string, string> subscriptions;
    23	    
    24	
    25	    // Map: user -> game -> events
    26	    map<string, map<string, names_and_events>> gameReports;
    27	    
    28	    string generateReceiptId();
    29	    string generateSubscriptionId();
    30	    
    31	public:
    32	    StompProtocol();
    33	    
    34	    // Frame builders
    35	    string buildConnectFrame(const string& host, 
    36	                                  const string& user, 
    37	                                  const string& pass);
    38	    
    39	    string buildSubscribeFrame(const string& topic);
    40	    
    41	    string buildUnsubscribeFrame(const string& subscriptionId);
    42	    
    43	    string buildSendFrame(const string& topic, 
    44	                               const Event& event, 
    45	                               const string& user);
    46	    
    47	    string buildDisconnectFrame();
    48	    
    49	    // Frame handlers
    50	    void handleMessageFrame(const string& frame);
    51	    
    52	    // Game data management
    53	    void saveGameEvent(const string& user, 
    54	                      const string& gameName, 
    55	                      const Event& event);
    56	    
    57	    void generateSummary(const string& gameName, 
    58	                        const string& user, 
    59	                        const string& outputFile);
    60	    
    61	    // State
    62	    bool isLoggedIn() const { return loggedIn; }
    63	    void setLoggedIn(bool status) { loggedIn = status; }
    64	
    65	    string getSubscriptionIdByTopic(const string& topic);
    66	    string getCurrentUsername() const { return username; }
    67	
    68	};
    69	
    70	#endif



===== FILE: ./client/include/event.h =====
     1	#pragma once
     2	
     3	#include <string>
     4	#include <iostream>
     5	#include <map>
     6	#include <vector>
     7	
     8	class Event
     9	{
    10	private:
    11	    // name of team a
    12	    std::string team_a_name;
    13	    // name of team b
    14	    std::string team_b_name;
    15	    // name of the event
    16	    std::string name;
    17	    // time of the event in seconds
    18	    int time;
    19	    // map of all the general game updates
    20	    std::map<std::string, std::string> game_updates;
    21	    // map of all team a updates the second type can be a string bool or int
    22	    std::map<std::string, std::string> team_a_updates;
    23	    // map of all team b updates
    24	    std::map<std::string, std::string> team_b_updates;
    25	    // description of the event
    26	    std::string description;
    27	
    28	public:
    29	    Event(std::string name, std::string team_a_name, std::string team_b_name, int time, std::map<std::string, std::string> game_updates, std::map<std::string, std::string> team_a_updates, std::map<std::string, std::string> team_b_updates, std::string discription);
    30	    Event(const std::string & frame_body);
    31	    virtual ~Event();
    32	    const std::string &get_team_a_name() const;
    33	    const std::string &get_team_b_name() const;
    34	    const std::string &get_name() const;
    35	    int get_time() const;
    36	    const std::map<std::string, std::string> &get_game_updates() const;
    37	    const std::map<std::string, std::string> &get_team_a_updates() const;
    38	    const std::map<std::string, std::string> &get_team_b_updates() const;
    39	    const std::string &get_discription() const;
    40	};
    41	
    42	// an object that holds the names of the teams and a vector of events, to be returned by the parseEventsFile function
    43	struct names_and_events {
    44	    std::string team_a_name;
    45	    std::string team_b_name;
    46	    std::vector<Event> events;
    47	};
    48	
    49	// function that parses the json file and returns a names_and_events object
    50	names_and_events parseEventsFile(std::string json_path);



===== FILE: ./client/makefile =====
     1	CFLAGS:=-c -Wall -Weffc++ -g -std=c++11 -Iinclude
     2	LDFLAGS:=-lboost_system -lpthread
     3	
     4	all: StompClient
     5	
     6	StompClient: bin/ConnectionHandler.o bin/StompClient.o bin/StompProtocol.o bin/event.o
     7		g++ -o bin/StompClient bin/ConnectionHandler.o bin/StompClient.o bin/StompProtocol.o bin/event.o $(LDFLAGS)
     8	
     9	bin/ConnectionHandler.o: src/ConnectionHandler.cpp
    10		g++ $(CFLAGS) -o bin/ConnectionHandler.o src/ConnectionHandler.cpp
    11	
    12	bin/StompClient.o: src/StompClient.cpp
    13		g++ $(CFLAGS) -o bin/StompClient.o src/StompClient.cpp
    14	
    15	bin/StompProtocol.o: src/StompProtocol.cpp
    16		g++ $(CFLAGS) -o bin/StompProtocol.o src/StompProtocol.cpp
    17	
    18	bin/event.o: src/event.cpp
    19		g++ $(CFLAGS) -o bin/event.o src/event.cpp
    20	
    21	.PHONY: clean
    22	clean:
    23		rm -f bin/*



===== FILE: ./client/src/ConnectionHandler.cpp =====
     1	#include "../include/ConnectionHandler.h"
     2	
     3	using boost::asio::ip::tcp;
     4	
     5	using std::cin;
     6	using std::cout;
     7	using std::cerr;
     8	using std::endl;
     9	using std::string;
    10	
    11	ConnectionHandler::ConnectionHandler(string host, short port) : host_(host), port_(port), io_service_(),
    12	                                                                socket_(io_service_), connected_(false) {}
    13	
    14	ConnectionHandler::~ConnectionHandler() {
    15		close();
    16	}
    17	
    18	bool ConnectionHandler::connect() {
    19		std::cout << "Starting connect to "
    20		          << host_ << ":" << port_ << std::endl;
    21		try {
    22			tcp::endpoint endpoint(boost::asio::ip::address::from_string(host_), port_); // the server endpoint
    23			boost::system::error_code error;
    24			socket_.connect(endpoint, error);
    25			if (error)
    26				throw boost::system::system_error(error);
    27			connected_ = true;
    28		}
    29		catch (std::exception &e) {
    30			std::cerr << "DEBUG Failed to connect to "
    31			          << host_ << ":" << port_ << std::endl;
    32			std::cerr << "Connection failed (Error: " << e.what() << ')' << std::endl;
    33			return false;
    34		}
    35		return true;
    36	}
    37	
    38	bool ConnectionHandler::getBytes(char bytes[], unsigned int bytesToRead) {
    39		size_t tmp = 0;
    40		boost::system::error_code error;
    41		try {
    42			lock_guard<std::mutex> lock(socketMutex_);
    43			while (!error && bytesToRead > tmp) {
    44				tmp += socket_.read_some(boost::asio::buffer(bytes + tmp, bytesToRead - tmp), error);
    45			}
    46			if (error)
    47				throw boost::system::system_error(error);
    48		} catch (std::exception &e) {
    49			std::cerr << "recv failed (Error: " << e.what() << ')' << std::endl;
    50			return false;
    51		}
    52		return true;
    53	}
    54	
    55	bool ConnectionHandler::sendBytes(const char bytes[], int bytesToWrite) {
    56		int tmp = 0;
    57		boost::system::error_code error;
    58		try {
    59			std::lock_guard<std::mutex> lock(socketMutex_);
    60			while (!error && bytesToWrite > tmp) {
    61				tmp += socket_.write_some(boost::asio::buffer(bytes + tmp, bytesToWrite - tmp), error);
    62			}
    63			if (error)
    64				throw boost::system::system_error(error);
    65		} catch (std::exception &e) {
    66			std::cerr << "recv failed (Error: " << e.what() << ')' << std::endl;
    67			return false;
    68		}
    69		return true;
    70	}
    71	
    72	bool ConnectionHandler::getLine(std::string &line) {
    73		return getFrameAscii(line, '\n');
    74	}
    75	
    76	bool ConnectionHandler::sendLine(std::string &line) {
    77		return sendFrameAscii(line, '\n');
    78	}
    79	
    80	
    81	bool ConnectionHandler::getFrameAscii(std::string &frame, char delimiter) {
    82		char ch;
    83		try {
    84			do {
    85				if (!getBytes(&ch, 1)) {
    86					return false;
    87				}
    88				if (ch != '\0')
    89					frame.append(1, ch);
    90			} while (delimiter != ch);
    91		} catch (std::exception &e) {
    92			std::cerr << "recv failed2 (Error: " << e.what() << ')' << std::endl;
    93			return false;
    94		}
    95		return true;
    96	}
    97	
    98	bool ConnectionHandler::sendFrameAscii(const std::string &frame, char delimiter) {
    99		bool result = sendBytes(frame.c_str(), frame.length());
   100		if (!result) return false;
   101		return sendBytes(&delimiter, 1);
   102	}
   103	
   104	// Close down the connection properly.
   105	void ConnectionHandler::close() {
   106		try {
   107			connected_ = false;
   108			socket_.close();
   109		} catch (...) {
   110			std::cout << "closing failed: connection already closed" << std::endl;
   111		}
   112	}



===== FILE: ./client/src/StompClient.cpp =====
     1	#include <iostream>
     2	#include <thread>
     3	#include <string>
     4	#include <sstream>
     5	#include <vector>
     6	#include "../include/ConnectionHandler.h"
     7	#include "event.h"
     8	
     9	void socketReaderThread(ConnectionHandler* handler) {
    10	    while (handler->isConnected()) {
    11	        std::string frame;
    12	        
    13	        if (!handler->getFrameAscii(frame, '\0')) {
    14	            break;
    15	        }
    16	        std::cout << "DEBUG === RECEIVED FRAME ===\n" << frame << "\n==================\n";
    17	
    18	        if (frame.substr(0, 9) == "CONNECTED") {
    19	            std::cout << "Login successful" << std::endl;
    20	            handler->getProtocol().setLoggedIn(true);
    21	            
    22	        } else if (frame.substr(0, 5) == "ERROR") {
    23	            std::cerr << "Error from server:\n" << frame << std::endl;
    24	            handler->close();
    25	            break;
    26	            
    27	        } else if (frame.substr(0, 7) == "RECEIPT") {
    28	            size_t pos = frame.find("receipt-id:");
    29	            if (pos != std::string::npos) {
    30	                std::string receiptId = frame.substr(pos + 11);
    31	                receiptId = receiptId.substr(0, receiptId.find('\n'));
    32	            }
    33	            
    34	        } else if (frame.substr(0, 7) == "MESSAGE") {
    35	            handler->getProtocol().handleMessageFrame(frame);
    36	        }
    37	    }
    38	}
    39	
    40	std::vector<std::string> split(const std::string& str, char delimiter) {
    41	    std::vector<std::string> tokens;
    42	    std::string token;
    43	    std::istringstream tokenStream(str);
    44	    
    45	    while (std::getline(tokenStream, token, delimiter)) {
    46	        tokens.push_back(token);
    47	    }
    48	    
    49	    return tokens;
    50	}
    51	
    52	int main(int argc, char* argv[]) {
    53	    ConnectionHandler* handler = nullptr;
    54	    std::thread* readerThread = nullptr;
    55	    
    56	    std::string line;
    57	    
    58	    while (std::getline(std::cin, line)) {
    59	        std::vector<std::string> tokens = split(line, ' ');
    60	        
    61	        if (tokens.empty()) continue;
    62	        
    63	        std::string command = tokens[0];
    64	        
    65	        if (command == "login") {
    66	            cout << "DEBUG Attempting to log in..." << std::endl;
    67	            if (tokens.size() != 4) {
    68	                std::cerr << "Usage: login host:port username password" << std::endl;
    69	                continue;
    70	            }
    71	            
    72	            if (handler != nullptr && handler->isConnected()) {
    73	                std::cerr << "The client is already logged in, log out before trying again" << std::endl;
    74	                continue;
    75	            }
    76	            
    77	            std::string hostPort = tokens[1];
    78	            size_t colonPos = hostPort.find(':');
    79	            
    80	            if (colonPos == std::string::npos) {
    81	                std::cerr << "Invalid host:port format" << std::endl;
    82	                continue;
    83	            }
    84	            
    85	            std::string host = hostPort.substr(0, colonPos);
    86	            short port = std::stoi(hostPort.substr(colonPos + 1));
    87	            
    88	            std::string username = tokens[2];
    89	            std::string password = tokens[3];
    90	            
    91	            handler = new ConnectionHandler(host, port);
    92	            
    93	            if (!handler->connect()) {
    94	                delete handler;
    95	                handler = nullptr;
    96	                continue;
    97	            }
    98	            readerThread = new std::thread(socketReaderThread, handler);
    99	
   100	            std::string connectFrame = handler->getProtocol().buildConnectFrame(host, username, password);
   101	            handler->sendFrameAscii(connectFrame, '\0');            
   102	        }
   103	        else if (command == "join") {
   104	            std::cout << "DEBUG Processing join command" << std::endl;  
   105	
   106	            if (tokens.size() != 2) {
   107	                std::cerr << "Usage: join game_name" << std::endl;
   108	                continue;
   109	            }
   110	            
   111	            if (handler == nullptr || !handler->isConnected()) {
   112	                std::cerr << "Not connected to server" << std::endl;
   113	                continue;
   114	            }
   115	            if (!handler->getProtocol().isLoggedIn()) {
   116	                std::cerr << "Not logged in. Please wait for login to complete." << std::endl;
   117	                continue;
   118	            }
   119	            std::string gameName = tokens[1];
   120	            std::string topic = "/" + gameName;
   121	            
   122	            std::string subscribeFrame = handler->getProtocol().buildSubscribeFrame(topic);
   123	            std::cout << "DEBUG === SENDING SUBSCRIBE ===\n" << subscribeFrame << "\n==================\n";
   124	
   125	            handler->sendFrameAscii(subscribeFrame, '\0');
   126	            
   127	            std::cout << "Joined channel " << gameName << std::endl;
   128	        }
   129	        
   130	        else if (command == "exit") {
   131	            if (tokens.size() != 2) {
   132	                std::cerr << "Usage: exit game_name" << std::endl;
   133	                continue;
   134	            }
   135	            
   136	            if (handler == nullptr || !handler->isConnected()) {
   137	                std::cerr << "Not connected to server" << std::endl;
   138	                continue;
   139	            }
   140	            
   141	            std::string gameName = tokens[1];
   142	            
   143	            std::string topic = "/" + gameName;
   144	            std::string subId = handler->getProtocol().getSubscriptionIdByTopic(topic);
   145	            if (subId == "") {
   146	                std::cerr << "Error: You are not subscribed to " << gameName << std::endl;
   147	                continue;
   148	            }
   149	            std::string unsubscribeFrame = handler->getProtocol().buildUnsubscribeFrame(subId);
   150	            handler->sendFrameAscii(unsubscribeFrame, '\0');
   151	            
   152	            std::cout << "Exited channel " << gameName << std::endl;
   153	        }
   154	        
   155	        else if (command == "report") {
   156	            if (tokens.size() != 2) {
   157	                std::cerr << "Usage: report filename" << std::endl;
   158	                continue;
   159	            }
   160	            
   161	            if (handler == nullptr || !handler->isConnected()) {
   162	                std::cerr << "Not connected to server" << std::endl;
   163	                continue;
   164	            }
   165	            
   166	            std::string filename = tokens[1];
   167	            
   168	            names_and_events nae = parseEventsFile(filename);
   169	            
   170	            std::string gameName = nae.team_a_name + "_" + nae.team_b_name;
   171	            std::string topic = "/" + gameName;
   172	            
   173	            for (const Event& event : nae.events) {
   174	                std::string sendFrame = handler->getProtocol().buildSendFrame(
   175	                    topic, event, handler->getProtocol().getCurrentUsername()
   176	                );
   177	                handler->sendFrameAscii(sendFrame, '\0');
   178	                
   179	                handler->getProtocol().saveGameEvent(handler->getProtocol().getCurrentUsername(), gameName, event);
   180	            }
   181	        }
   182	        else if (command == "summary") {
   183	            if (tokens.size() != 4) {
   184	                std::cerr << "Usage: summary game_name user outputfile" << std::endl;
   185	                continue;
   186	            }
   187	            
   188	            std::string gameName = tokens[1];
   189	            std::string user = tokens[2];
   190	            std::string outputFile = tokens[3];
   191	            
   192	            handler->getProtocol().generateSummary(gameName, user, outputFile);
   193	        }
   194	        else if (command == "logout") {
   195	            if (handler == nullptr || !handler->isConnected()) {
   196	                std::cerr << "Not connected to server" << std::endl;
   197	                continue;
   198	            }
   199	            
   200	            std::string disconnectFrame = handler->getProtocol().buildDisconnectFrame();
   201	            handler->sendFrameAscii(disconnectFrame, '\0');
   202	            
   203	            std::this_thread::sleep_for(std::chrono::milliseconds(500));
   204	            
   205	            handler->close();
   206	            
   207	            if (readerThread != nullptr) {
   208	                readerThread->join();
   209	                delete readerThread;
   210	                readerThread = nullptr;
   211	            }
   212	            
   213	            delete handler;
   214	            handler = nullptr;
   215	            
   216	            std::cout << "Logged out" << std::endl;
   217	        }
   218	        else {
   219	            std::cerr << "Unknown command: " << command << std::endl;
   220	        }
   221	    }
   222	    
   223	    if (handler != nullptr) {
   224	        handler->close();
   225	        if (readerThread != nullptr) {
   226	            readerThread->join();
   227	            delete readerThread;
   228	        }
   229	        delete handler;
   230	    }
   231	    
   232	    return 0;
   233	}



===== FILE: ./client/src/StompProtocol.cpp =====
     1	#include "StompProtocol.h"
     2	#include <sstream>
     3	#include <fstream>
     4	#include <iostream>
     5	#include <algorithm>
     6	
     7	using namespace std;
     8	
     9	StompProtocol::StompProtocol() 
    10	    : username(""), password(""), receiptIdCounter(0), 
    11	      subscriptionIdCounter(0), loggedIn(false) {}
    12	
    13	string StompProtocol::generateReceiptId() {
    14	    lock_guard<mutex> lock(mtx);
    15	    return to_string(++receiptIdCounter);
    16	}
    17	
    18	string StompProtocol::generateSubscriptionId() {
    19	    lock_guard<mutex> lock(mtx);
    20	    return to_string(++subscriptionIdCounter);
    21	}
    22	
    23	string StompProtocol::buildConnectFrame(const string& host, 
    24	                                        const string& user, 
    25	                                        const string& pass) {
    26	    username = user;
    27	    password = pass;
    28	    
    29	    string frame = "";
    30	    frame.append("CONNECT\n");
    31	    frame.append("accept-version:1.2\n");
    32	    frame.append("host:stomp.cs.bgu.ac.il\n");
    33	    frame.append("login:").append(user).append("\n");
    34	    frame.append("passcode:").append(pass).append("\n");
    35	    frame.append("\n");
    36	    
    37	    return frame;
    38	}
    39	
    40	string StompProtocol::buildSubscribeFrame(const string& topic) {
    41	    string subId = generateSubscriptionId();
    42	    string receiptId = generateReceiptId();
    43	    
    44	    {
    45	        lock_guard<mutex> lock(mtx);
    46	        subscriptions[subId] = topic;
    47	    }
    48	    
    49	    string frame = "";
    50	    frame.append("SUBSCRIBE\n");
    51	    frame.append("destination:").append(topic).append("\n");
    52	    frame.append("id:").append(subId).append("\n");
    53	    frame.append("receipt:").append(receiptId).append("\n");
    54	    frame.append("\n");
    55	    
    56	    return frame;
    57	}
    58	
    59	string StompProtocol::buildUnsubscribeFrame(const string& subId) {
    60	    string receiptId = generateReceiptId();
    61	    
    62	    string frame = "";
    63	    frame.append("UNSUBSCRIBE\n");
    64	    frame.append("id:").append(subId).append("\n");
    65	    frame.append("receipt:").append(receiptId).append("\n");
    66	    frame.append("\n");
    67	    
    68	    {
    69	        lock_guard<mutex> lock(mtx);
    70	        subscriptions.erase(subId);
    71	    }
    72	    
    73	    return frame;
    74	}
    75	
    76	string StompProtocol::buildSendFrame(const string& topic, 
    77	                                     const Event& event, 
    78	                                     const string& user) {
    79	    string frame = "";
    80	    
    81	    frame.append("SEND\n");
    82	    frame.append("destination:").append(topic).append("\n");
    83	    frame.append("user: ").append(user).append("\n");
    84	    frame.append("team a: ").append(event.get_team_a_name()).append("\n");
    85	    frame.append("team b: ").append(event.get_team_b_name()).append("\n");
    86	    frame.append("event name: ").append(event.get_name()).append("\n");
    87	    frame.append("time: ").append(to_string(event.get_time())).append("\n");
    88	    
    89	    frame.append("\n");
    90	    
    91	    frame.append("general game updates:\n");
    92	    for (auto& kv : event.get_game_updates()) {
    93	        frame.append(kv.first).append(": ").append(kv.second).append("\n");
    94	    }
    95	    
    96	    frame.append("team a updates:\n");
    97	    for (auto& kv : event.get_team_a_updates()) {
    98	        frame.append(kv.first).append(": ").append(kv.second).append("\n");
    99	    }
   100	    
   101	    frame.append("team b updates:\n");
   102	    for (auto& kv : event.get_team_b_updates()) {
   103	        frame.append(kv.first).append(": ").append(kv.second).append("\n");
   104	    }
   105	    
   106	    // BODY - description
   107	    frame.append("description:\n").append(event.get_discription()).append("\n");
   108	    
   109	    return frame;
   110	}
   111	
   112	string StompProtocol::buildDisconnectFrame() {
   113	    string receiptId = generateReceiptId();
   114	    
   115	    string frame = "";
   116	    frame.append("DISCONNECT\n");
   117	    frame.append("receipt:").append(receiptId).append("\n");
   118	    frame.append("\n");
   119	    
   120	    return frame;
   121	}
   122	
   123	void StompProtocol::handleMessageFrame(const string& frame) {
   124	    istringstream iss(frame);
   125	    string line;
   126	    map<string, string> headers;
   127	    
   128	    getline(iss, line);
   129	    
   130	    while (getline(iss, line) && !line.empty() && line != "\r") {
   131	        size_t colonPos = line.find(':');
   132	        if (colonPos != string::npos) {
   133	            string key = line.substr(0, colonPos);
   134	            string value = line.substr(colonPos + 1);
   135	            
   136	            if (!value.empty() && value[0] == ' ') {
   137	                value = value.substr(1);
   138	            }
   139	            
   140	            if (!value.empty() && value.back() == '\r') {
   141	                value.pop_back();
   142	            }
   143	            
   144	            headers[key] = value;
   145	        }
   146	    }
   147	    
   148	    string bodyStream = "";
   149	    while (getline(iss, line)) {
   150	        bodyStream.append(line).append("\n");
   151	    }
   152	    
   153	    std::string user = headers["user"];
   154	    std::string teamA = headers["team a"];
   155	    std::string teamB = headers["team b"];
   156	    std::string gameName = teamA + "_" + teamB;
   157	    std::string eventName = headers["event name"];
   158	    std::string timeStr = headers["time"];
   159	    int time = std::stoi(timeStr);
   160	    
   161	    // Parsing BODY to extract game updates
   162	    std::map<std::string, std::string> gameUpdates;
   163	    std::map<std::string, std::string> teamAUpdates;
   164	    std::map<std::string, std::string> teamBUpdates;
   165	    std::string description = "";
   166	    
   167	    std::istringstream bodyStream2(bodyStream);
   168	    std::string section = "";
   169	    
   170	    while (std::getline(bodyStream2, line)) {
   171	        if (line.find("general game updates:") == 0) {
   172	            section = "general";
   173	        } else if (line.find("team a updates:") == 0) {
   174	            section = "team_a";
   175	        } else if (line.find("team b updates:") == 0) {
   176	            section = "team_b";
   177	        } else if (line.find("description:") == 0) {
   178	            section = "description";
   179	
   180	            std::string descLine;
   181	            while (std::getline(bodyStream2, descLine)) {
   182	                description.append(descLine).append("\n");
   183	            }
   184	            if (!description.empty() && description.back() == '\n') {
   185	                description.pop_back();
   186	            }
   187	            break;
   188	        } else if (!line.empty() && line.find(':') != std::string::npos) {
   189	            size_t colonPos = line.find(':');
   190	            std::string key = line.substr(0, colonPos);
   191	            std::string value = line.substr(colonPos + 1);
   192	            
   193	            if (!value.empty() && value[0] == ' ') {
   194	                value = value.substr(1);
   195	            }
   196	            if (!value.empty() && value.back() == '\r') {
   197	                value.pop_back();
   198	            }
   199	            
   200	            if (section == "general") {
   201	                gameUpdates[key] = value;
   202	            } else if (section == "team_a") {
   203	                teamAUpdates[key] = value;
   204	            } else if (section == "team_b") {
   205	                teamBUpdates[key] = value;
   206	            }
   207	        }
   208	    }
   209	    
   210	    // Creat Event and save
   211	    Event event(teamA, teamB, eventName, time, 
   212	                gameUpdates, teamAUpdates, teamBUpdates, description);
   213	    
   214	    saveGameEvent(user, gameName, event);
   215	    
   216	    // Print to console
   217	    std::cout << user << " - " << gameName << ":\n";
   218	    std::cout << eventName << "\n\n";
   219	    std::cout << description << "\n" << std::endl;
   220	}
   221	
   222	void StompProtocol::saveGameEvent(const string& user, 
   223	                                  const string& gameName, 
   224	                                  const Event& event) {
   225	    lock_guard<mutex> lock(mtx);
   226	    
   227	    if (gameReports[user].find(gameName) == gameReports[user].end()) {
   228	        gameReports[user][gameName] = names_and_events();
   229	        
   230	        // Extract team names from gameName (format: "USA_Canada")
   231	        size_t underscorePos = gameName.find('_');
   232	        if (underscorePos != string::npos) {
   233	            gameReports[user][gameName].team_a_name = gameName.substr(0, underscorePos);
   234	            gameReports[user][gameName].team_b_name = gameName.substr(underscorePos + 1);
   235	        }
   236	    }
   237	    
   238	    // Add event
   239	    gameReports[user][gameName].events.push_back(event);
   240	}
   241	
   242	void StompProtocol::generateSummary(const string& gameName, 
   243	                                    const string& user, 
   244	                                    const string& outputFile) {
   245	    ofstream out(outputFile);
   246	    
   247	    if (!out.is_open()) {
   248	        cerr << "Cannot open file: " << outputFile << endl;
   249	        return;
   250	    }
   251	    
   252	    // Find reports for this game and user
   253	    auto userIt = gameReports.find(user);
   254	    if (userIt == gameReports.end()) {
   255	        out << "No reports found for user " << user << endl;
   256	        out.close();
   257	        cout << "Summary written to " << outputFile << endl;
   258	        return;
   259	    }
   260	    
   261	    auto gameIt = userIt->second.find(gameName);
   262	    if (gameIt == userIt->second.end()) {
   263	        out << "No reports found for game " << gameName << endl;
   264	        out.close();
   265	        cout << "Summary written to " << outputFile << endl;
   266	        return;
   267	    }
   268	    
   269	    names_and_events& nae = gameIt->second;
   270	    
   271	    // Header (assignment format)
   272	    out << nae.team_a_name << " vs " << nae.team_b_name << "\n";
   273	    out << "Game stats:\n";
   274	    out << "General stats:\n";
   275	    
   276	    // Aggregate general stats from all events
   277	    map<string, string> generalStats;
   278	    for (const Event& event : nae.events) {
   279	        for (auto& kv : event.get_game_updates()) {
   280	            generalStats[kv.first] = kv.second;  // Last value wins
   281	        }
   282	    }
   283	    
   284	    // Print general stats (lexicographic order)
   285	    for (auto& kv : generalStats) {
   286	        out << kv.first << ": " << kv.second << "\n";
   287	    }
   288	    
   289	    // Team A stats
   290	    out << nae.team_a_name << " stats:\n";
   291	    map<string, string> teamAStats;
   292	    for (const Event& event : nae.events) {
   293	        for (auto& kv : event.get_team_a_updates()) {
   294	            teamAStats[kv.first] = kv.second;
   295	        }
   296	    }
   297	    for (auto& kv : teamAStats) {
   298	        out << kv.first << ": " << kv.second << "\n";
   299	    }
   300	    
   301	    // Team B stats
   302	    out << nae.team_b_name << " stats:\n";
   303	    map<string, string> teamBStats;
   304	    for (const Event& event : nae.events) {
   305	        for (auto& kv : event.get_team_b_updates()) {
   306	            teamBStats[kv.first] = kv.second;
   307	        }
   308	    }
   309	    for (auto& kv : teamBStats) {
   310	        out << kv.first << ": " << kv.second << "\n";
   311	    }
   312	    
   313	    // Game event reports
   314	    out << "\nGame event reports:\n";
   315	    
   316	    // Sort events by time (handling halftime)
   317	    vector<Event> sortedEvents = nae.events;
   318	    sort(sortedEvents.begin(), sortedEvents.end(), 
   319	         [](const Event& a, const Event& b) {
   320	             // If one is "halftime", handle specially
   321	             bool aBeforeHalftime = true;
   322	             bool bBeforeHalftime = true;
   323	             
   324	             // Check if events have "before halftime" in game_updates
   325	             auto aUpdates = a.get_game_updates();
   326	             auto bUpdates = b.get_game_updates();
   327	             
   328	             if (aUpdates.find("before halftime") != aUpdates.end()) {
   329	                 aBeforeHalftime = (aUpdates.at("before halftime") == "true");
   330	             }
   331	             
   332	             if (bUpdates.find("before halftime") != bUpdates.end()) {
   333	                 bBeforeHalftime = (bUpdates.at("before halftime") == "true");
   334	             }
   335	             
   336	             // If one is before halftime and the other is after
   337	             if (aBeforeHalftime && !bBeforeHalftime) return true;
   338	             if (!aBeforeHalftime && bBeforeHalftime) return false;
   339	             
   340	             // Otherwise sort by time
   341	             return a.get_time() < b.get_time();
   342	         });
   343	    
   344	    // Print events
   345	    for (const Event& event : sortedEvents) {
   346	        out << event.get_time() << " - " << event.get_name() << ":\n";
   347	        out << event.get_discription() << "\n\n";
   348	    }
   349	    
   350	    out.close();
   351	    cout << "Summary written to " << outputFile << endl;
   352	}
   353	string StompProtocol::getSubscriptionIdByTopic(const string& topic) {
   354	    lock_guard<mutex> lock(mtx);
   355	    
   356	    for (auto const& [id, subTopic] : subscriptions) {
   357	        if (subTopic == topic) {
   358	            return id; 
   359	        }
   360	    }
   361	    return ""; 
   362	}



===== FILE: ./client/src/echoClient.cpp =====
     1	#include <stdlib.h>
     2	#include "../include/ConnectionHandler.h"
     3	
     4	/**
     5	* This code assumes that the server replies the exact text the client sent it (as opposed to the practical session example)
     6	*/
     7	int main (int argc, char *argv[]) {
     8	    if (argc < 3) {
     9	        std::cerr << "Usage: " << argv[0] << " host port" << std::endl << std::endl;
    10	        return -1;
    11	    }
    12	    std::string host = argv[1];
    13	    short port = atoi(argv[2]);
    14	    
    15	    ConnectionHandler connectionHandler(host, port);
    16	    if (!connectionHandler.connect()) {
    17	        std::cerr << "Cannot connect to " << host << ":" << port << std::endl;
    18	        return 1;
    19	    }
    20		
    21		//From here we will see the rest of the ehco client implementation:
    22	    while (1) {
    23	        const short bufsize = 1024;
    24	        char buf[bufsize];
    25	        std::cin.getline(buf, bufsize);
    26			std::string line(buf);
    27			int len=line.length();
    28	        if (!connectionHandler.sendLine(line)) {
    29	            std::cout << "Disconnected. Exiting...\n" << std::endl;
    30	            break;
    31	        }
    32			// connectionHandler.sendLine(line) appends '\n' to the message. Therefor we send len+1 bytes.
    33	        std::cout << "Sent " << len+1 << " bytes to server" << std::endl;
    34	
    35	 
    36	        // We can use one of three options to read data from the server:
    37	        // 1. Read a fixed number of characters
    38	        // 2. Read a line (up to the newline character using the getline() buffered reader
    39	        // 3. Read up to the null character
    40	        std::string answer;
    41	        // Get back an answer: by using the expected number of bytes (len bytes + newline delimiter)
    42	        // We could also use: connectionHandler.getline(answer) and then get the answer without the newline char at the end
    43	        if (!connectionHandler.getLine(answer)) {
    44	            std::cout << "Disconnected. Exiting...\n" << std::endl;
    45	            break;
    46	        }
    47	        
    48			len=answer.length();
    49			// A C string must end with a 0 char delimiter.  When we filled the answer buffer from the socket
    50			// we filled up to the \n char - we must make sure now that a 0 char is also present. So we truncate last character.
    51	        answer.resize(len-1);
    52	        std::cout << "Reply: " << answer << " " << len << " bytes " << std::endl << std::endl;
    53	        if (answer == "bye") {
    54	            std::cout << "Exiting...\n" << std::endl;
    55	            break;
    56	        }
    57	    }
    58	    return 0;
    59	}



===== FILE: ./client/src/event.cpp =====
     1	#include "../include/event.h"
     2	#include "../include/json.hpp"
     3	#include <iostream>
     4	#include <fstream>
     5	#include <string>
     6	#include <map>
     7	#include <vector>
     8	#include <sstream>
     9	using json = nlohmann::json;
    10	
    11	Event::Event(std::string team_a_name, std::string team_b_name, std::string name, int time,
    12	             std::map<std::string, std::string> game_updates, std::map<std::string, std::string> team_a_updates,
    13	             std::map<std::string, std::string> team_b_updates, std::string discription)
    14	    : team_a_name(team_a_name), team_b_name(team_b_name), name(name),
    15	      time(time), game_updates(game_updates), team_a_updates(team_a_updates),
    16	      team_b_updates(team_b_updates), description(discription)
    17	{
    18	}
    19	
    20	Event::~Event()
    21	{
    22	}
    23	
    24	const std::string &Event::get_team_a_name() const
    25	{
    26	    return this->team_a_name;
    27	}
    28	
    29	const std::string &Event::get_team_b_name() const
    30	{
    31	    return this->team_b_name;
    32	}
    33	
    34	const std::string &Event::get_name() const
    35	{
    36	    return this->name;
    37	}
    38	
    39	int Event::get_time() const
    40	{
    41	    return this->time;
    42	}
    43	
    44	const std::map<std::string, std::string> &Event::get_game_updates() const
    45	{
    46	    return this->game_updates;
    47	}
    48	
    49	const std::map<std::string, std::string> &Event::get_team_a_updates() const
    50	{
    51	    return this->team_a_updates;
    52	}
    53	
    54	const std::map<std::string, std::string> &Event::get_team_b_updates() const
    55	{
    56	    return this->team_b_updates;
    57	}
    58	
    59	const std::string &Event::get_discription() const
    60	{
    61	    return this->description;
    62	}
    63	
    64	Event::Event(const std::string &frame_body) : team_a_name(""), team_b_name(""), name(""), time(0), game_updates(), team_a_updates(), team_b_updates(), description("")
    65	{
    66	}
    67	
    68	names_and_events parseEventsFile(std::string json_path)
    69	{
    70	    std::ifstream f(json_path);
    71	    json data = json::parse(f);
    72	
    73	    std::string team_a_name = data["team a"];
    74	    std::string team_b_name = data["team b"];
    75	
    76	    // run over all the events and convert them to Event objects
    77	    std::vector<Event> events;
    78	    for (auto &event : data["events"])
    79	    {
    80	        std::string name = event["event name"];
    81	        int time = event["time"];
    82	        std::string description = event["description"];
    83	        std::map<std::string, std::string> game_updates;
    84	        std::map<std::string, std::string> team_a_updates;
    85	        std::map<std::string, std::string> team_b_updates;
    86	        for (auto &update : event["general game updates"].items())
    87	        {
    88	            if (update.value().is_string())
    89	                game_updates[update.key()] = update.value();
    90	            else
    91	                game_updates[update.key()] = update.value().dump();
    92	        }
    93	
    94	        for (auto &update : event["team a updates"].items())
    95	        {
    96	            if (update.value().is_string())
    97	                team_a_updates[update.key()] = update.value();
    98	            else
    99	                team_a_updates[update.key()] = update.value().dump();
   100	        }
   101	
   102	        for (auto &update : event["team b updates"].items())
   103	        {
   104	            if (update.value().is_string())
   105	                team_b_updates[update.key()] = update.value();
   106	            else
   107	                team_b_updates[update.key()] = update.value().dump();
   108	        }
   109	        
   110	        events.push_back(Event(team_a_name, team_b_name, name, time, game_updates, team_a_updates, team_b_updates, description));
   111	    }
   112	    names_and_events events_and_names{team_a_name, team_b_name, events};
   113	
   114	    return events_and_names;
   115	}



===== FILE: ./data/sql_server.py =====
     1	#!/usr/bin/env python3
     2	"""
     3	Basic Python Server for STOMP Assignment â€“ Stage 3.3
     4	
     5	IMPORTANT:
     6	DO NOT CHANGE the server name or the basic protocol.
     7	Students should EXTEND this server by implementing
     8	the methods below.
     9	"""
    10	
    11	import socket
    12	import sys
    13	import threading
    14	
    15	
    16	SERVER_NAME = "STOMP_PYTHON_SQL_SERVER"  # DO NOT CHANGE!
    17	DB_FILE = "stomp_server.db"              # DO NOT CHANGE!
    18	
    19	
    20	def recv_null_terminated(sock: socket.socket) -> str:
    21	    data = b""
    22	    while True:
    23	        chunk = sock.recv(1024)
    24	        if not chunk:
    25	            return ""
    26	        data += chunk
    27	        if b"\0" in data:
    28	            msg, _ = data.split(b"\0", 1)
    29	            return msg.decode("utf-8", errors="replace")
    30	
    31	
    32	def init_database():
    33	    global db_conn
    34	     
    35	    db_conn = sqlite3.connect(DB_FILE, check_same_thread=False)
    36	    cursor = db_conn.cursor()
    37	    
    38	    # Table Users
    39	    cursor.execute('''
    40	        CREATE TABLE IF NOT EXISTS users (
    41	            username TEXT PRIMARY KEY,
    42	            password TEXT NOT NULL,
    43	            registration_date TEXT NOT NULL
    44	        )
    45	    ''')
    46	    
    47	    # Table login history
    48	    cursor.execute('''
    49	        CREATE TABLE IF NOT EXISTS login_history (
    50	            id INTEGER PRIMARY KEY AUTOINCREMENT,
    51	            username TEXT NOT NULL,
    52	            login_time TEXT NOT NULL,
    53	            logout_time TEXT,
    54	            FOREIGN KEY (username) REFERENCES users(username)
    55	        )
    56	    ''')
    57	    
    58	    # Table file tracking
    59	    cursor.execute('''
    60	        CREATE TABLE IF NOT EXISTS file_tracking (
    61	            id INTEGER PRIMARY KEY AUTOINCREMENT,
    62	            username TEXT NOT NULL,
    63	            filename TEXT NOT NULL,
    64	            upload_time TEXT NOT NULL,
    65	            game_channel TEXT,
    66	            FOREIGN KEY (username) REFERENCES users(username)
    67	        )
    68	    ''')
    69	    
    70	    db_conn.commit()
    71	    print(f"[{SERVER_NAME}] Database initialized")
    72	
    73	
    74	def execute_sql_command(sql_command: str) -> str:
    75	    global db_conn
    76	    
    77	    try:
    78	        with db_lock:
    79	            cursor = db_conn.cursor()
    80	            cursor.execute(sql_command)
    81	            db_conn.commit()
    82	            return "SUCCESS"
    83	    except Exception as e:
    84	        return f"ERROR:{str(e)}"
    85	
    86	
    87	def execute_sql_query(sql_query: str) -> str:
    88	    global db_conn
    89	    
    90	    try:
    91	        with db_lock:
    92	            cursor = db_conn.cursor()
    93	            cursor.execute(sql_query)
    94	            rows = cursor.fetchall()
    95	            
    96	            if not rows:
    97	                return "SUCCESS|"
    98	            
    99	            result = "SUCCESS|" + "|".join(str(row) for row in rows)
   100	            return result
   101	    except Exception as e:
   102	        return f"ERROR:{str(e)}"
   103	
   104	
   105	def handle_client(client_socket: socket.socket, addr):
   106	    print(f"[{SERVER_NAME}] Client connected from {addr}")
   107	
   108	    try:
   109	        while True:
   110	            message = recv_null_terminated(client_socket)
   111	            if message == "":
   112	                break
   113	
   114	            print(f"[{SERVER_NAME}] Received:")
   115	            print(message)
   116	
   117	            client_socket.sendall(b"done\0")
   118	
   119	    except Exception as e:
   120	        print(f"[{SERVER_NAME}] Error handling client {addr}: {e}")
   121	    finally:
   122	        try:
   123	            client_socket.close()
   124	        except Exception:
   125	            pass
   126	        print(f"[{SERVER_NAME}] Client {addr} disconnected")
   127	
   128	
   129	def start_server(host="127.0.0.1", port=7778):
   130	    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   131	    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
   132	
   133	    try:
   134	        server_socket.bind((host, port))
   135	        server_socket.listen(5)
   136	        print(f"[{SERVER_NAME}] Server started on {host}:{port}")
   137	        print(f"[{SERVER_NAME}] Waiting for connections...")
   138	
   139	        while True:
   140	            client_socket, addr = server_socket.accept()
   141	            t = threading.Thread(
   142	                target=handle_client,
   143	                args=(client_socket, addr),
   144	                daemon=True
   145	            )
   146	            t.start()
   147	
   148	    except KeyboardInterrupt:
   149	        print(f"\n[{SERVER_NAME}] Shutting down server...")
   150	    finally:
   151	        try:
   152	            server_socket.close()
   153	        except Exception:
   154	            pass
   155	
   156	
   157	if __name__ == "__main__":
   158	    port = 7778
   159	    if len(sys.argv) > 1:
   160	        raw_port = sys.argv[1].strip()
   161	        try:
   162	            port = int(raw_port)
   163	        except ValueError:
   164	            print(f"Invalid port '{raw_port}', falling back to default {port}")
   165	
   166	    start_server(port=port)



===== FILE: ./server/pom.xml =====
     1	<?xml version="1.0" encoding="UTF-8"?>
     2	<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
     3	         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     4	    <modelVersion>4.0.0</modelVersion>
     5	    <groupId>bgu.spl</groupId>
     6	    <artifactId>server</artifactId>
     7	    <version>1.0</version>
     8	    <packaging>jar</packaging>
     9	    <properties>
    10	        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    11	        <maven.compiler.source>1.8</maven.compiler.source>
    12	        <maven.compiler.target>1.8</maven.compiler.target>
    13	    </properties>
    14	    <name>server</name>
    15	</project>



===== FILE: ./server/src/main/java/bgu/spl/net/api/MessageEncoderDecoder.java =====
     1	package bgu.spl.net.api;
     2	
     3	public interface MessageEncoderDecoder<T> {
     4	
     5	    /**
     6	     * add the next byte to the decoding process
     7	     *
     8	     * @param nextByte the next byte to consider for the currently decoded
     9	     * message
    10	     * @return a message if this byte completes one or null if it doesnt.
    11	     */
    12	    T decodeNextByte(byte nextByte);
    13	
    14	    /**
    15	     * encodes the given message to bytes array
    16	     *
    17	     * @param message the message to encode
    18	     * @return the encoded bytes
    19	     */
    20	    byte[] encode(T message);
    21	
    22	}



===== FILE: ./server/src/main/java/bgu/spl/net/api/MessagingProtocol.java =====
     1	package bgu.spl.net.api;
     2	
     3	public interface MessagingProtocol<T> {
     4	 
     5	    /**
     6	     * process the given message 
     7	     * @param msg the received message
     8	     * @return the response to send or null if no response is expected by the client
     9	     */
    10	    T process(T msg);
    11	 
    12	    /**
    13	     * @return true if the connection should be terminated
    14	     */
    15	    boolean shouldTerminate();
    16	 
    17	}



===== FILE: ./server/src/main/java/bgu/spl/net/api/StompMessagingProtocol.java =====
     1	package bgu.spl.net.api;
     2	
     3	import bgu.spl.net.srv.Connections;
     4	
     5	public interface StompMessagingProtocol<T> extends MessagingProtocol<T> {
     6		/**
     7		 * Used to initiate the current client protocol with it's personal connection ID and the connections implementation
     8		**/
     9	    void start(int connectionId, Connections<T> connections);
    10	    
    11	    //void process(T message);
    12		
    13		/**
    14	     * @return true if the connection should be terminated
    15	     */
    16	    boolean shouldTerminate();
    17	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/data/Database.java =====
     1	package bgu.spl.net.impl.data;
     2	
     3	import java.io.BufferedReader;
     4	import java.io.InputStreamReader;
     5	import java.io.PrintWriter;
     6	import java.net.Socket;
     7	import java.util.concurrent.ConcurrentHashMap;
     8	
     9	public class Database {
    10		private final ConcurrentHashMap<String, User> userMap;
    11		private final ConcurrentHashMap<Integer, User> connectionsIdMap;
    12		private final String sqlHost;
    13		private final int sqlPort;
    14	
    15		private Database() {
    16			userMap = new ConcurrentHashMap<>();
    17			connectionsIdMap = new ConcurrentHashMap<>();
    18			// SQL server connection details
    19			this.sqlHost = "127.0.0.1";
    20			this.sqlPort = 7778;
    21		}
    22	
    23		public static Database getInstance() {
    24			return Instance.instance;
    25		}
    26	
    27		/**
    28		 * Execute SQL query and return result
    29		 * @param sql SQL query string
    30		 * @return Result string from SQL server
    31		 */
    32		private String executeSQL(String sql) {
    33			try (Socket socket = new Socket(sqlHost, sqlPort);
    34				 PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
    35				 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {
    36				
    37				// Send SQL with null terminator
    38				out.print(sql + '\0');
    39				out.flush();
    40				
    41				// Read response until null terminator
    42				StringBuilder response = new StringBuilder();
    43				int ch;
    44				while ((ch = in.read()) != -1 && ch != '\0') {
    45					response.append((char) ch);
    46				}
    47				
    48				return response.toString();
    49				
    50			} catch (Exception e) {
    51				System.err.println("SQL Error: " + e.getMessage());
    52				return "ERROR:" + e.getMessage();
    53			}
    54		}
    55	
    56		/**
    57		 * Escape SQL special characters to prevent SQL injection
    58		 */
    59		private String escapeSql(String str) {
    60			if (str == null) return "";
    61			return str.replace("'", "''");
    62		}
    63	
    64		public void addUser(User user) {
    65			userMap.putIfAbsent(user.name, user);
    66			connectionsIdMap.putIfAbsent(user.getConnectionId(), user);
    67		}
    68	
    69		public LoginStatus login(int connectionId, String username, String password) {
    70			if (connectionsIdMap.containsKey(connectionId)) {
    71				return LoginStatus.CLIENT_ALREADY_CONNECTED;
    72			}
    73			if (addNewUserCase(connectionId, username, password)) {
    74				// Log new user registration in SQL
    75				String sql = String.format(
    76					"INSERT INTO users (username, password, registration_date) VALUES ('%s', '%s', datetime('now'))",
    77					escapeSql(username), escapeSql(password)
    78				);
    79				executeSQL(sql);
    80				
    81				// Log login
    82				logLogin(username);
    83				return LoginStatus.ADDED_NEW_USER;
    84			} else {
    85				LoginStatus status = userExistsCase(connectionId, username, password);
    86				if (status == LoginStatus.LOGGED_IN_SUCCESSFULLY) {
    87					// Log successful login in SQL
    88					logLogin(username);
    89				}
    90				return status;
    91			}
    92		}
    93	
    94		private void logLogin(String username) {
    95			String sql = String.format(
    96				"INSERT INTO login_history (username, login_time) VALUES ('%s', datetime('now'))",
    97				escapeSql(username)
    98			);
    99			executeSQL(sql);
   100		}
   101	
   102		private LoginStatus userExistsCase(int connectionId, String username, String password) {
   103			User user = userMap.get(username);
   104			synchronized (user) {
   105				if (user.isLoggedIn()) {
   106					return LoginStatus.ALREADY_LOGGED_IN;
   107				} else if (!user.password.equals(password)) {
   108					return LoginStatus.WRONG_PASSWORD;
   109				} else {
   110					user.login();
   111					user.setConnectionId(connectionId);
   112					connectionsIdMap.put(connectionId, user);
   113					return LoginStatus.LOGGED_IN_SUCCESSFULLY;
   114				}
   115			}
   116		}
   117	
   118		private boolean addNewUserCase(int connectionId, String username, String password) {
   119			if (!userMap.containsKey(username)) {
   120				synchronized (userMap) {
   121					if (!userMap.containsKey(username)) {
   122						User user = new User(connectionId, username, password);
   123						user.login();
   124						addUser(user);
   125						return true;
   126					}
   127				}
   128			}
   129			return false;
   130		}
   131	
   132		public void logout(int connectionsId) {
   133			User user = connectionsIdMap.get(connectionsId);
   134			if (user != null) {
   135				// Log logout in SQL
   136				String sql = String.format(
   137					"UPDATE login_history SET logout_time=datetime('now') " +
   138					"WHERE username='%s' AND logout_time IS NULL " +
   139					"ORDER BY login_time DESC LIMIT 1",
   140					escapeSql(user.name)
   141				);
   142				executeSQL(sql);
   143				
   144				user.logout();
   145				connectionsIdMap.remove(connectionsId);
   146			}
   147		}
   148	
   149		/**
   150		 * Track file upload in SQL database
   151		 * @param username User who uploaded the file
   152		 * @param filename Name of the file
   153		 * @param gameChannel Game channel the file was reported to
   154		 */
   155		public void trackFileUpload(String username, String filename, String gameChannel) {
   156			String sql = String.format(
   157				"INSERT INTO file_tracking (username, filename, upload_time, game_channel) " +
   158				"VALUES ('%s', '%s', datetime('now'), '%s')",
   159				escapeSql(username), escapeSql(filename), escapeSql(gameChannel)
   160			);
   161			executeSQL(sql);
   162		}
   163	
   164		/**
   165		 * Generate and print server report using SQL queries
   166		 */
   167		public void printReport() {
   168			System.out.println(repeat("=", 80));
   169			System.out.println("SERVER REPORT - Generated at: " + java.time.LocalDateTime.now());
   170			System.out.println(repeat("=", 80));
   171			
   172			// List all users
   173			System.out.println("\n1. REGISTERED USERS:");
   174			System.out.println(repeat("-", 80));
   175			String usersSQL = "SELECT username, registration_date FROM users ORDER BY registration_date";
   176			String usersResult = executeSQL(usersSQL);
   177			if (usersResult.startsWith("SUCCESS")) {
   178				String[] parts = usersResult.split("\\|");
   179				if (parts.length > 1) {
   180					for (int i = 1; i < parts.length; i++) {
   181						System.out.println("   " + parts[i]);
   182					}
   183				} else {
   184					System.out.println("   No users registered");
   185				}
   186			}
   187			
   188			// Login history for each user
   189			System.out.println("\n2. LOGIN HISTORY:");
   190			System.out.println(repeat("-", 80));
   191			String loginSQL = "SELECT username, login_time, logout_time FROM login_history ORDER BY username, login_time DESC";
   192			String loginResult = executeSQL(loginSQL);
   193			if (loginResult.startsWith("SUCCESS")) {
   194				String[] parts = loginResult.split("\\|");
   195				if (parts.length > 1) {
   196					String currentUser = "";
   197					for (int i = 1; i < parts.length; i++) {
   198						String[] fields = parts[i].replace("(", "").replace(")", "").replace("'", "").split(", ");
   199						if (fields.length >= 3) {
   200							if (!fields[0].equals(currentUser)) {
   201								currentUser = fields[0];
   202								System.out.println("\n   User: " + currentUser);
   203							}
   204							System.out.println("      Login:  " + fields[1]);
   205							System.out.println("      Logout: " + (fields[2].equals("None") ? "Still logged in" : fields[2]));
   206						}
   207					}
   208				} else {
   209					System.out.println("   No login history");
   210				}
   211			}
   212			
   213			// File uploads for each user
   214			System.out.println("\n3. FILE UPLOADS:");
   215			System.out.println(repeat("-", 80));
   216			String filesSQL = "SELECT username, filename, upload_time, game_channel FROM file_tracking ORDER BY username, upload_time DESC";
   217			String filesResult = executeSQL(filesSQL);
   218			if (filesResult.startsWith("SUCCESS")) {
   219				String[] parts = filesResult.split("\\|");
   220				if (parts.length > 1) {
   221					String currentUser = "";
   222					for (int i = 1; i < parts.length; i++) {
   223						String[] fields = parts[i].replace("(", "").replace(")", "").replace("'", "").split(", ");
   224						if (fields.length >= 4) {
   225							if (!fields[0].equals(currentUser)) {
   226								currentUser = fields[0];
   227								System.out.println("\n   User: " + currentUser);
   228							}
   229							System.out.println("      File: " + fields[1]);
   230							System.out.println("      Time: " + fields[2]);
   231							System.out.println("      Game: " + fields[3]);
   232							System.out.println();
   233						}
   234					}
   235				} else {
   236					System.out.println("   No files uploaded");
   237				}
   238			}
   239			
   240		System.out.println(repeat("=", 80));
   241	}
   242	
   243	private String repeat(String str, int times) {
   244		StringBuilder sb = new StringBuilder();
   245		for (int i = 0; i < times; i++) {
   246			sb.append(str);
   247		}
   248		return sb.toString();
   249	}
   250	
   251	private static class Instance {
   252		static Database instance = new Database();
   253	}}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/data/LoginStatus.java =====
     1	package bgu.spl.net.impl.data;
     2	
     3	public enum LoginStatus {
     4		CLIENT_ALREADY_CONNECTED, ADDED_NEW_USER, ALREADY_LOGGED_IN, LOGGED_IN_SUCCESSFULLY, WRONG_PASSWORD
     5	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/data/User.java =====
     1	package bgu.spl.net.impl.data;
     2	
     3	public class User {
     4		public final String name;
     5		public final String password;
     6		private int connectionId;
     7		private boolean isLoggedIn = false;
     8	
     9		public User(int connectionId, String name, String password) {
    10			this.connectionId = connectionId;
    11			this.name = name;
    12			this.password = password;
    13		}
    14	
    15		public boolean isLoggedIn() {
    16			return isLoggedIn;
    17		}
    18	
    19		public void login() {
    20			isLoggedIn = true;
    21		}
    22	
    23		public void logout() {
    24			isLoggedIn = false;
    25		}
    26	
    27		public int getConnectionId() {
    28			return connectionId;
    29		}
    30	
    31		public void setConnectionId(int connectionId) {
    32			this.connectionId = connectionId;
    33		}
    34	
    35	
    36	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/echo/EchoClient.java =====
     1	package bgu.spl.net.impl.echo;
     2	
     3	import java.io.BufferedReader;
     4	import java.io.BufferedWriter;
     5	import java.io.IOException;
     6	import java.io.InputStreamReader;
     7	import java.io.OutputStreamWriter;
     8	import java.net.Socket;
     9	
    10	public class EchoClient {
    11	
    12	    public static void main(String[] args) throws IOException {
    13	
    14	        if (args.length == 0) {
    15	            args = new String[]{"localhost", "hello"};
    16	        }
    17	
    18	        if (args.length < 2) {
    19	            System.out.println("you must supply two arguments: host, message");
    20	            System.exit(1);
    21	        }
    22	
    23	        //BufferedReader and BufferedWriter automatically using UTF-8 encoding
    24	        try (Socket sock = new Socket(args[0], 7777);
    25	                BufferedReader in = new BufferedReader(new InputStreamReader(sock.getInputStream()));
    26	                BufferedWriter out = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()))) {
    27	
    28	            System.out.println("sending message to server");
    29	            out.write(args[1]);
    30	            out.newLine();
    31	            out.flush();
    32	
    33	            System.out.println("awaiting response");
    34	            String line = in.readLine();
    35	            System.out.println("message from server: " + line);
    36	        }
    37	    }
    38	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/echo/EchoProtocol.java =====
     1	package bgu.spl.net.impl.echo;
     2	
     3	import bgu.spl.net.api.MessagingProtocol;
     4	import java.time.LocalDateTime;
     5	
     6	public class EchoProtocol implements MessagingProtocol<String> {
     7	
     8	    private boolean shouldTerminate = false;
     9	
    10	    @Override
    11	    public String process(String msg) {
    12	        shouldTerminate = "bye".equals(msg);
    13	        System.out.println("[" + LocalDateTime.now() + "]: " + msg);
    14	        return createEcho(msg);
    15	    }
    16	
    17	    private String createEcho(String message) {
    18	        String echoPart = message.substring(Math.max(message.length() - 2, 0), message.length());
    19	        return message + " .. " + echoPart + " .. " + echoPart + " ..";
    20	    }
    21	
    22	    @Override
    23	    public boolean shouldTerminate() {
    24	        return shouldTerminate;
    25	    }
    26	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/echo/EchoServer.java =====
     1	package bgu.spl.net.impl.echo;
     2	
     3	import bgu.spl.net.srv.Server;
     4	
     5	public class EchoServer {
     6	
     7	    public static void main(String[] args) {
     8	
     9	        // you can use any server... 
    10	        Server.threadPerClient(
    11	                7777, //port
    12	                () -> new EchoProtocol(), //protocol factory
    13	                LineMessageEncoderDecoder::new //message encoder decoder factory
    14	        ).serve();
    15	
    16	        // Server.reactor(
    17	        //         Runtime.getRuntime().availableProcessors(),
    18	        //         7777, //port
    19	        //         () -> new EchoProtocol<>(), //protocol factory
    20	        //         LineMessageEncoderDecoder::new //message encoder decoder factory
    21	        // ).serve();
    22	    }
    23	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/echo/LineMessageEncoderDecoder.java =====
     1	package bgu.spl.net.impl.echo;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	import java.nio.charset.StandardCharsets;
     5	import java.util.Arrays;
     6	
     7	public class LineMessageEncoderDecoder implements MessageEncoderDecoder<String> {
     8	
     9	    private byte[] bytes = new byte[1 << 10]; //start with 1k
    10	    private int len = 0;
    11	
    12	    @Override
    13	    public String decodeNextByte(byte nextByte) {
    14	        //notice that the top 128 ascii characters have the same representation as their utf-8 counterparts
    15	        //this allow us to do the following comparison
    16	        if (nextByte == '\n') {
    17	            return popString();
    18	        }
    19	
    20	        pushByte(nextByte);
    21	        return null; //not a line yet
    22	    }
    23	
    24	    @Override
    25	    public byte[] encode(String message) {
    26	        return (message + "\n").getBytes(); //uses utf8 by default
    27	    }
    28	
    29	    private void pushByte(byte nextByte) {
    30	        if (len >= bytes.length) {
    31	            bytes = Arrays.copyOf(bytes, len * 2);
    32	        }
    33	
    34	        bytes[len++] = nextByte;
    35	    }
    36	
    37	    private String popString() {
    38	        //notice that we explicitly requesting that the string will be decoded from UTF-8
    39	        //this is not actually required as it is the default encoding in java.
    40	        String result = new String(bytes, 0, len, StandardCharsets.UTF_8);
    41	        len = 0;
    42	        return result;
    43	    }
    44	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/newsfeed/FetchNewsCommand.java =====
     1	package bgu.spl.net.impl.newsfeed;
     2	
     3	import bgu.spl.net.impl.rci.Command;
     4	import java.io.Serializable;
     5	
     6	public class FetchNewsCommand implements Command<NewsFeed> {
     7	
     8	    private String channel;
     9	
    10	    public FetchNewsCommand(String channel) {
    11	        this.channel = channel;
    12	    }
    13	
    14	    @Override
    15	    public Serializable execute(NewsFeed feed) {
    16	        return feed.fetch(channel);
    17	    }
    18	
    19	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/newsfeed/NewsFeed.java =====
     1	package bgu.spl.net.impl.newsfeed;
     2	
     3	import java.util.ArrayList;
     4	import java.util.concurrent.ConcurrentHashMap;
     5	import java.util.concurrent.ConcurrentLinkedQueue;
     6	
     7	public class NewsFeed {
     8	
     9	    private ConcurrentHashMap<String, ConcurrentLinkedQueue<String>> channels = new ConcurrentHashMap<>();
    10	
    11	    public ArrayList<String> fetch(String channel) {
    12	        ConcurrentLinkedQueue<String> queue = channels.get(channel);
    13	        if (queue == null) {
    14	            return new ArrayList<>(0); //empty
    15	        } else {
    16	            return new ArrayList<>(queue); //copy of the queue, arraylist is serializable
    17	        }
    18	    }
    19	
    20	    public void publish(String channel, String news) {
    21	        ConcurrentLinkedQueue<String> queue = channels.computeIfAbsent(channel, k -> new ConcurrentLinkedQueue<>());
    22	        queue.add(news);
    23	    }
    24	
    25	    public void clear() {
    26	        channels.clear();
    27	    }
    28	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/newsfeed/NewsFeedClientMain.java =====
     1	package bgu.spl.net.impl.newsfeed;
     2	
     3	import bgu.spl.net.impl.rci.RCIClient;
     4	
     5	public class NewsFeedClientMain {
     6	
     7	    public static void main(String[] args) throws Exception {
     8	        if (args.length == 0) {
     9	            args = new String[]{"127.0.0.1"};
    10	        }
    11	
    12	//        System.out.println("running clients");
    13	        runFirstClient(args[0]);
    14	        runSecondClient(args[0]);
    15	        runThirdClient(args[0]);
    16	    }
    17	
    18	    private static void runFirstClient(String host) throws Exception {
    19	        try (RCIClient c = new RCIClient(host, 7777)) {
    20	            c.send(new PublishNewsCommand(
    21	                    "jobs",
    22	                    "System Programmer, knowledge in C++, Java and Python required. call 0x134693F"));
    23	
    24	            c.receive(); //ok
    25	
    26	            c.send(new PublishNewsCommand(
    27	                    "headlines",
    28	                    "new SPL assignment is out soon!!"));
    29	
    30	            c.receive(); //ok
    31	
    32	            c.send(new PublishNewsCommand(
    33	                    "headlines",
    34	                    "THE CAKE IS A LIE!"));
    35	
    36	            c.receive(); //ok
    37	        }
    38	
    39	    }
    40	
    41	    private static void runSecondClient(String host) throws Exception {
    42	        try (RCIClient c = new RCIClient(host, 7777)) {
    43	            c.send(new FetchNewsCommand("jobs"));
    44	            System.out.println("second client received: " + c.receive());
    45	        }
    46	    }
    47	
    48	    private static void runThirdClient(String host) throws Exception {
    49	        try (RCIClient c = new RCIClient(host, 7777)) {
    50	            c.send(new FetchNewsCommand("headlines"));
    51	            System.out.println("third client received: " + c.receive());
    52	        }
    53	    }
    54	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/newsfeed/NewsFeedServerMain.java =====
     1	package bgu.spl.net.impl.newsfeed;
     2	
     3	import bgu.spl.net.impl.rci.ObjectEncoderDecoder;
     4	import bgu.spl.net.impl.rci.RemoteCommandInvocationProtocol;
     5	import bgu.spl.net.srv.Server;
     6	
     7	public class NewsFeedServerMain {
     8	
     9	    public static void main(String[] args) {
    10	        NewsFeed feed = new NewsFeed(); //one shared object
    11	
    12	        // you can use any server... 
    13	        Server.threadPerClient(
    14	                7777, //port
    15	                () -> new RemoteCommandInvocationProtocol<>(feed), //protocol factory
    16	                ObjectEncoderDecoder::new //message encoder decoder factory
    17	        ).serve();
    18	
    19	        // Server.reactor(
    20	        //         Runtime.getRuntime().availableProcessors(),
    21	        //         7777, //port
    22	        //         () ->  new RemoteCommandInvocationProtocol<>(feed), //protocol factory
    23	        //         ObjectEncoderDecoder::new //message encoder decoder factory
    24	        // ).serve();
    25	    }
    26	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/newsfeed/PublishNewsCommand.java =====
     1	package bgu.spl.net.impl.newsfeed;
     2	
     3	import bgu.spl.net.impl.rci.Command;
     4	import java.io.Serializable;
     5	
     6	public class PublishNewsCommand implements Command<NewsFeed> {
     7	 
     8	    private String channel;
     9	    private String news;
    10	 
    11	    public PublishNewsCommand(String channel, String news) {
    12	        this.channel = channel;
    13	        this.news = news;
    14	    }
    15	 
    16	    @Override
    17	    public Serializable execute(NewsFeed feed) {
    18	        feed.publish(channel, news);
    19	        return "OK";
    20	    }
    21	 
    22	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/rci/Command.java =====
     1	package bgu.spl.net.impl.rci;
     2	
     3	import java.io.Serializable;
     4	
     5	public interface Command<T> extends Serializable {
     6	
     7	    Serializable execute(T arg);
     8	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/rci/ObjectEncoderDecoder.java =====
     1	package bgu.spl.net.impl.rci;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	import java.io.ByteArrayInputStream;
     5	import java.io.ByteArrayOutputStream;
     6	import java.io.ObjectInput;
     7	import java.io.ObjectInputStream;
     8	import java.io.ObjectOutput;
     9	import java.io.ObjectOutputStream;
    10	import java.io.Serializable;
    11	import java.nio.ByteBuffer;
    12	
    13	public class ObjectEncoderDecoder implements MessageEncoderDecoder<Serializable> {
    14	
    15	    private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);
    16	    private byte[] objectBytes = null;
    17	    private int objectBytesIndex = 0;
    18	
    19	    @Override
    20	    public Serializable decodeNextByte(byte nextByte) {
    21	        if (objectBytes == null) { //indicates that we are still reading the length
    22	            lengthBuffer.put(nextByte);
    23	            if (!lengthBuffer.hasRemaining()) { //we read 4 bytes and therefore can take the length
    24	                lengthBuffer.flip();
    25	                objectBytes = new byte[lengthBuffer.getInt()];
    26	                objectBytesIndex = 0;
    27	                lengthBuffer.clear();
    28	            }
    29	        } else {
    30	            objectBytes[objectBytesIndex] = nextByte;
    31	            if (++objectBytesIndex == objectBytes.length) {
    32	                Serializable result = deserializeObject();
    33	                objectBytes = null;
    34	                return result;
    35	            }
    36	        }
    37	
    38	        return null;
    39	    }
    40	
    41	    @Override
    42	    public byte[] encode(Serializable message) {
    43	        return serializeObject(message);
    44	    }
    45	
    46	    private Serializable deserializeObject() {
    47	        try {
    48	            ObjectInput in = new ObjectInputStream(new ByteArrayInputStream(objectBytes));
    49	            return (Serializable) in.readObject();
    50	        } catch (Exception ex) {
    51	            throw new IllegalArgumentException("cannot desrialize object", ex);
    52	        }
    53	
    54	    }
    55	
    56	    private byte[] serializeObject(Serializable message) {
    57	        try {
    58	            ByteArrayOutputStream bytes = new ByteArrayOutputStream();
    59	
    60	            //placeholder for the object size
    61	            for (int i = 0; i < 4; i++) {
    62	                bytes.write(0);
    63	            }
    64	
    65	            ObjectOutput out = new ObjectOutputStream(bytes);
    66	            out.writeObject(message);
    67	            out.flush();
    68	            byte[] result = bytes.toByteArray();
    69	
    70	            //now write the object size
    71	            ByteBuffer.wrap(result).putInt(result.length - 4);
    72	            return result;
    73	
    74	        } catch (Exception ex) {
    75	            throw new IllegalArgumentException("cannot serialize object", ex);
    76	        }
    77	    }
    78	
    79	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/rci/RCIClient.java =====
     1	package bgu.spl.net.impl.rci;
     2	
     3	import java.io.BufferedInputStream;
     4	import java.io.BufferedOutputStream;
     5	import java.io.Closeable;
     6	import java.io.IOException;
     7	import java.io.Serializable;
     8	import java.net.Socket;
     9	
    10	public class RCIClient implements Closeable {
    11	
    12	    private final ObjectEncoderDecoder encdec;
    13	    private final Socket sock;
    14	    private final BufferedInputStream in;
    15	    private final BufferedOutputStream out;
    16	
    17	    public RCIClient(String host, int port) throws IOException {
    18	        sock = new Socket(host, port);
    19	        encdec = new ObjectEncoderDecoder();
    20	        in = new BufferedInputStream(sock.getInputStream());
    21	        out = new BufferedOutputStream(sock.getOutputStream());
    22	    }
    23	
    24	    public void send(Command<?> cmd) throws IOException {
    25	        out.write(encdec.encode(cmd));
    26	        out.flush();
    27	    }
    28	
    29	    public Serializable receive() throws IOException {
    30	        int read;
    31	        while ((read = in.read()) >= 0) {
    32	            Serializable msg = encdec.decodeNextByte((byte) read);
    33	            if (msg != null) {
    34	                return msg;
    35	            }
    36	        }
    37	
    38	        throw new IOException("disconnected before complete reading message");
    39	    }
    40	
    41	    @Override
    42	    public void close() throws IOException {
    43	        out.close();
    44	        in.close();
    45	        sock.close();
    46	    }
    47	
    48	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/rci/RemoteCommandInvocationProtocol.java =====
     1	package bgu.spl.net.impl.rci;
     2	
     3	import bgu.spl.net.api.MessagingProtocol;
     4	import java.io.Serializable;
     5	
     6	public class RemoteCommandInvocationProtocol<T> implements MessagingProtocol<Serializable> {
     7	
     8	    private T arg;
     9	
    10	    public RemoteCommandInvocationProtocol(T arg) {
    11	        this.arg = arg;
    12	    }
    13	
    14	    @Override
    15	    public Serializable process(Serializable msg) {
    16	        return ((Command) msg).execute(arg);
    17	    }
    18	
    19	    @Override
    20	    public boolean shouldTerminate() {
    21	        return false;
    22	    }
    23	
    24	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/stomp/StompFrame.java =====
     1	package bgu.spl.net.impl.stomp;
     2	
     3	import java.util.HashMap;
     4	import java.util.Map;
     5	
     6	public class StompFrame {
     7	    private String command;
     8	    private Map<String,String> headers = new HashMap<>();
     9	    private String body;
    10	
    11	    public StompFrame(String commands) {
    12	        this.command = commands;
    13	    }
    14	    public StompFrame(StompFrame other) {
    15	        this.command = other.command;
    16	        this.headers = new HashMap<>(other.headers);
    17	        this.body = other.body;
    18	    }
    19	    public String getCommand() {
    20	        return command;
    21	    }
    22	    public void addHeader(String key, String value) {
    23	        headers.put(key, value);
    24	    }
    25	    public String getHeader(String key) {
    26	        return headers.get(key);
    27	    }
    28	    public void setBody(String body) {
    29	        this.body = body;
    30	    }
    31	    public String getBody() {
    32	        return this.body;
    33	    }
    34	
    35	    public static StompFrame fromString(String rawMessage) {
    36	        StompFrame ret = null;
    37	        int i = 0;
    38	
    39	        if (rawMessage == null || rawMessage.length() == 0) {
    40	            return null;
    41	        }
    42	
    43	        String[] lines = rawMessage.split("\n");
    44	
    45	        // COMMAND
    46	        ret = new StompFrame(lines[i].trim());
    47	        i++;
    48	
    49	        // HEADERS - until end of lines or an empty line
    50	        for (i = 1; i < lines.length && !lines[i].isEmpty(); i++) {
    51	            String[] parts = lines[i].split(":", 2);
    52	            // Add new Header to frame
    53	            if (parts.length == 2) {
    54	                ret.addHeader(parts[0].trim(), parts[1].trim());
    55	            }
    56	        }
    57	
    58	        // BODY - build body until end of message
    59	        StringBuilder bodyBuilder = new StringBuilder();
    60	
    61	        // if we got to an empty line
    62	        if (i != lines.length) {
    63	            i++; // continuing after empty line
    64	            for (; i < lines.length; i++) {
    65	                bodyBuilder.append(lines[i]);
    66	
    67	                // add new line
    68	                if (i < lines.length - 1) {
    69	                    bodyBuilder.append("\n");
    70	                }
    71	            }
    72	        }
    73	
    74	        ret.setBody(bodyBuilder.toString());
    75	
    76	        return ret;
    77	    }
    78	
    79	    @Override
    80	    public String toString() {
    81	        StringBuilder sb = new StringBuilder();
    82	
    83	        // 1. Command
    84	        sb.append(command).append("\n");
    85	
    86	        // 2. Headers
    87	        for (Map.Entry<String, String> header : headers.entrySet()) {
    88	            sb.append(header.getKey())
    89	                    .append(":")
    90	                    .append(header.getValue())
    91	                    .append("\n");
    92	        }
    93	
    94	        // 3. Empty Line - SEPARATION
    95	        sb.append("\n");
    96	
    97	        // 4. Body
    98	        if (body != null && !body.isEmpty()) {
    99	            sb.append(body);
   100	        }
   101	
   102	        return sb.toString();
   103	    }
   104	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/stomp/StompMessageEncoderDecoder.java =====
     1	package bgu.spl.net.impl.stomp;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	
     5	public class StompMessageEncoderDecoder implements MessageEncoderDecoder<StompFrame> {
     6	    private byte[] bytes = new byte[1024];
     7	    private int len = 0;
     8	    private static final int MAX_MESSAGE_SIZE = 1 << 20;
     9	    @Override
    10	    public StompFrame decodeNextByte(byte nextByte) {
    11	        if(nextByte == '\0'){
    12	            return popMessage();
    13	        }
    14	        pushByte(nextByte);
    15	        return null;
    16	    }
    17	
    18	    private void pushByte(byte nextByte) {
    19	        if (len >= MAX_MESSAGE_SIZE) {
    20	            throw new RuntimeException("Message size limit exceeded");
    21	        }
    22	        // if needed, resize the array
    23	        if (len >= bytes.length) {
    24	            //double the size of the array
    25	            bytes = java.util.Arrays.copyOf(bytes, len * 2);
    26	        }
    27	        bytes[len++] = nextByte;   
    28	    }
    29	    // when we get here we have a full message
    30	    private StompFrame popMessage() {
    31	        String message = new String(bytes,0,len, java.nio.charset.StandardCharsets.UTF_8);
    32	        len = 0;
    33	        return StompFrame.fromString(message);
    34	    }
    35	
    36	    @Override
    37	    public byte[] encode(StompFrame message) {
    38	        StringBuilder strMessage = new StringBuilder(message.toString());
    39	        strMessage.append('\0');
    40	        return strMessage.toString().getBytes(java.nio.charset.StandardCharsets.UTF_8);
    41	    }
    42	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/stomp/StompMessagingProtocolImpl.java =====
     1	package bgu.spl.net.impl.stomp;
     2	
     3	import java.util.Map;
     4	import java.util.concurrent.ConcurrentHashMap;
     5	import java.util.concurrent.atomic.AtomicInteger;
     6	
     7	import bgu.spl.net.impl.data.Database;
     8	import bgu.spl.net.api.StompMessagingProtocol;
     9	import bgu.spl.net.impl.data.LoginStatus;
    10	import bgu.spl.net.srv.Connections;
    11	
    12	public class StompMessagingProtocolImpl implements StompMessagingProtocol<StompFrame> {
    13	    private int connectionId;
    14	    private Connections<StompFrame> connections;
    15	    private boolean shouldTerminate = false;
    16	    private boolean isLoggedIn = false;
    17	    private String currentUser = null;
    18	    private Map<String, String> subscriptions = new ConcurrentHashMap<>();
    19	    private static AtomicInteger messageIdCounter = new AtomicInteger(0);
    20	
    21	    @Override
    22	    public void start(int connectionId, Connections<StompFrame> connections) {
    23	        this.connectionId = connectionId;
    24	        this.connections = connections;
    25	    }
    26	    @Override
    27	    public StompFrame process(StompFrame frame) {
    28	        String command = frame.getCommand();
    29	        // Check if user is logged in for commands other than CONNECT
    30	        if(!isLoggedIn && !command.equals("CONNECT")) {
    31	            sendError(frame, "User not logged in", "You must log in before sending other commands.");
    32	        }
    33	        else{
    34	            switch (command) {
    35	                case "CONNECT":
    36	                    handleConnect(frame);
    37	                    break;
    38	                case "SEND":
    39	                    handleSend(frame);
    40	                    break;
    41	                case "SUBSCRIBE":
    42	                    handleSubscribe(frame);
    43	                    break;
    44	                case "UNSUBSCRIBE":
    45	                    handleUnsubscribe(frame);
    46	                    break;
    47	                case "DISCONNECT":
    48	                    handleDisconnect(frame);
    49	                    break;
    50	                default:
    51	                    sendError(frame, "Unknown command", "The command '" + command + "' is not recognized.");
    52	                    shouldTerminate = true;
    53	                    break;
    54	        }
    55	    }
    56	    return null;
    57	}
    58	
    59	    private void handleDisconnect(StompFrame frame) {
    60	        if (!isLoggedIn) {
    61	            sendError(frame, "Not logged in", "You must be logged in to disconnect.");
    62	            return;
    63	        }
    64	
    65	        String receipt = frame.getHeader("receipt");
    66	        if (receipt != null) {
    67	            sendReceipt(receipt);
    68	        }
    69	
    70	        // Perform logout
    71	        Database.getInstance().logout(connectionId);
    72	        this.shouldTerminate = true;
    73	    }
    74	    private void handleUnsubscribe(StompFrame frame) {
    75	        if (!isLoggedIn) {
    76	            sendError(frame, "Not logged in", "You must be logged in to unsubscribe.");
    77	            return;
    78	        }
    79	
    80	        String requestId = frame.getHeader("id");
    81	
    82	        if (requestId == null || requestId.isEmpty()) {
    83	            sendError(frame, "Malformed UNSUBSCRIBE", "Missing 'id' header.");
    84	            return;
    85	        }
    86	        // Check if subscribed with the given id
    87	        String destination = subscriptions.remove(requestId);
    88	        if (destination == null) {
    89	            sendError(frame, "Subscription not found", "No active subscription found with ID: " + requestId);
    90	            return;
    91	        }
    92	
    93	        connections.unsubscribe(destination, connectionId, requestId);
    94	
    95	        // Handle receipt if requested
    96	        String receipt = frame.getHeader("receipt");
    97	        if (receipt != null) {
    98	            sendReceipt(receipt);
    99	        }
   100	    }
   101	    private void handleSubscribe(StompFrame frame) {
   102	        System.err.println("DEBUG Handling SUBSCRIBE frame");
   103	        if (!isLoggedIn) {
   104	            sendError(frame, "Not logged in", "You must be logged in to subscribe.");
   105	            return;
   106	        }
   107	
   108	        String destination = frame.getHeader("destination");
   109	        String requestId = frame.getHeader("id");
   110	
   111	        if (destination == null || destination.isEmpty() || requestId == null || requestId.isEmpty()) {
   112	            sendError(frame, "Malformed SUBSCRIBE", "Missing 'destination' or 'id' header.");            return;
   113	        }
   114	
   115	        // Check if already subscribed with the same id
   116	        if (subscriptions.containsKey(requestId)) {
   117	            sendError(frame, "Already subscribed", "You are already subscribed with id '" + requestId + "'.");
   118	            return;
   119	        }
   120	
   121	        subscriptions.put(requestId, destination);
   122	        
   123	        connections.subscribe(destination, connectionId, requestId);
   124	
   125	        // Handle receipt if requested
   126	        String receipt = frame.getHeader("receipt");
   127	        if (receipt != null) {
   128	            sendReceipt(receipt);
   129	        }
   130	    }
   131	    private void handleSend(StompFrame frame) {
   132	        if (!isLoggedIn) {
   133	            sendError(frame, "Not logged in", "You must be logged in to send messages.");
   134	            return;
   135	        }
   136	
   137	        String destination = frame.getHeader("destination");
   138	        if (destination == null || destination.isEmpty()) {
   139	            sendError(frame, "Missing destination", "SEND frame must include a destination header.");
   140	            return;
   141	        }
   142	
   143	        if (!subscriptions.containsValue(destination)) {
   144	            sendError(frame, "Not subscribed", "You cannot send to '" + destination + "' without subscribing first.");
   145	            return;
   146	        }
   147	
   148	        /*// Track file upload if 'file-name' header is present
   149	        String filename = frame.getHeader("file-name"); 
   150	        if (filename != null) {
   151	            Database.getInstance().trackFileUpload(currentUser, filename, destination);
   152	        }*/
   153	
   154	        StompFrame messageFrame = new StompFrame("MESSAGE");
   155	        messageFrame.addHeader("destination", destination);
   156	        messageFrame.addHeader("message-id", String.valueOf(messageIdCounter.incrementAndGet()));
   157	        // Copy the body and content (Game updates, user, team names, etc.)
   158	        // We don't validate them, we just pass them through.
   159	        messageFrame.setBody(frame.getBody());
   160	
   161	        // Send the MESSAGE frame (not the SEND frame)
   162	        connections.send(destination, messageFrame);
   163	
   164	        // Handle receipt if requested
   165	        String receipt = frame.getHeader("receipt");
   166	        if (receipt != null) {
   167	            sendReceipt(receipt);
   168	        }
   169	}
   170	    private void handleConnect(StompFrame frame) {
   171	        if(isLoggedIn) {
   172	            sendError(frame, "Already logged in", "You are already logged in.");
   173	            return;
   174	        }
   175	        String username = frame.getHeader("login");
   176	        String passcode = frame.getHeader("passcode");
   177	        String acceptVersion = frame.getHeader("accept-version");
   178	        String host = frame.getHeader("host");
   179	
   180	        if (username == null || passcode == null || host == null) {
   181	            sendError(frame, "Missing credentials", "Login or passcode header is missing.");
   182	            return;
   183	        }
   184	        
   185	        LoginStatus status = Database.getInstance().login(connectionId, username, passcode);
   186	        switch (status) {
   187	            case LOGGED_IN_SUCCESSFULLY:
   188	            case ADDED_NEW_USER:
   189	                this.currentUser = username;
   190	                sendConnectedFrame();
   191	                break;
   192	            case CLIENT_ALREADY_CONNECTED:
   193	                sendError(frame, "Client already connected", "This client is already connected.");
   194	                break;
   195	            case ALREADY_LOGGED_IN:
   196	                sendError(frame, "Already logged in", "This user is already logged in.");
   197	                break;
   198	            case WRONG_PASSWORD:
   199	                sendError(frame, "Wrong password", "The passcode you entered is incorrect.");
   200	                break;
   201	            default:
   202	                sendError(frame, "Login failed", "Login failed due to unknown reasons.");
   203	                break;
   204	        }
   205	    }
   206	    @Override
   207	    public boolean shouldTerminate() {
   208	        return shouldTerminate;
   209	    }
   210	    private void sendConnectedFrame() {
   211	        this.isLoggedIn = true;
   212	        StompFrame connectedFrame = new StompFrame("CONNECTED");
   213	        connectedFrame.addHeader("version", "1.2");
   214	        connections.send(connectionId, connectedFrame);
   215	    }
   216	/**
   217	 * Sends a RECEIPT frame to acknowledge that a command with a receipt header was processed.
   218	 * @param receiptId The receipt ID from the original frame's receipt header.
   219	 */
   220	private void sendReceipt(String receiptId) {
   221	    StompFrame receiptFrame = new StompFrame("RECEIPT");
   222	    receiptFrame.addHeader("receipt-id", receiptId);
   223	    connections.send(connectionId, receiptFrame);
   224	}
   225	
   226	/**
   227	 * Sends an ERROR frame in the specific format required by the assignment and closes the connection.
   228	 * * @param faultyFrame The original frame that caused the error (used to extract receipt-id and print in body).
   229	 * @param messageHeader A short description of the error (goes into the 'message' header).
   230	 * @param detailedInfo A detailed explanation (goes into the body).
   231	 */
   232	private void sendError(StompFrame faultyFrame, String messageHeader, String detailedInfo) {
   233	    StompFrame errorFrame = new StompFrame("ERROR");
   234	
   235	    errorFrame.addHeader("message", messageHeader);
   236	
   237	    if (faultyFrame != null) {
   238	        String receipt = faultyFrame.getHeader("receipt");
   239	        if (receipt != null) {
   240	            errorFrame.addHeader("receipt-id", receipt);
   241	        }
   242	    }
   243	
   244	    // Construct the body in the requested format
   245	    StringBuilder body = new StringBuilder();
   246	    body.append("The message:\n");
   247	    body.append("-----\n");
   248	    
   249	    if (faultyFrame != null) {
   250	        // Assuming your StompFrame.toString() returns the frame representation (Command + Headers + Body)
   251	        body.append(faultyFrame.toString()); 
   252	    } else {
   253	        body.append("(No frame content available)");
   254	    }
   255	    
   256	    body.append("\n-----\n");
   257	    body.append(detailedInfo);
   258	    errorFrame.setBody(body.toString());
   259	    connections.send(connectionId, errorFrame);
   260	
   261	    this.shouldTerminate = true;
   262	    }
   263	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/stomp/StompServer.java =====
     1	package bgu.spl.net.impl.stomp;
     2	
     3	import bgu.spl.net.srv.Server;
     4	
     5	public class StompServer {
     6	
     7	    public static void main(String[] args) {
     8	        if (args.length < 2) {
     9	            System.out.println("Usage: StompServer <port> <server-type>");
    10	            System.out.println("server-type: tpc (Thread Per Client) or reactor");
    11	            return;
    12	        }
    13	
    14	        int port = 0;
    15	        try {
    16	            port = Integer.parseInt(args[0]);
    17	        } catch (NumberFormatException e) {
    18	            System.out.println("Error: Port must be a number.");
    19	            return;
    20	        }
    21	
    22	        String serverType = args[1];
    23	
    24	        if (serverType.equals("tpc")) {
    25	            System.err.println("DEBUG Starting Stomp Server in Thread Per Client mode");
    26	            Server.threadPerClient(
    27	                    port,
    28	                    () -> new StompMessagingProtocolImpl(), // Protocol Factory 
    29	                    () -> new StompMessageEncoderDecoder()         // Encoder Factory
    30	            ).serve();
    31	
    32	        } else if (serverType.equals("reactor")) {
    33	            Server.reactor(
    34	                    Runtime.getRuntime().availableProcessors(),
    35	                    port,
    36	                    () -> new StompMessagingProtocolImpl(), // Protocol Factory (Lambda)
    37	                    () -> new StompMessageEncoderDecoder()         // Encoder Factory (Lambda)
    38	            ).serve();
    39	
    40	        } else {
    41	            System.out.println("Unknown server type: " + serverType);
    42	            System.out.println("Please use 'tpc' or 'reactor'.");
    43	        }
    44	    }
    45	}



===== FILE: ./server/src/main/java/bgu/spl/net/impl/stomp/StompTestClient.java =====
     1	import java.io.OutputStream;
     2	import java.net.Socket;
     3	import java.nio.charset.StandardCharsets;
     4	
     5	public class StompTestClient {
     6	    public static void main(String[] args) throws Exception {
     7	        Socket socket = new Socket("localhost", 7777);
     8	        OutputStream out = socket.getOutputStream();
     9	
    10	        String frame =
    11	                "CONNECT\n" +
    12	                "accept-version :1.2\n" +
    13	                "host:stomp.cs.bgu.ac.il\n" +
    14	                "login:alice\n" +
    15	                "passcode:123\n" +
    16	                "\n";
    17	
    18	        out.write(frame.getBytes(StandardCharsets.UTF_8));
    19	        out.write(0); // STOMP null character
    20	        out.flush();
    21	
    22	        Thread.sleep(5000);
    23	        socket.close();
    24	    }
    25	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/ActorThreadPool.java =====
     1	package bgu.spl.net.srv;
     2	
     3	import java.util.LinkedList;
     4	import java.util.Map;
     5	import java.util.Queue;
     6	import java.util.Set;
     7	import java.util.WeakHashMap;
     8	import java.util.concurrent.ConcurrentHashMap;
     9	import java.util.concurrent.ExecutorService;
    10	import java.util.concurrent.Executors;
    11	import java.util.concurrent.locks.ReadWriteLock;
    12	import java.util.concurrent.locks.ReentrantReadWriteLock;
    13	
    14	public class ActorThreadPool {
    15	
    16	    private final Map<Object, Queue<Runnable>> acts;
    17	    private final ReadWriteLock actsRWLock;
    18	    private final Set<Object> playingNow;
    19	    private final ExecutorService threads;
    20	
    21	    public ActorThreadPool(int threads) {
    22	        this.threads = Executors.newFixedThreadPool(threads);
    23	        acts = new WeakHashMap<>();
    24	        playingNow = ConcurrentHashMap.newKeySet();
    25	        actsRWLock = new ReentrantReadWriteLock();
    26	    }
    27	
    28	    public void submit(Object act, Runnable r) {
    29	        synchronized (act) {
    30	            if (!playingNow.contains(act)) {
    31	                playingNow.add(act);
    32	                execute(r, act);
    33	            } else {
    34	                pendingRunnablesOf(act).add(r);
    35	            }
    36	        }
    37	    }
    38	
    39	    public void shutdown() {
    40	        threads.shutdownNow();
    41	    }
    42	
    43	    private Queue<Runnable> pendingRunnablesOf(Object act) {
    44	
    45	        actsRWLock.readLock().lock();
    46	        Queue<Runnable> pendingRunnables = acts.get(act);
    47	        actsRWLock.readLock().unlock();
    48	
    49	        if (pendingRunnables == null) {
    50	            actsRWLock.writeLock().lock();
    51	            acts.put(act, pendingRunnables = new LinkedList<>());
    52	            actsRWLock.writeLock().unlock();
    53	        }
    54	        return pendingRunnables;
    55	    }
    56	
    57	    private void execute(Runnable r, Object act) {
    58	        threads.execute(() -> {
    59	            try {
    60	                r.run();
    61	            } finally {
    62	                complete(act);
    63	            }
    64	        });
    65	    }
    66	
    67	    private void complete(Object act) {
    68	        synchronized (act) {
    69	            Queue<Runnable> pending = pendingRunnablesOf(act);
    70	            if (pending.isEmpty()) {
    71	                playingNow.remove(act);
    72	            } else {
    73	                execute(pending.poll(), act);
    74	            }
    75	        }
    76	    }
    77	
    78	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/BaseServer.java =====
     1	package bgu.spl.net.srv;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	import bgu.spl.net.api.MessagingProtocol;
     5	import java.io.IOException;
     6	import java.net.ServerSocket;
     7	import java.net.Socket;
     8	import java.util.function.Supplier;
     9	import java.util.concurrent.atomic.AtomicInteger;
    10	
    11	public abstract class BaseServer<T> implements Server<T> {
    12	
    13	    private final int port;
    14	    private final Supplier<MessagingProtocol<T>> protocolFactory;
    15	    private final Supplier<MessageEncoderDecoder<T>> encdecFactory;
    16	    private ServerSocket sock;
    17	    private final ConnectionsImpl<T> connections = new ConnectionsImpl<>();
    18	    private final AtomicInteger connectionIdCounter = new AtomicInteger(0);
    19	
    20	    public BaseServer(
    21	            int port,
    22	            Supplier<MessagingProtocol<T>> protocolFactory,
    23	            Supplier<MessageEncoderDecoder<T>> encdecFactory) {
    24	
    25	        this.port = port;
    26	        this.protocolFactory = protocolFactory;
    27	        this.encdecFactory = encdecFactory;
    28			this.sock = null;
    29	    }
    30	
    31	    @Override
    32	    public void serve() {
    33	
    34	        try (ServerSocket serverSock = new ServerSocket(port)) {
    35				System.out.println("Server started");
    36	
    37	            this.sock = serverSock; //just to be able to close
    38	
    39	            while (!Thread.currentThread().isInterrupted()) {
    40	
    41	                Socket clientSock = serverSock.accept();
    42	                int connectionId = connectionIdCounter.incrementAndGet();
    43	
    44	                BlockingConnectionHandler<T> handler = new BlockingConnectionHandler<>(
    45	                        clientSock,
    46	                        encdecFactory.get(),
    47	                        protocolFactory.get(),
    48	                        connectionId,
    49	                        connections
    50	                );
    51	                
    52	                connections.addConnection(connectionId, handler);
    53	                execute(handler);
    54	            }
    55	        } catch (IOException ex) {
    56	        }
    57	
    58	        System.out.println("server closed!!!");
    59	    }
    60	
    61	    @Override
    62	    public void close() throws IOException {
    63			if (sock != null)
    64				sock.close();
    65	    }
    66	
    67	    protected abstract void execute(BlockingConnectionHandler<T>  handler);
    68	
    69	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/BlockingConnectionHandler.java =====
     1	package bgu.spl.net.srv;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	import bgu.spl.net.api.StompMessagingProtocol;
     5	import bgu.spl.net.api.MessagingProtocol;
     6	
     7	import java.io.BufferedInputStream;
     8	import java.io.BufferedOutputStream;
     9	import java.io.IOException;
    10	import java.net.Socket;
    11	
    12	public class BlockingConnectionHandler<T> implements Runnable, ConnectionHandler<T> {
    13	
    14	    private final StompMessagingProtocol<T> protocol;
    15	    private final MessageEncoderDecoder<T> encdec;
    16	    private final Socket sock;
    17	    private BufferedInputStream in;
    18	    private BufferedOutputStream out;
    19	    private volatile boolean connected = true;
    20	
    21	    private final int connectionId;
    22	    private final ConnectionsImpl<T> connections;
    23	
    24	    public BlockingConnectionHandler(Socket sock, MessageEncoderDecoder<T> reader, MessagingProtocol<T> protocol, int connectionId, ConnectionsImpl<T> connections) {
    25	        this.sock = sock;
    26	        this.encdec = reader;
    27	
    28	        // Cast to StompMessagingProtocol
    29	        if (protocol instanceof StompMessagingProtocol) {
    30	            this.protocol = (StompMessagingProtocol<T>) protocol;
    31	        } else {
    32	            throw new IllegalArgumentException("Protocol must implement StompMessagingProtocol");
    33	        }
    34	        
    35	        this.connectionId = connectionId;
    36	        this.connections = connections;
    37	    }
    38	
    39	    @Override
    40	    public void run() {
    41	        try (Socket sock = this.sock) { //just for automatic closing
    42	            int read;
    43	
    44	            in = new BufferedInputStream(sock.getInputStream());
    45	            out = new BufferedOutputStream(sock.getOutputStream());
    46	
    47	            // Initialize protocol with connectionId and connections
    48	            protocol.start(connectionId, connections);
    49	
    50	            while (!protocol.shouldTerminate() && connected && (read = in.read()) >= 0) {
    51	                T nextMessage = encdec.decodeNextByte((byte) read);
    52	                if (nextMessage != null) {
    53	                    // Process message (no response needed - protocol uses connections.send())
    54	                    protocol.process(nextMessage);
    55	                    /*if (response != null) {
    56	                        out.write(encdec.encode(response));
    57	                        out.flush();
    58	                    }*/
    59	                }
    60	            }
    61	
    62	        } catch (IOException ex) {
    63	            ex.printStackTrace();
    64	        }
    65	
    66	    }
    67	
    68	    @Override
    69	    public void close() throws IOException {
    70	        connected = false;
    71	        sock.close();
    72	    }
    73	
    74	    @Override
    75	    public void send(T msg) {
    76	         try {
    77	            if (out != null && connected) {
    78	                synchronized (out) {
    79	                    out.write(encdec.encode(msg));
    80	                    out.flush();
    81	                }
    82	            }
    83	        } catch (IOException e) {
    84	            e.printStackTrace();
    85	        }
    86	    }
    87	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/ConnectionHandler.java =====
     1	/*
     2	 * To change this license header, choose License Headers in Project Properties.
     3	 * To change this template file, choose Tools | Templates
     4	 * and open the template in the editor.
     5	 */
     6	package bgu.spl.net.srv;
     7	
     8	import java.io.Closeable;
     9	
    10	/**
    11	 * The ConnectionHandler interface for Message of type T
    12	 */
    13	public interface ConnectionHandler<T> extends Closeable {
    14	
    15	    /**
    16	     * Comment the following lines (both send methods) for the existing implentations to work.
    17	     *
    18	     */
    19	
    20	    void send(T msg);
    21	
    22	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/Connections.java =====
     1	package bgu.spl.net.srv;
     2	
     3	import java.io.IOException;
     4	
     5	public interface Connections<T> {
     6	
     7	    boolean send(int connectionId, T msg);
     8	
     9	    void send(String channel, T msg);
    10	
    11	    void disconnect(int connectionId);
    12	
    13	    //new methods for subscribe and unsubscribe
    14	    void subscribe(String channel, int connectionId, String subscriptionId);
    15	    void unsubscribe(String channel, int connectionId, String subscriptionId);
    16	    void addConnection(int connectionId, ConnectionHandler<T> handler);
    17	
    18	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/ConnectionsImpl.java =====
     1	package bgu.spl.net.srv;
     2	import java.io.IOException;
     3	import java.util.Map;
     4	import java.util.Set;
     5	import java.util.concurrent.ConcurrentHashMap;
     6	import java.util.concurrent.atomic.AtomicInteger;
     7	
     8	import bgu.spl.net.impl.stomp.StompFrame;
     9	
    10	public class ConnectionsImpl<T> implements Connections<T> {
    11	    private Map<Integer, ConnectionHandler<T>> connections = new ConcurrentHashMap<>();
    12	    //Map <"Topic" <ConnectionId, SubscriptionId>>
    13	    private Map<String,ConcurrentHashMap<Integer, String>> topics = new ConcurrentHashMap<>();
    14	    private static final AtomicInteger messageIdCounter = new AtomicInteger(0);
    15	
    16	    @Override
    17	    public boolean send(int connectionId, T msg){
    18	        ConnectionHandler<T> handler = connections.get(connectionId);
    19	        if(handler != null){
    20	            handler.send(msg);
    21	            return true;
    22	        }
    23	        return false;
    24	    }
    25	
    26	    @Override
    27	    public void send(String channel, T msg){
    28	        ConcurrentHashMap<Integer, String> subscribers = topics.get(channel);
    29	        if(subscribers != null){
    30	            Set<Integer> connectionIds = subscribers.keySet();
    31	            for(Integer id : connectionIds){
    32	                T msgToSend = addsubscriptionToMsg(msg, id, channel);
    33	                send(id, msgToSend);
    34	            }
    35	        }
    36	    }
    37	
    38	    @Override
    39	    public void disconnect(int connectionId){
    40	        connections.remove(connectionId);//remove user from connections
    41	        for(ConcurrentHashMap<Integer, String> subscribers : topics.values()){ //remove user from all topics he subscribed to
    42	            subscribers.remove(connectionId);
    43	        }
    44	    }
    45	
    46	    @Override
    47	    public void subscribe(String channel, int connectionId, String subscriptionId){
    48	        topics.putIfAbsent(channel, new ConcurrentHashMap<>());
    49	        topics.get(channel).put(connectionId, subscriptionId);
    50	    }
    51	
    52	    @Override
    53	    public void unsubscribe(String channel, int connectionId, String subscriptionId)
    54	    {
    55	        ConcurrentHashMap<Integer, String> subscribers = topics.get(channel);
    56	        if(subscribers != null){
    57	            subscribers.remove(connectionId);
    58	            if (subscribers.isEmpty()) {
    59	                topics.remove(channel);
    60	            }
    61	        }
    62	    }
    63	    public void addConnection(int connectionId, ConnectionHandler<T> handler) {
    64	        System.err.println("DEBUG Adding connection with ID: " + connectionId);
    65	        connections.put(connectionId, handler);
    66	    }
    67	    private T addsubscriptionToMsg(T msg, int connectionId, String channel) {
    68	        if (msg instanceof StompFrame) {
    69	           
    70	            StompFrame cloned = new StompFrame((StompFrame) msg);
    71	            
    72	            ConcurrentHashMap<Integer, String> subscribers = topics.get(channel);
    73	            String subscriptionId = subscribers.get(connectionId);
    74	            if (subscriptionId != null) {
    75	                cloned.addHeader("subscription", subscriptionId);
    76	            }
    77	            
    78	            // Add message-id (server-unique)
    79	            cloned.addHeader("message-id", String.valueOf(messageIdCounter.incrementAndGet()));
    80	
    81	            return (T) cloned;
    82	        }
    83	        
    84	        return msg;
    85	    }
    86	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/NonBlockingConnectionHandler.java =====
     1	package bgu.spl.net.srv;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	import bgu.spl.net.api.MessagingProtocol;
     5	
     6	import java.io.IOException;
     7	import java.nio.ByteBuffer;
     8	import java.nio.channels.SelectionKey;
     9	import java.nio.channels.SocketChannel;
    10	import java.util.Queue;
    11	import java.util.concurrent.ConcurrentLinkedQueue;
    12	
    13	public class NonBlockingConnectionHandler<T> implements ConnectionHandler<T> {
    14	
    15	    private static final int BUFFER_ALLOCATION_SIZE = 1 << 13; //8k
    16	    private static final ConcurrentLinkedQueue<ByteBuffer> BUFFER_POOL = new ConcurrentLinkedQueue<>();
    17	
    18	    private final MessagingProtocol<T> protocol;
    19	    private final MessageEncoderDecoder<T> encdec;
    20	    private final Queue<ByteBuffer> writeQueue = new ConcurrentLinkedQueue<>();
    21	    private final SocketChannel chan;
    22	    private final Reactor reactor;
    23	
    24	    public NonBlockingConnectionHandler(
    25	            MessageEncoderDecoder<T> reader,
    26	            MessagingProtocol<T> protocol,
    27	            SocketChannel chan,
    28	            Reactor reactor) {
    29	        this.chan = chan;
    30	        this.encdec = reader;
    31	        this.protocol = protocol;
    32	        this.reactor = reactor;
    33	    }
    34	
    35	    public Runnable continueRead() {
    36	        ByteBuffer buf = leaseBuffer();
    37	
    38	        boolean success = false;
    39	        try {
    40	            success = chan.read(buf) != -1;
    41	        } catch (IOException ex) {
    42	            ex.printStackTrace();
    43	        }
    44	
    45	        if (success) {
    46	            buf.flip();
    47	            return () -> {
    48	                try {
    49	                    while (buf.hasRemaining()) {
    50	                        T nextMessage = encdec.decodeNextByte(buf.get());
    51	                        if (nextMessage != null) {
    52	                            T response = protocol.process(nextMessage);
    53	                            if (response != null) {
    54	                                writeQueue.add(ByteBuffer.wrap(encdec.encode(response)));
    55	                                reactor.updateInterestedOps(chan, SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    56	                            }
    57	                        }
    58	                    }
    59	                } finally {
    60	                    releaseBuffer(buf);
    61	                }
    62	            };
    63	        } else {
    64	            releaseBuffer(buf);
    65	            close();
    66	            return null;
    67	        }
    68	
    69	    }
    70	
    71	    public void close() {
    72	        try {
    73	            chan.close();
    74	        } catch (IOException ex) {
    75	            ex.printStackTrace();
    76	        }
    77	    }
    78	
    79	    public boolean isClosed() {
    80	        return !chan.isOpen();
    81	    }
    82	
    83	    public void continueWrite() {
    84	        while (!writeQueue.isEmpty()) {
    85	            try {
    86	                ByteBuffer top = writeQueue.peek();
    87	                chan.write(top);
    88	                if (top.hasRemaining()) {
    89	                    return;
    90	                } else {
    91	                    writeQueue.remove();
    92	                }
    93	            } catch (IOException ex) {
    94	                ex.printStackTrace();
    95	                close();
    96	            }
    97	        }
    98	
    99	        if (writeQueue.isEmpty()) {
   100	            if (protocol.shouldTerminate()) close();
   101	            else reactor.updateInterestedOps(chan, SelectionKey.OP_READ);
   102	        }
   103	    }
   104	
   105	    private static ByteBuffer leaseBuffer() {
   106	        ByteBuffer buff = BUFFER_POOL.poll();
   107	        if (buff == null) {
   108	            return ByteBuffer.allocateDirect(BUFFER_ALLOCATION_SIZE);
   109	        }
   110	
   111	        buff.clear();
   112	        return buff;
   113	    }
   114	
   115	    private static void releaseBuffer(ByteBuffer buff) {
   116	        BUFFER_POOL.add(buff);
   117	    }
   118	
   119	    @Override
   120	    public void send(T msg) {
   121	        //IMPLEMENT IF NEEDED
   122	    }
   123	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/Reactor.java =====
     1	package bgu.spl.net.srv;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	import bgu.spl.net.api.MessagingProtocol;
     5	import java.io.IOException;
     6	import java.net.InetSocketAddress;
     7	import java.nio.channels.ClosedSelectorException;
     8	import java.nio.channels.SelectionKey;
     9	import java.nio.channels.Selector;
    10	import java.nio.channels.ServerSocketChannel;
    11	import java.nio.channels.SocketChannel;
    12	import java.util.concurrent.ConcurrentLinkedQueue;
    13	import java.util.function.Supplier;
    14	
    15	public class Reactor<T> implements Server<T> {
    16	
    17	    private final int port;
    18	    private final Supplier<MessagingProtocol<T>> protocolFactory;
    19	    private final Supplier<MessageEncoderDecoder<T>> readerFactory;
    20	    private final ActorThreadPool pool;
    21	    private Selector selector;
    22	
    23	    private Thread selectorThread;
    24	    private final ConcurrentLinkedQueue<Runnable> selectorTasks = new ConcurrentLinkedQueue<>();
    25	
    26	    public Reactor(
    27	            int numThreads,
    28	            int port,
    29	            Supplier<MessagingProtocol<T>> protocolFactory,
    30	            Supplier<MessageEncoderDecoder<T>> readerFactory) {
    31	
    32	        this.pool = new ActorThreadPool(numThreads);
    33	        this.port = port;
    34	        this.protocolFactory = protocolFactory;
    35	        this.readerFactory = readerFactory;
    36	    }
    37	
    38	    @Override
    39	    public void serve() {
    40		selectorThread = Thread.currentThread();
    41	        try (Selector selector = Selector.open();
    42	                ServerSocketChannel serverSock = ServerSocketChannel.open()) {
    43	
    44	            this.selector = selector; //just to be able to close
    45	
    46	            serverSock.bind(new InetSocketAddress(port));
    47	            serverSock.configureBlocking(false);
    48	            serverSock.register(selector, SelectionKey.OP_ACCEPT);
    49				System.out.println("Server started");
    50	
    51	            while (!Thread.currentThread().isInterrupted()) {
    52	
    53	                selector.select();
    54	                runSelectionThreadTasks();
    55	
    56	                for (SelectionKey key : selector.selectedKeys()) {
    57	
    58	                    if (!key.isValid()) {
    59	                        continue;
    60	                    } else if (key.isAcceptable()) {
    61	                        handleAccept(serverSock, selector);
    62	                    } else {
    63	                        handleReadWrite(key);
    64	                    }
    65	                }
    66	
    67	                selector.selectedKeys().clear(); //clear the selected keys set so that we can know about new events
    68	
    69	            }
    70	
    71	        } catch (ClosedSelectorException ex) {
    72	            //do nothing - server was requested to be closed
    73	        } catch (IOException ex) {
    74	            //this is an error
    75	            ex.printStackTrace();
    76	        }
    77	
    78	        System.out.println("server closed!!!");
    79	        pool.shutdown();
    80	    }
    81	
    82	    /*package*/ void updateInterestedOps(SocketChannel chan, int ops) {
    83	        final SelectionKey key = chan.keyFor(selector);
    84	        if (Thread.currentThread() == selectorThread) {
    85	            key.interestOps(ops);
    86	        } else {
    87	            selectorTasks.add(() -> {
    88	                key.interestOps(ops);
    89	            });
    90	            selector.wakeup();
    91	        }
    92	    }
    93	
    94	
    95	    private void handleAccept(ServerSocketChannel serverChan, Selector selector) throws IOException {
    96	        SocketChannel clientChan = serverChan.accept();
    97	        clientChan.configureBlocking(false);
    98	        final NonBlockingConnectionHandler<T> handler = new NonBlockingConnectionHandler<>(
    99	                readerFactory.get(),
   100	                protocolFactory.get(),
   101	                clientChan,
   102	                this);
   103	        clientChan.register(selector, SelectionKey.OP_READ, handler);
   104	    }
   105	
   106	    private void handleReadWrite(SelectionKey key) {
   107	        @SuppressWarnings("unchecked")
   108	        NonBlockingConnectionHandler<T> handler = (NonBlockingConnectionHandler<T>) key.attachment();
   109	
   110	        if (key.isReadable()) {
   111	            Runnable task = handler.continueRead();
   112	            if (task != null) {
   113	                pool.submit(handler, task);
   114	            }
   115	        }
   116	
   117		    if (key.isValid() && key.isWritable()) {
   118	            handler.continueWrite();
   119	        }
   120	    }
   121	
   122	    private void runSelectionThreadTasks() {
   123	        while (!selectorTasks.isEmpty()) {
   124	            selectorTasks.remove().run();
   125	        }
   126	    }
   127	
   128	    @Override
   129	    public void close() throws IOException {
   130	        selector.close();
   131	    }
   132	
   133	}



===== FILE: ./server/src/main/java/bgu/spl/net/srv/Server.java =====
     1	package bgu.spl.net.srv;
     2	
     3	import bgu.spl.net.api.MessageEncoderDecoder;
     4	import bgu.spl.net.api.MessagingProtocol;
     5	import java.io.Closeable;
     6	import java.util.function.Supplier;
     7	
     8	public interface Server<T> extends Closeable {
     9	
    10	    /**
    11	     * The main loop of the server, Starts listening and handling new clients.
    12	     */
    13	    void serve();
    14	
    15	    /**
    16	     *This function returns a new instance of a thread per client pattern server
    17	     * @param port The port for the server socket
    18	     * @param protocolFactory A factory that creats new MessagingProtocols
    19	     * @param encoderDecoderFactory A factory that creats new MessageEncoderDecoder
    20	     * @param <T> The Message Object for the protocol
    21	     * @return A new Thread per client server
    22	     */
    23	    public static <T> Server<T>  threadPerClient(
    24	            int port,
    25	            Supplier<MessagingProtocol<T> > protocolFactory,
    26	            Supplier<MessageEncoderDecoder<T> > encoderDecoderFactory) {
    27	
    28	        return new BaseServer<T>(port, protocolFactory, encoderDecoderFactory) {
    29	            @Override
    30	            protected void execute(BlockingConnectionHandler<T>  handler) {
    31	                new Thread(handler).start();
    32	            }
    33	        };
    34	
    35	    }
    36	
    37	    /**
    38	     * This function returns a new instance of a reactor pattern server
    39	     * @param nthreads Number of threads available for protocol processing
    40	     * @param port The port for the server socket
    41	     * @param protocolFactory A factory that creats new MessagingProtocols
    42	     * @param encoderDecoderFactory A factory that creats new MessageEncoderDecoder
    43	     * @param <T> The Message Object for the protocol
    44	     * @return A new reactor server
    45	     */
    46	    public static <T> Server<T> reactor(
    47	            int nthreads,
    48	            int port,
    49	            Supplier<MessagingProtocol<T>> protocolFactory,
    50	            Supplier<MessageEncoderDecoder<T>> encoderDecoderFactory) {
    51	        return new Reactor<T>(nthreads, port, protocolFactory, encoderDecoderFactory);
    52	    }
    53	
    54	}



