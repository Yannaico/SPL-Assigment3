---File: ./client/include/ConnectionHandler.h---
#pragma once

#include <string>
#include <iostream>
#include <boost/asio.hpp>
#include "StompProtocol.h"
#include <mutex>

using boost::asio::ip::tcp;

class ConnectionHandler {
private:
	const std::string host_;
	const short port_;
	boost::asio::io_service io_service_;   // Provides core I/O functionality
	tcp::socket socket_;

	StompProtocol protocol_;
    
    std::mutex socketMutex_;
    bool connected_;

public:
	ConnectionHandler(std::string host, short port);

	virtual ~ConnectionHandler();

	// Connect to the remote machine
	bool connect();

	// Read a fixed number of bytes from the server - blocking.
	// Returns false in case the connection is closed before bytesToRead bytes can be read.
	bool getBytes(char bytes[], unsigned int bytesToRead);

	// Send a fixed number of bytes from the client - blocking.
	// Returns false in case the connection is closed before all the data is sent.
	bool sendBytes(const char bytes[], int bytesToWrite);

	// Read an ascii line from the server
	// Returns false in case connection closed before a newline can be read.
	bool getLine(std::string &line);

	// Send an ascii line from the server
	// Returns false in case connection closed before all the data is sent.
	bool sendLine(std::string &line);

	// Get Ascii data from the server until the delimiter character
	// Returns false in case connection closed before null can be read.
	bool getFrameAscii(std::string &frame, char delimiter);

	// Send a message to the remote host.
	// Returns false in case connection is closed before all the data is sent.
	bool sendFrameAscii(const std::string &frame, char delimiter);

	// Close down the connection properly.
	void close();
	bool isConnected() const { return connected_; }
    StompProtocol& getProtocol() { return protocol_; }
}; //class ConnectionHandler


---File: ./client/include/event.h---
#pragma once

#include <string>
#include <iostream>
#include <map>
#include <vector>

class Event
{
private:
    // name of team a
    std::string team_a_name;
    // name of team b
    std::string team_b_name;
    // name of the event
    std::string name;
    // time of the event in seconds
    int time;
    // map of all the general game updates
    std::map<std::string, std::string> game_updates;
    // map of all team a updates the second type can be a string bool or int
    std::map<std::string, std::string> team_a_updates;
    // map of all team b updates
    std::map<std::string, std::string> team_b_updates;
    // description of the event
    std::string description;

public:
    Event(std::string name, std::string team_a_name, std::string team_b_name, int time, std::map<std::string, std::string> game_updates, std::map<std::string, std::string> team_a_updates, std::map<std::string, std::string> team_b_updates, std::string discription);
    Event(const std::string & frame_body);
    virtual ~Event();
    const std::string &get_team_a_name() const;
    const std::string &get_team_b_name() const;
    const std::string &get_name() const;
    int get_time() const;
    const std::map<std::string, std::string> &get_game_updates() const;
    const std::map<std::string, std::string> &get_team_a_updates() const;
    const std::map<std::string, std::string> &get_team_b_updates() const;
    const std::string &get_discription() const;
};

// an object that holds the names of the teams and a vector of events, to be returned by the parseEventsFile function
struct names_and_events {
    std::string team_a_name;
    std::string team_b_name;
    std::vector<Event> events;
};

// function that parses the json file and returns a names_and_events object
names_and_events parseEventsFile(std::string json_path);


---File: ./client/include/StompProtocol.h---
#ifndef STOMP_PROTOCOL_H
#define STOMP_PROTOCOL_H

#include <string>
#include <map>
#include <vector>
#include <mutex>
#include "event.h"

using namespace std;

class StompProtocol {
private:
    string username;
    string password;
    int receiptIdCounter;
    int subscriptionIdCounter;
    bool loggedIn;
    mutex mtx;
    
    // Maps subscription ID to topic
    map<string, string> subscriptions;
    

    // Map: user -> game -> events
    map<string, map<string, names_and_events>> gameReports;
    
    string generateReceiptId();
    string generateSubscriptionId();
    
public:
    StompProtocol();
    
    // Frame builders
    string buildConnectFrame(const string& host, 
                                  const string& user, 
                                  const string& pass);
    
    string buildSubscribeFrame(const string& topic);
    
    string buildUnsubscribeFrame(const string& subscriptionId);
    
    string buildSendFrame(const string& topic, 
                               const Event& event, 
                               const string& user);
    
    string buildDisconnectFrame();
    
    // Frame handlers
    void handleMessageFrame(const string& frame);
    
    // Game data management
    void saveGameEvent(const string& user, 
                      const string& gameName, 
                      const Event& event);
    
    void generateSummary(const string& gameName, 
                        const string& user, 
                        const string& outputFile);
    
    // State
    bool isLoggedIn() const { return loggedIn; }
    void setLoggedIn(bool status) { loggedIn = status; }

    string getSubscriptionIdByTopic(const string& topic);
    string getCurrentUsername() const { return username; }

};

#endif

---File: ./client/src/ConnectionHandler.cpp---
#include "../include/ConnectionHandler.h"

using boost::asio::ip::tcp;

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::string;

ConnectionHandler::ConnectionHandler(string host, short port) : host_(host), port_(port), io_service_(),
                                                                socket_(io_service_), connected_(false) {}

ConnectionHandler::~ConnectionHandler() {
	close();
}

bool ConnectionHandler::connect() {
	std::cout << "Starting connect to "
	          << host_ << ":" << port_ << std::endl;
	try {
		tcp::endpoint endpoint(boost::asio::ip::address::from_string(host_), port_); // the server endpoint
		boost::system::error_code error;
		socket_.connect(endpoint, error);
		if (error)
			throw boost::system::system_error(error);
		connected_ = true;
	}
	catch (std::exception &e) {
		std::cerr << "Connection failed (Error: " << e.what() << ')' << std::endl;
		return false;
	}
	return true;
}

bool ConnectionHandler::getBytes(char bytes[], unsigned int bytesToRead) {
	size_t tmp = 0;
	boost::system::error_code error;
	try {
		lock_guard<std::mutex> lock(socketMutex_);
		while (!error && bytesToRead > tmp) {
			tmp += socket_.read_some(boost::asio::buffer(bytes + tmp, bytesToRead - tmp), error);
		}
		if (error)
			throw boost::system::system_error(error);
	} catch (std::exception &e) {
		std::cerr << "recv failed (Error: " << e.what() << ')' << std::endl;
		connected_ = false;
		return false;
	}
	return true;
}

bool ConnectionHandler::sendBytes(const char bytes[], int bytesToWrite) {
	int tmp = 0;
	boost::system::error_code error;
	try {
		std::lock_guard<std::mutex> lock(socketMutex_);
		while (!error && bytesToWrite > tmp) {
			tmp += socket_.write_some(boost::asio::buffer(bytes + tmp, bytesToWrite - tmp), error);
		}
		if (error)
			throw boost::system::system_error(error);
	} catch (std::exception &e) {
		std::cerr << "recv failed (Error: " << e.what() << ')' << std::endl;
		connected_ = false;
		return false;
	}
	return true;
}

bool ConnectionHandler::getLine(std::string &line) {
	return getFrameAscii(line, '\n');
}

bool ConnectionHandler::sendLine(std::string &line) {
	return sendFrameAscii(line, '\n');
}


bool ConnectionHandler::getFrameAscii(std::string &frame, char delimiter) {
	char ch;
	// Stop when we encounter the null character.
	// Notice that the null character is not appended to the frame string.
	try {
		do {
			if (!getBytes(&ch, 1)) {
				return false;
			}
			if (ch != '\0')
				frame.append(1, ch);
		} while (delimiter != ch);
	} catch (std::exception &e) {
		std::cerr << "recv failed2 (Error: " << e.what() << ')' << std::endl;
		connected_ = false;
		return false;
	}
	return true;
}

bool ConnectionHandler::sendFrameAscii(const std::string &frame, char delimiter) {
	bool result = sendBytes(frame.c_str(), frame.length());
	if (!result) return false;
	return sendBytes(&delimiter, 1);
}

// Close down the connection properly.
void ConnectionHandler::close() {
	try {
		connected_ = false;
		socket_.close();
	} catch (...) {
		std::cout << "closing failed: connection already closed" << std::endl;
	}
}


---File: ./client/src/echoClient.cpp---
#include <stdlib.h>
#include "../include/ConnectionHandler.h"

/**
* This code assumes that the server replies the exact text the client sent it (as opposed to the practical session example)
*/
int main (int argc, char *argv[]) {
    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " host port" << std::endl << std::endl;
        return -1;
    }
    std::string host = argv[1];
    short port = atoi(argv[2]);
    
    ConnectionHandler connectionHandler(host, port);
    if (!connectionHandler.connect()) {
        std::cerr << "Cannot connect to " << host << ":" << port << std::endl;
        return 1;
    }
	
	//From here we will see the rest of the ehco client implementation:
    while (1) {
        const short bufsize = 1024;
        char buf[bufsize];
        std::cin.getline(buf, bufsize);
		std::string line(buf);
		int len=line.length();
        if (!connectionHandler.sendLine(line)) {
            std::cout << "Disconnected. Exiting...\n" << std::endl;
            break;
        }
		// connectionHandler.sendLine(line) appends '\n' to the message. Therefor we send len+1 bytes.
        std::cout << "Sent " << len+1 << " bytes to server" << std::endl;

 
        // We can use one of three options to read data from the server:
        // 1. Read a fixed number of characters
        // 2. Read a line (up to the newline character using the getline() buffered reader
        // 3. Read up to the null character
        std::string answer;
        // Get back an answer: by using the expected number of bytes (len bytes + newline delimiter)
        // We could also use: connectionHandler.getline(answer) and then get the answer without the newline char at the end
        if (!connectionHandler.getLine(answer)) {
            std::cout << "Disconnected. Exiting...\n" << std::endl;
            break;
        }
        
		len=answer.length();
		// A C string must end with a 0 char delimiter.  When we filled the answer buffer from the socket
		// we filled up to the \n char - we must make sure now that a 0 char is also present. So we truncate last character.
        answer.resize(len-1);
        std::cout << "Reply: " << answer << " " << len << " bytes " << std::endl << std::endl;
        if (answer == "bye") {
            std::cout << "Exiting...\n" << std::endl;
            break;
        }
    }
    return 0;
}


---File: ./client/src/event.cpp---
#include "../include/event.h"
#include "../include/json.hpp"
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <vector>
#include <sstream>
using json = nlohmann::json;

Event::Event(std::string team_a_name, std::string team_b_name, std::string name, int time,
             std::map<std::string, std::string> game_updates, std::map<std::string, std::string> team_a_updates,
             std::map<std::string, std::string> team_b_updates, std::string discription)
    : team_a_name(team_a_name), team_b_name(team_b_name), name(name),
      time(time), game_updates(game_updates), team_a_updates(team_a_updates),
      team_b_updates(team_b_updates), description(discription)
{
}

Event::~Event()
{
}

const std::string &Event::get_team_a_name() const
{
    return this->team_a_name;
}

const std::string &Event::get_team_b_name() const
{
    return this->team_b_name;
}

const std::string &Event::get_name() const
{
    return this->name;
}

int Event::get_time() const
{
    return this->time;
}

const std::map<std::string, std::string> &Event::get_game_updates() const
{
    return this->game_updates;
}

const std::map<std::string, std::string> &Event::get_team_a_updates() const
{
    return this->team_a_updates;
}

const std::map<std::string, std::string> &Event::get_team_b_updates() const
{
    return this->team_b_updates;
}

const std::string &Event::get_discription() const
{
    return this->description;
}

Event::Event(const std::string &frame_body) : team_a_name(""), team_b_name(""), name(""), time(0), game_updates(), team_a_updates(), team_b_updates(), description("")
{
}

names_and_events parseEventsFile(std::string json_path)
{
    std::ifstream f(json_path);
    json data = json::parse(f);

    std::string team_a_name = data["team a"];
    std::string team_b_name = data["team b"];

    // run over all the events and convert them to Event objects
    std::vector<Event> events;
    for (auto &event : data["events"])
    {
        std::string name = event["event name"];
        int time = event["time"];
        std::string description = event["description"];
        std::map<std::string, std::string> game_updates;
        std::map<std::string, std::string> team_a_updates;
        std::map<std::string, std::string> team_b_updates;
        for (auto &update : event["general game updates"].items())
        {
            if (update.value().is_string())
                game_updates[update.key()] = update.value();
            else
                game_updates[update.key()] = update.value().dump();
        }

        for (auto &update : event["team a updates"].items())
        {
            if (update.value().is_string())
                team_a_updates[update.key()] = update.value();
            else
                team_a_updates[update.key()] = update.value().dump();
        }

        for (auto &update : event["team b updates"].items())
        {
            if (update.value().is_string())
                team_b_updates[update.key()] = update.value();
            else
                team_b_updates[update.key()] = update.value().dump();
        }
        
        events.push_back(Event(team_a_name, team_b_name, name, time, game_updates, team_a_updates, team_b_updates, description));
    }
    names_and_events events_and_names{team_a_name, team_b_name, events};

    return events_and_names;
}

---File: ./client/src/StompClient.cpp---
#include <iostream>
#include <thread>
#include <string>
#include <sstream>
#include <vector>
#include "../include/ConnectionHandler.h"
#include "event.h"

void socketReaderThread(ConnectionHandler* handler) {
    while (handler->isConnected()) {
        std::string frame;
        
        if (!handler->getFrameAscii(frame, '\0')) {
            break;
        }
        
        if (frame.substr(0, 9) == "CONNECTED") {
            std::cout << "Login successful" << std::endl;
            handler->getProtocol().setLoggedIn(true);
            
        } else if (frame.substr(0, 5) == "ERROR") {
            std::cerr << "Error from server:\n" << frame << std::endl;
            handler->close();
            break;
            
        } else if (frame.substr(0, 7) == "RECEIPT") {
            size_t pos = frame.find("receipt-id:");
            if (pos != std::string::npos) {
                std::string receiptId = frame.substr(pos + 11);
                receiptId = receiptId.substr(0, receiptId.find('\n'));
            }
            
        } else if (frame.substr(0, 7) == "MESSAGE") {
            handler->getProtocol().handleMessageFrame(frame);
        }
    }
}

std::vector<std::string> split(const std::string& str, char delimiter) {
    std::vector<std::string> tokens;
    std::string token;
    std::istringstream tokenStream(str);
    
    while (std::getline(tokenStream, token, delimiter)) {
        tokens.push_back(token);
    }
    
    return tokens;
}

int main(int argc, char* argv[]) {
    ConnectionHandler* handler = nullptr;
    std::thread* readerThread = nullptr;
    
    std::string line;
    
    while (std::getline(std::cin, line)) {
        std::vector<std::string> tokens = split(line, ' ');
        
        if (tokens.empty()) continue;
        
        std::string command = tokens[0];
        
        if (command == "login") {
            cout << "DEBUG Attempting to log in..." << std::endl;
            if (tokens.size() != 4) {
                std::cerr << "Usage: login host:port username password" << std::endl;
                continue;
            }
            
            if (handler != nullptr && handler->isConnected()) {
                std::cerr << "The client is already logged in, log out before trying again" << std::endl;
                continue;
            }
            
            std::string hostPort = tokens[1];
            size_t colonPos = hostPort.find(':');
            
            if (colonPos == std::string::npos) {
                std::cerr << "Invalid host:port format" << std::endl;
                continue;
            }
            
            std::string host = hostPort.substr(0, colonPos);
            short port = std::stoi(hostPort.substr(colonPos + 1));
            
            std::string username = tokens[2];
            std::string password = tokens[3];
            
            handler = new ConnectionHandler(host, port);
            
            if (!handler->connect()) {
                delete handler;
                handler = nullptr;
                continue;
            }
            readerThread = new std::thread(socketReaderThread, handler);

            std::string connectFrame = handler->getProtocol().buildConnectFrame(host, username, password);
            handler->sendFrameAscii(connectFrame, '\0');            
        }
        else if (command == "join") {
            if (tokens.size() != 2) {
                std::cerr << "Usage: join game_name" << std::endl;
                continue;
            }
            
            if (handler == nullptr || !handler->isConnected()) {
                std::cerr << "Not connected to server" << std::endl;
                continue;
            }
            
            std::string gameName = tokens[1];
            std::string topic = "/" + gameName;
            
            std::string subscribeFrame = handler->getProtocol().buildSubscribeFrame(topic);
            handler->sendFrameAscii(subscribeFrame, '\0');
            
            std::cout << "Joined channel " << gameName << std::endl;
        }
        
        else if (command == "exit") {
            if (tokens.size() != 2) {
                std::cerr << "Usage: exit game_name" << std::endl;
                continue;
            }
            
            if (handler == nullptr || !handler->isConnected()) {
                std::cerr << "Not connected to server" << std::endl;
                continue;
            }
            
            std::string gameName = tokens[1];
            
            std::string topic = "/" + gameName;
            std::string subId = handler->getProtocol().getSubscriptionIdByTopic(topic);
            if (subId == "") {
                std::cerr << "Error: You are not subscribed to " << gameName << std::endl;
                continue;
            }
            std::string unsubscribeFrame = handler->getProtocol().buildUnsubscribeFrame(subId);
            handler->sendFrameAscii(unsubscribeFrame, '\0');
            
            std::cout << "Exited channel " << gameName << std::endl;
        }
        
        else if (command == "report") {
            if (tokens.size() != 2) {
                std::cerr << "Usage: report filename" << std::endl;
                continue;
            }
            
            if (handler == nullptr || !handler->isConnected()) {
                std::cerr << "Not connected to server" << std::endl;
                continue;
            }
            
            std::string filename = tokens[1];
            
            names_and_events nae = parseEventsFile(filename);
            
            std::string gameName = nae.team_a_name + "_" + nae.team_b_name;
            std::string topic = "/" + gameName;
            
            for (const Event& event : nae.events) {
                std::string sendFrame = handler->getProtocol().buildSendFrame(
                    topic, event, handler->getProtocol().getCurrentUsername()
                );
                handler->sendFrameAscii(sendFrame, '\0');
                
                handler->getProtocol().saveGameEvent(handler->getProtocol().getCurrentUsername(), gameName, event);
            }
        }
        else if (command == "summary") {
            if (tokens.size() != 4) {
                std::cerr << "Usage: summary game_name user outputfile" << std::endl;
                continue;
            }
            
            std::string gameName = tokens[1];
            std::string user = tokens[2];
            std::string outputFile = tokens[3];
            
            handler->getProtocol().generateSummary(gameName, user, outputFile);
        }
        else if (command == "logout") {
            if (handler == nullptr || !handler->isConnected()) {
                std::cerr << "Not connected to server" << std::endl;
                continue;
            }
            
            std::string disconnectFrame = handler->getProtocol().buildDisconnectFrame();
            handler->sendFrameAscii(disconnectFrame, '\0');
            
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
            
            handler->close();
            
            if (readerThread != nullptr) {
                readerThread->join();
                delete readerThread;
                readerThread = nullptr;
            }
            
            delete handler;
            handler = nullptr;
            
            std::cout << "Logged out" << std::endl;
        }
        else {
            std::cerr << "Unknown command: " << command << std::endl;
        }
    }
    
    if (handler != nullptr) {
        handler->close();
        if (readerThread != nullptr) {
            readerThread->join();
            delete readerThread;
        }
        delete handler;
    }
    
    return 0;
}

---File: ./client/src/StompProtocol.cpp---
#include "StompProtocol.h"
#include <sstream>
#include <fstream>
#include <iostream>
#include <algorithm>

using namespace std;

StompProtocol::StompProtocol() 
    : username(""), password(""), receiptIdCounter(0), 
      subscriptionIdCounter(0), loggedIn(false) {}

string StompProtocol::generateReceiptId() {
    lock_guard<mutex> lock(mtx);
    return to_string(++receiptIdCounter);
}

string StompProtocol::generateSubscriptionId() {
    lock_guard<mutex> lock(mtx);
    return to_string(++subscriptionIdCounter);
}

string StompProtocol::buildConnectFrame(const string& host, 
                                        const string& user, 
                                        const string& pass) {
    username = user;
    password = pass;
    
    string frame = "";
    frame.append("CONNECT\n");
    frame.append("accept-version:1.2\n");
    frame.append("host:stomp.cs.bgu.ac.il\n");
    frame.append("login:").append(user).append("\n");
    frame.append("passcode:").append(pass).append("\n");
    frame.append("\n");
    
    return frame;
}

string StompProtocol::buildSubscribeFrame(const string& topic) {
    string subId = generateSubscriptionId();
    string receiptId = generateReceiptId();
    
    {
        lock_guard<mutex> lock(mtx);
        subscriptions[subId] = topic;
    }
    
    string frame = "";
    frame.append("SUBSCRIBE\n");
    frame.append("destination:").append(topic).append("\n");
    frame.append("id:").append(subId).append("\n");
    frame.append("receipt:").append(receiptId).append("\n");
    frame.append("\n");
    
    return frame;
}

string StompProtocol::buildUnsubscribeFrame(const string& subId) {
    string receiptId = generateReceiptId();
    
    string frame = "";
    frame.append("UNSUBSCRIBE\n");
    frame.append("id:").append(subId).append("\n");
    frame.append("receipt:").append(receiptId).append("\n");
    frame.append("\n");
    
    {
        lock_guard<mutex> lock(mtx);
        subscriptions.erase(subId);
    }
    
    return frame;
}

string StompProtocol::buildSendFrame(const string& topic, 
                                     const Event& event, 
                                     const string& user) {
    string frame = "";
    
    frame.append("SEND\n");
    frame.append("destination:").append(topic).append("\n");
    frame.append("user: ").append(user).append("\n");
    frame.append("team a: ").append(event.get_team_a_name()).append("\n");
    frame.append("team b: ").append(event.get_team_b_name()).append("\n");
    frame.append("event name: ").append(event.get_name()).append("\n");
    frame.append("time: ").append(to_string(event.get_time())).append("\n");
    
    frame.append("\n");
    
    frame.append("general game updates:\n");
    for (auto& kv : event.get_game_updates()) {
        frame.append(kv.first).append(": ").append(kv.second).append("\n");
    }
    
    frame.append("team a updates:\n");
    for (auto& kv : event.get_team_a_updates()) {
        frame.append(kv.first).append(": ").append(kv.second).append("\n");
    }
    
    frame.append("team b updates:\n");
    for (auto& kv : event.get_team_b_updates()) {
        frame.append(kv.first).append(": ").append(kv.second).append("\n");
    }
    
    // BODY - description
    frame.append("description:\n").append(event.get_discription()).append("\n");
    
    return frame;
}

string StompProtocol::buildDisconnectFrame() {
    string receiptId = generateReceiptId();
    
    string frame = "";
    frame.append("DISCONNECT\n");
    frame.append("receipt:").append(receiptId).append("\n");
    frame.append("\n");
    
    return frame;
}

void StompProtocol::handleMessageFrame(const string& frame) {
    istringstream iss(frame);
    string line;
    map<string, string> headers;
    
    getline(iss, line);
    
    while (getline(iss, line) && !line.empty() && line != "\r") {
        size_t colonPos = line.find(':');
        if (colonPos != string::npos) {
            string key = line.substr(0, colonPos);
            string value = line.substr(colonPos + 1);
            
            if (!value.empty() && value[0] == ' ') {
                value = value.substr(1);
            }
            
            if (!value.empty() && value.back() == '\r') {
                value.pop_back();
            }
            
            headers[key] = value;
        }
    }
    
    string bodyStream = "";
    while (getline(iss, line)) {
        bodyStream.append(line).append("\n");
    }
    
    std::string user = headers["user"];
    std::string teamA = headers["team a"];
    std::string teamB = headers["team b"];
    std::string gameName = teamA + "_" + teamB;
    std::string eventName = headers["event name"];
    std::string timeStr = headers["time"];
    int time = std::stoi(timeStr);
    
    // Parsing BODY to extract game updates
    std::map<std::string, std::string> gameUpdates;
    std::map<std::string, std::string> teamAUpdates;
    std::map<std::string, std::string> teamBUpdates;
    std::string description = "";
    
    std::istringstream bodyStream2(bodyStream);
    std::string section = "";
    
    while (std::getline(bodyStream2, line)) {
        if (line.find("general game updates:") == 0) {
            section = "general";
        } else if (line.find("team a updates:") == 0) {
            section = "team_a";
        } else if (line.find("team b updates:") == 0) {
            section = "team_b";
        } else if (line.find("description:") == 0) {
            section = "description";

            std::string descLine;
            while (std::getline(bodyStream2, descLine)) {
                description.append(descLine).append("\n");
            }
            if (!description.empty() && description.back() == '\n') {
                description.pop_back();
            }
            break;
        } else if (!line.empty() && line.find(':') != std::string::npos) {
            size_t colonPos = line.find(':');
            std::string key = line.substr(0, colonPos);
            std::string value = line.substr(colonPos + 1);
            
            if (!value.empty() && value[0] == ' ') {
                value = value.substr(1);
            }
            if (!value.empty() && value.back() == '\r') {
                value.pop_back();
            }
            
            if (section == "general") {
                gameUpdates[key] = value;
            } else if (section == "team_a") {
                teamAUpdates[key] = value;
            } else if (section == "team_b") {
                teamBUpdates[key] = value;
            }
        }
    }
    
    // Creat Event and save
    Event event(teamA, teamB, eventName, time, 
                gameUpdates, teamAUpdates, teamBUpdates, description);
    
    saveGameEvent(user, gameName, event);
    
    // Print to console
    std::cout << user << " - " << gameName << ":\n";
    std::cout << eventName << "\n\n";
    std::cout << description << "\n" << std::endl;
}

void StompProtocol::saveGameEvent(const string& user, 
                                  const string& gameName, 
                                  const Event& event) {
    lock_guard<mutex> lock(mtx);
    
    if (gameReports[user].find(gameName) == gameReports[user].end()) {
        gameReports[user][gameName] = names_and_events();
        
        // Extract team names from gameName (format: "USA_Canada")
        size_t underscorePos = gameName.find('_');
        if (underscorePos != string::npos) {
            gameReports[user][gameName].team_a_name = gameName.substr(0, underscorePos);
            gameReports[user][gameName].team_b_name = gameName.substr(underscorePos + 1);
        }
    }
    
    // Add event
    gameReports[user][gameName].events.push_back(event);
}

void StompProtocol::generateSummary(const string& gameName, 
                                    const string& user, 
                                    const string& outputFile) {
    ofstream out(outputFile);
    
    if (!out.is_open()) {
        cerr << "Cannot open file: " << outputFile << endl;
        return;
    }
    
    // Find reports for this game and user
    auto userIt = gameReports.find(user);
    if (userIt == gameReports.end()) {
        out << "No reports found for user " << user << endl;
        out.close();
        cout << "Summary written to " << outputFile << endl;
        return;
    }
    
    auto gameIt = userIt->second.find(gameName);
    if (gameIt == userIt->second.end()) {
        out << "No reports found for game " << gameName << endl;
        out.close();
        cout << "Summary written to " << outputFile << endl;
        return;
    }
    
    names_and_events& nae = gameIt->second;
    
    // Header (assignment format)
    out << nae.team_a_name << " vs " << nae.team_b_name << "\n";
    out << "Game stats:\n";
    out << "General stats:\n";
    
    // Aggregate general stats from all events
    map<string, string> generalStats;
    for (const Event& event : nae.events) {
        for (auto& kv : event.get_game_updates()) {
            generalStats[kv.first] = kv.second;  // Last value wins
        }
    }
    
    // Print general stats (lexicographic order)
    for (auto& kv : generalStats) {
        out << kv.first << ": " << kv.second << "\n";
    }
    
    // Team A stats
    out << nae.team_a_name << " stats:\n";
    map<string, string> teamAStats;
    for (const Event& event : nae.events) {
        for (auto& kv : event.get_team_a_updates()) {
            teamAStats[kv.first] = kv.second;
        }
    }
    for (auto& kv : teamAStats) {
        out << kv.first << ": " << kv.second << "\n";
    }
    
    // Team B stats
    out << nae.team_b_name << " stats:\n";
    map<string, string> teamBStats;
    for (const Event& event : nae.events) {
        for (auto& kv : event.get_team_b_updates()) {
            teamBStats[kv.first] = kv.second;
        }
    }
    for (auto& kv : teamBStats) {
        out << kv.first << ": " << kv.second << "\n";
    }
    
    // Game event reports
    out << "\nGame event reports:\n";
    
    // Sort events by time (handling halftime)
    vector<Event> sortedEvents = nae.events;
    sort(sortedEvents.begin(), sortedEvents.end(), 
         [](const Event& a, const Event& b) {
             // If one is "halftime", handle specially
             bool aBeforeHalftime = true;
             bool bBeforeHalftime = true;
             
             // Check if events have "before halftime" in game_updates
             auto aUpdates = a.get_game_updates();
             auto bUpdates = b.get_game_updates();
             
             if (aUpdates.find("before halftime") != aUpdates.end()) {
                 aBeforeHalftime = (aUpdates.at("before halftime") == "true");
             }
             
             if (bUpdates.find("before halftime") != bUpdates.end()) {
                 bBeforeHalftime = (bUpdates.at("before halftime") == "true");
             }
             
             // If one is before halftime and the other is after
             if (aBeforeHalftime && !bBeforeHalftime) return true;
             if (!aBeforeHalftime && bBeforeHalftime) return false;
             
             // Otherwise sort by time
             return a.get_time() < b.get_time();
         });
    
    // Print events
    for (const Event& event : sortedEvents) {
        out << event.get_time() << " - " << event.get_name() << ":\n";
        out << event.get_discription() << "\n\n";
    }
    
    out.close();
    cout << "Summary written to " << outputFile << endl;
}
string StompProtocol::getSubscriptionIdByTopic(const string& topic) {
    lock_guard<mutex> lock(mtx);
    
    for (auto const& [id, subTopic] : subscriptions) {
        if (subTopic == topic) {
            return id; 
        }
    }
    return ""; 
}

---File: ./server/src/main/java/bgu/spl/net/api/MessageEncoderDecoder.java---
package bgu.spl.net.api;

public interface MessageEncoderDecoder<T> {

    /**
     * add the next byte to the decoding process
     *
     * @param nextByte the next byte to consider for the currently decoded
     * message
     * @return a message if this byte completes one or null if it doesnt.
     */
    T decodeNextByte(byte nextByte);

    /**
     * encodes the given message to bytes array
     *
     * @param message the message to encode
     * @return the encoded bytes
     */
    byte[] encode(T message);

}


---File: ./server/src/main/java/bgu/spl/net/api/MessagingProtocol.java---
package bgu.spl.net.api;

public interface MessagingProtocol<T> {
 
    /**
     * process the given message 
     * @param msg the received message
     * @return the response to send or null if no response is expected by the client
     */
    T process(T msg);
 
    /**
     * @return true if the connection should be terminated
     */
    boolean shouldTerminate();
 
}

---File: ./server/src/main/java/bgu/spl/net/api/StompMessagingProtocol.java---
package bgu.spl.net.api;

import bgu.spl.net.srv.Connections;

public interface StompMessagingProtocol<T> extends MessagingProtocol<T> {
	/**
	 * Used to initiate the current client protocol with it's personal connection ID and the connections implementation
	**/
    void start(int connectionId, Connections<T> connections);
    
    //void process(T message);
	
	/**
     * @return true if the connection should be terminated
     */
    boolean shouldTerminate();
}


---File: ./server/src/main/java/bgu/spl/net/impl/data/Database.java---
package bgu.spl.net.impl.data;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.concurrent.ConcurrentHashMap;

public class Database {
	private final ConcurrentHashMap<String, User> userMap;
	private final ConcurrentHashMap<Integer, User> connectionsIdMap;
	private final String sqlHost;
	private final int sqlPort;

	private Database() {
		userMap = new ConcurrentHashMap<>();
		connectionsIdMap = new ConcurrentHashMap<>();
		// SQL server connection details
		this.sqlHost = "127.0.0.1";
		this.sqlPort = 7778;
	}

	public static Database getInstance() {
		return Instance.instance;
	}

	/**
	 * Execute SQL query and return result
	 * @param sql SQL query string
	 * @return Result string from SQL server
	 */
	private String executeSQL(String sql) {
		try (Socket socket = new Socket(sqlHost, sqlPort);
			 PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
			 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {
			
			// Send SQL with null terminator
			out.print(sql + '\0');
			out.flush();
			
			// Read response until null terminator
			StringBuilder response = new StringBuilder();
			int ch;
			while ((ch = in.read()) != -1 && ch != '\0') {
				response.append((char) ch);
			}
			
			return response.toString();
			
		} catch (Exception e) {
			System.err.println("SQL Error: " + e.getMessage());
			return "ERROR:" + e.getMessage();
		}
	}

	/**
	 * Escape SQL special characters to prevent SQL injection
	 */
	private String escapeSql(String str) {
		if (str == null) return "";
		return str.replace("'", "''");
	}

	public void addUser(User user) {
		userMap.putIfAbsent(user.name, user);
		connectionsIdMap.putIfAbsent(user.getConnectionId(), user);
	}

	public LoginStatus login(int connectionId, String username, String password) {
		if (connectionsIdMap.containsKey(connectionId)) {
			return LoginStatus.CLIENT_ALREADY_CONNECTED;
		}
		if (addNewUserCase(connectionId, username, password)) {
			// Log new user registration in SQL
			String sql = String.format(
				"INSERT INTO users (username, password, registration_date) VALUES ('%s', '%s', datetime('now'))",
				escapeSql(username), escapeSql(password)
			);
			executeSQL(sql);
			
			// Log login
			logLogin(username);
			return LoginStatus.ADDED_NEW_USER;
		} else {
			LoginStatus status = userExistsCase(connectionId, username, password);
			if (status == LoginStatus.LOGGED_IN_SUCCESSFULLY) {
				// Log successful login in SQL
				logLogin(username);
			}
			return status;
		}
	}

	private void logLogin(String username) {
		String sql = String.format(
			"INSERT INTO login_history (username, login_time) VALUES ('%s', datetime('now'))",
			escapeSql(username)
		);
		executeSQL(sql);
	}

	private LoginStatus userExistsCase(int connectionId, String username, String password) {
		User user = userMap.get(username);
		synchronized (user) {
			if (user.isLoggedIn()) {
				return LoginStatus.ALREADY_LOGGED_IN;
			} else if (!user.password.equals(password)) {
				return LoginStatus.WRONG_PASSWORD;
			} else {
				user.login();
				user.setConnectionId(connectionId);
				connectionsIdMap.put(connectionId, user);
				return LoginStatus.LOGGED_IN_SUCCESSFULLY;
			}
		}
	}

	private boolean addNewUserCase(int connectionId, String username, String password) {
		if (!userMap.containsKey(username)) {
			synchronized (userMap) {
				if (!userMap.containsKey(username)) {
					User user = new User(connectionId, username, password);
					user.login();
					addUser(user);
					return true;
				}
			}
		}
		return false;
	}

	public void logout(int connectionsId) {
		User user = connectionsIdMap.get(connectionsId);
		if (user != null) {
			// Log logout in SQL
			String sql = String.format(
				"UPDATE login_history SET logout_time=datetime('now') " +
				"WHERE username='%s' AND logout_time IS NULL " +
				"ORDER BY login_time DESC LIMIT 1",
				escapeSql(user.name)
			);
			executeSQL(sql);
			
			user.logout();
			connectionsIdMap.remove(connectionsId);
		}
	}

	/**
	 * Track file upload in SQL database
	 * @param username User who uploaded the file
	 * @param filename Name of the file
	 * @param gameChannel Game channel the file was reported to
	 */
	public void trackFileUpload(String username, String filename, String gameChannel) {
		String sql = String.format(
			"INSERT INTO file_tracking (username, filename, upload_time, game_channel) " +
			"VALUES ('%s', '%s', datetime('now'), '%s')",
			escapeSql(username), escapeSql(filename), escapeSql(gameChannel)
		);
		executeSQL(sql);
	}

	/**
	 * Generate and print server report using SQL queries
	 */
	public void printReport() {
		System.out.println(repeat("=", 80));
		System.out.println("SERVER REPORT - Generated at: " + java.time.LocalDateTime.now());
		System.out.println(repeat("=", 80));
		
		// List all users
		System.out.println("\n1. REGISTERED USERS:");
		System.out.println(repeat("-", 80));
		String usersSQL = "SELECT username, registration_date FROM users ORDER BY registration_date";
		String usersResult = executeSQL(usersSQL);
		if (usersResult.startsWith("SUCCESS")) {
			String[] parts = usersResult.split("\\|");
			if (parts.length > 1) {
				for (int i = 1; i < parts.length; i++) {
					System.out.println("   " + parts[i]);
				}
			} else {
				System.out.println("   No users registered");
			}
		}
		
		// Login history for each user
		System.out.println("\n2. LOGIN HISTORY:");
		System.out.println(repeat("-", 80));
		String loginSQL = "SELECT username, login_time, logout_time FROM login_history ORDER BY username, login_time DESC";
		String loginResult = executeSQL(loginSQL);
		if (loginResult.startsWith("SUCCESS")) {
			String[] parts = loginResult.split("\\|");
			if (parts.length > 1) {
				String currentUser = "";
				for (int i = 1; i < parts.length; i++) {
					String[] fields = parts[i].replace("(", "").replace(")", "").replace("'", "").split(", ");
					if (fields.length >= 3) {
						if (!fields[0].equals(currentUser)) {
							currentUser = fields[0];
							System.out.println("\n   User: " + currentUser);
						}
						System.out.println("      Login:  " + fields[1]);
						System.out.println("      Logout: " + (fields[2].equals("None") ? "Still logged in" : fields[2]));
					}
				}
			} else {
				System.out.println("   No login history");
			}
		}
		
		// File uploads for each user
		System.out.println("\n3. FILE UPLOADS:");
		System.out.println(repeat("-", 80));
		String filesSQL = "SELECT username, filename, upload_time, game_channel FROM file_tracking ORDER BY username, upload_time DESC";
		String filesResult = executeSQL(filesSQL);
		if (filesResult.startsWith("SUCCESS")) {
			String[] parts = filesResult.split("\\|");
			if (parts.length > 1) {
				String currentUser = "";
				for (int i = 1; i < parts.length; i++) {
					String[] fields = parts[i].replace("(", "").replace(")", "").replace("'", "").split(", ");
					if (fields.length >= 4) {
						if (!fields[0].equals(currentUser)) {
							currentUser = fields[0];
							System.out.println("\n   User: " + currentUser);
						}
						System.out.println("      File: " + fields[1]);
						System.out.println("      Time: " + fields[2]);
						System.out.println("      Game: " + fields[3]);
						System.out.println();
					}
				}
			} else {
				System.out.println("   No files uploaded");
			}
		}
		
	System.out.println(repeat("=", 80));
}

private String repeat(String str, int times) {
	StringBuilder sb = new StringBuilder();
	for (int i = 0; i < times; i++) {
		sb.append(str);
	}
	return sb.toString();
}

private static class Instance {
	static Database instance = new Database();
}}

---File: ./server/src/main/java/bgu/spl/net/impl/data/LoginStatus.java---
package bgu.spl.net.impl.data;

public enum LoginStatus {
	CLIENT_ALREADY_CONNECTED, ADDED_NEW_USER, ALREADY_LOGGED_IN, LOGGED_IN_SUCCESSFULLY, WRONG_PASSWORD
}


---File: ./server/src/main/java/bgu/spl/net/impl/data/User.java---
package bgu.spl.net.impl.data;

public class User {
	public final String name;
	public final String password;
	private int connectionId;
	private boolean isLoggedIn = false;

	public User(int connectionId, String name, String password) {
		this.connectionId = connectionId;
		this.name = name;
		this.password = password;
	}

	public boolean isLoggedIn() {
		return isLoggedIn;
	}

	public void login() {
		isLoggedIn = true;
	}

	public void logout() {
		isLoggedIn = false;
	}

	public int getConnectionId() {
		return connectionId;
	}

	public void setConnectionId(int connectionId) {
		this.connectionId = connectionId;
	}


}


---File: ./server/src/main/java/bgu/spl/net/impl/echo/EchoClient.java---
package bgu.spl.net.impl.echo;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;

public class EchoClient {

    public static void main(String[] args) throws IOException {

        if (args.length == 0) {
            args = new String[]{"localhost", "hello"};
        }

        if (args.length < 2) {
            System.out.println("you must supply two arguments: host, message");
            System.exit(1);
        }

        //BufferedReader and BufferedWriter automatically using UTF-8 encoding
        try (Socket sock = new Socket(args[0], 7777);
                BufferedReader in = new BufferedReader(new InputStreamReader(sock.getInputStream()));
                BufferedWriter out = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()))) {

            System.out.println("sending message to server");
            out.write(args[1]);
            out.newLine();
            out.flush();

            System.out.println("awaiting response");
            String line = in.readLine();
            System.out.println("message from server: " + line);
        }
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/echo/EchoProtocol.java---
package bgu.spl.net.impl.echo;

import bgu.spl.net.api.MessagingProtocol;
import java.time.LocalDateTime;

public class EchoProtocol implements MessagingProtocol<String> {

    private boolean shouldTerminate = false;

    @Override
    public String process(String msg) {
        shouldTerminate = "bye".equals(msg);
        System.out.println("[" + LocalDateTime.now() + "]: " + msg);
        return createEcho(msg);
    }

    private String createEcho(String message) {
        String echoPart = message.substring(Math.max(message.length() - 2, 0), message.length());
        return message + " .. " + echoPart + " .. " + echoPart + " ..";
    }

    @Override
    public boolean shouldTerminate() {
        return shouldTerminate;
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/echo/EchoServer.java---
package bgu.spl.net.impl.echo;

import bgu.spl.net.srv.Server;

public class EchoServer {

    public static void main(String[] args) {

        // you can use any server... 
        Server.threadPerClient(
                7777, //port
                () -> new EchoProtocol(), //protocol factory
                LineMessageEncoderDecoder::new //message encoder decoder factory
        ).serve();

        // Server.reactor(
        //         Runtime.getRuntime().availableProcessors(),
        //         7777, //port
        //         () -> new EchoProtocol<>(), //protocol factory
        //         LineMessageEncoderDecoder::new //message encoder decoder factory
        // ).serve();
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/echo/LineMessageEncoderDecoder.java---
package bgu.spl.net.impl.echo;

import bgu.spl.net.api.MessageEncoderDecoder;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;

public class LineMessageEncoderDecoder implements MessageEncoderDecoder<String> {

    private byte[] bytes = new byte[1 << 10]; //start with 1k
    private int len = 0;

    @Override
    public String decodeNextByte(byte nextByte) {
        //notice that the top 128 ascii characters have the same representation as their utf-8 counterparts
        //this allow us to do the following comparison
        if (nextByte == '\n') {
            return popString();
        }

        pushByte(nextByte);
        return null; //not a line yet
    }

    @Override
    public byte[] encode(String message) {
        return (message + "\n").getBytes(); //uses utf8 by default
    }

    private void pushByte(byte nextByte) {
        if (len >= bytes.length) {
            bytes = Arrays.copyOf(bytes, len * 2);
        }

        bytes[len++] = nextByte;
    }

    private String popString() {
        //notice that we explicitly requesting that the string will be decoded from UTF-8
        //this is not actually required as it is the default encoding in java.
        String result = new String(bytes, 0, len, StandardCharsets.UTF_8);
        len = 0;
        return result;
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/newsfeed/FetchNewsCommand.java---
package bgu.spl.net.impl.newsfeed;

import bgu.spl.net.impl.rci.Command;
import java.io.Serializable;

public class FetchNewsCommand implements Command<NewsFeed> {

    private String channel;

    public FetchNewsCommand(String channel) {
        this.channel = channel;
    }

    @Override
    public Serializable execute(NewsFeed feed) {
        return feed.fetch(channel);
    }

}


---File: ./server/src/main/java/bgu/spl/net/impl/newsfeed/NewsFeed.java---
package bgu.spl.net.impl.newsfeed;

import java.util.ArrayList;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

public class NewsFeed {

    private ConcurrentHashMap<String, ConcurrentLinkedQueue<String>> channels = new ConcurrentHashMap<>();

    public ArrayList<String> fetch(String channel) {
        ConcurrentLinkedQueue<String> queue = channels.get(channel);
        if (queue == null) {
            return new ArrayList<>(0); //empty
        } else {
            return new ArrayList<>(queue); //copy of the queue, arraylist is serializable
        }
    }

    public void publish(String channel, String news) {
        ConcurrentLinkedQueue<String> queue = channels.computeIfAbsent(channel, k -> new ConcurrentLinkedQueue<>());
        queue.add(news);
    }

    public void clear() {
        channels.clear();
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/newsfeed/NewsFeedClientMain.java---
package bgu.spl.net.impl.newsfeed;

import bgu.spl.net.impl.rci.RCIClient;

public class NewsFeedClientMain {

    public static void main(String[] args) throws Exception {
        if (args.length == 0) {
            args = new String[]{"127.0.0.1"};
        }

//        System.out.println("running clients");
        runFirstClient(args[0]);
        runSecondClient(args[0]);
        runThirdClient(args[0]);
    }

    private static void runFirstClient(String host) throws Exception {
        try (RCIClient c = new RCIClient(host, 7777)) {
            c.send(new PublishNewsCommand(
                    "jobs",
                    "System Programmer, knowledge in C++, Java and Python required. call 0x134693F"));

            c.receive(); //ok

            c.send(new PublishNewsCommand(
                    "headlines",
                    "new SPL assignment is out soon!!"));

            c.receive(); //ok

            c.send(new PublishNewsCommand(
                    "headlines",
                    "THE CAKE IS A LIE!"));

            c.receive(); //ok
        }

    }

    private static void runSecondClient(String host) throws Exception {
        try (RCIClient c = new RCIClient(host, 7777)) {
            c.send(new FetchNewsCommand("jobs"));
            System.out.println("second client received: " + c.receive());
        }
    }

    private static void runThirdClient(String host) throws Exception {
        try (RCIClient c = new RCIClient(host, 7777)) {
            c.send(new FetchNewsCommand("headlines"));
            System.out.println("third client received: " + c.receive());
        }
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/newsfeed/NewsFeedServerMain.java---
package bgu.spl.net.impl.newsfeed;

import bgu.spl.net.impl.rci.ObjectEncoderDecoder;
import bgu.spl.net.impl.rci.RemoteCommandInvocationProtocol;
import bgu.spl.net.srv.Server;

public class NewsFeedServerMain {

    public static void main(String[] args) {
        NewsFeed feed = new NewsFeed(); //one shared object

        // you can use any server... 
        Server.threadPerClient(
                7777, //port
                () -> new RemoteCommandInvocationProtocol<>(feed), //protocol factory
                ObjectEncoderDecoder::new //message encoder decoder factory
        ).serve();

        // Server.reactor(
        //         Runtime.getRuntime().availableProcessors(),
        //         7777, //port
        //         () ->  new RemoteCommandInvocationProtocol<>(feed), //protocol factory
        //         ObjectEncoderDecoder::new //message encoder decoder factory
        // ).serve();
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/newsfeed/PublishNewsCommand.java---
package bgu.spl.net.impl.newsfeed;

import bgu.spl.net.impl.rci.Command;
import java.io.Serializable;

public class PublishNewsCommand implements Command<NewsFeed> {
 
    private String channel;
    private String news;
 
    public PublishNewsCommand(String channel, String news) {
        this.channel = channel;
        this.news = news;
    }
 
    @Override
    public Serializable execute(NewsFeed feed) {
        feed.publish(channel, news);
        return "OK";
    }
 
}

---File: ./server/src/main/java/bgu/spl/net/impl/rci/Command.java---
package bgu.spl.net.impl.rci;

import java.io.Serializable;

public interface Command<T> extends Serializable {

    Serializable execute(T arg);
}


---File: ./server/src/main/java/bgu/spl/net/impl/rci/ObjectEncoderDecoder.java---
package bgu.spl.net.impl.rci;

import bgu.spl.net.api.MessageEncoderDecoder;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.nio.ByteBuffer;

public class ObjectEncoderDecoder implements MessageEncoderDecoder<Serializable> {

    private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);
    private byte[] objectBytes = null;
    private int objectBytesIndex = 0;

    @Override
    public Serializable decodeNextByte(byte nextByte) {
        if (objectBytes == null) { //indicates that we are still reading the length
            lengthBuffer.put(nextByte);
            if (!lengthBuffer.hasRemaining()) { //we read 4 bytes and therefore can take the length
                lengthBuffer.flip();
                objectBytes = new byte[lengthBuffer.getInt()];
                objectBytesIndex = 0;
                lengthBuffer.clear();
            }
        } else {
            objectBytes[objectBytesIndex] = nextByte;
            if (++objectBytesIndex == objectBytes.length) {
                Serializable result = deserializeObject();
                objectBytes = null;
                return result;
            }
        }

        return null;
    }

    @Override
    public byte[] encode(Serializable message) {
        return serializeObject(message);
    }

    private Serializable deserializeObject() {
        try {
            ObjectInput in = new ObjectInputStream(new ByteArrayInputStream(objectBytes));
            return (Serializable) in.readObject();
        } catch (Exception ex) {
            throw new IllegalArgumentException("cannot desrialize object", ex);
        }

    }

    private byte[] serializeObject(Serializable message) {
        try {
            ByteArrayOutputStream bytes = new ByteArrayOutputStream();

            //placeholder for the object size
            for (int i = 0; i < 4; i++) {
                bytes.write(0);
            }

            ObjectOutput out = new ObjectOutputStream(bytes);
            out.writeObject(message);
            out.flush();
            byte[] result = bytes.toByteArray();

            //now write the object size
            ByteBuffer.wrap(result).putInt(result.length - 4);
            return result;

        } catch (Exception ex) {
            throw new IllegalArgumentException("cannot serialize object", ex);
        }
    }

}


---File: ./server/src/main/java/bgu/spl/net/impl/rci/RCIClient.java---
package bgu.spl.net.impl.rci;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.Closeable;
import java.io.IOException;
import java.io.Serializable;
import java.net.Socket;

public class RCIClient implements Closeable {

    private final ObjectEncoderDecoder encdec;
    private final Socket sock;
    private final BufferedInputStream in;
    private final BufferedOutputStream out;

    public RCIClient(String host, int port) throws IOException {
        sock = new Socket(host, port);
        encdec = new ObjectEncoderDecoder();
        in = new BufferedInputStream(sock.getInputStream());
        out = new BufferedOutputStream(sock.getOutputStream());
    }

    public void send(Command<?> cmd) throws IOException {
        out.write(encdec.encode(cmd));
        out.flush();
    }

    public Serializable receive() throws IOException {
        int read;
        while ((read = in.read()) >= 0) {
            Serializable msg = encdec.decodeNextByte((byte) read);
            if (msg != null) {
                return msg;
            }
        }

        throw new IOException("disconnected before complete reading message");
    }

    @Override
    public void close() throws IOException {
        out.close();
        in.close();
        sock.close();
    }

}


---File: ./server/src/main/java/bgu/spl/net/impl/rci/RemoteCommandInvocationProtocol.java---
package bgu.spl.net.impl.rci;

import bgu.spl.net.api.MessagingProtocol;
import java.io.Serializable;

public class RemoteCommandInvocationProtocol<T> implements MessagingProtocol<Serializable> {

    private T arg;

    public RemoteCommandInvocationProtocol(T arg) {
        this.arg = arg;
    }

    @Override
    public Serializable process(Serializable msg) {
        return ((Command) msg).execute(arg);
    }

    @Override
    public boolean shouldTerminate() {
        return false;
    }

}


---File: ./server/src/main/java/bgu/spl/net/impl/stomp/StompFrame.java---
package bgu.spl.net.impl.stomp;

import java.util.HashMap;
import java.util.Map;

public class StompFrame {
    private String command;
    private Map<String,String> headers = new HashMap<>();
    private String body;

    public StompFrame(String commands) {
        this.command = commands;
    }
    public StompFrame(StompFrame other) {
        this.command = other.command;
        this.headers = new HashMap<>(other.headers);
        this.body = other.body;
    }
    public String getCommand() {
        return command;
    }
    public void addHeader(String key, String value) {
        headers.put(key, value);
    }
    public String getHeader(String key) {
        return headers.get(key);
    }
    public void setBody(String body) {
        this.body = body;
    }
    public String getBody() {
        return this.body;
    }

    public static StompFrame fromString(String rawMessage) {
        StompFrame ret = null;
        int i = 0;

        if (rawMessage == null || rawMessage.length() == 0) {
            return null;
        }

        String[] lines = rawMessage.split("\n");

        // COMMAND
        ret = new StompFrame(lines[i].trim());
        i++;

        // HEADERS - until end of lines or an empty line
        for (i = 1; i < lines.length && !lines[i].isEmpty(); i++) {
            String[] parts = lines[i].split(":", 2);
            // Add new Header to frame
            if (parts.length == 2) {
                ret.addHeader(parts[0].trim(), parts[1].trim());
            }
        }

        // BODY - build body until end of message
        StringBuilder bodyBuilder = new StringBuilder();

        // if we got to an empty line
        if (i != lines.length) {
            i++; // continuing after empty line
            for (; i < lines.length; i++) {
                bodyBuilder.append(lines[i]);

                // add new line
                if (i < lines.length - 1) {
                    bodyBuilder.append("\n");
                }
            }
        }

        ret.setBody(bodyBuilder.toString());

        return ret;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();

        // 1. Command
        sb.append(command).append("\n");

        // 2. Headers
        for (Map.Entry<String, String> header : headers.entrySet()) {
            sb.append(header.getKey())
                    .append(":")
                    .append(header.getValue())
                    .append("\n");
        }

        // 3. Empty Line - SEPARATION
        sb.append("\n");

        // 4. Body
        if (body != null && !body.isEmpty()) {
            sb.append(body);
        }

        return sb.toString();
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/stomp/StompMessageEncoderDecoder.java---
package bgu.spl.net.impl.stomp;

import bgu.spl.net.api.MessageEncoderDecoder;

public class StompMessageEncoderDecoder implements MessageEncoderDecoder<StompFrame> {
    private byte[] bytes = new byte[1024];
    private int len = 0;
    private static final int MAX_MESSAGE_SIZE = 1 << 20;
    @Override
    public StompFrame decodeNextByte(byte nextByte) {
        if(nextByte == '\0'){
            return popMessage();
        }
        pushByte(nextByte);
        return null;
    }

    private void pushByte(byte nextByte) {
        if (len >= MAX_MESSAGE_SIZE) {
            throw new RuntimeException("Message size limit exceeded");
        }
        // if needed, resize the array
        if (len >= bytes.length) {
            //double the size of the array
            bytes = java.util.Arrays.copyOf(bytes, len * 2);
        }
        bytes[len++] = nextByte;   
    }
    // when we get here we have a full message
    private StompFrame popMessage() {
        String message = new String(bytes,0,len, java.nio.charset.StandardCharsets.UTF_8);
        len = 0;
        return StompFrame.fromString(message);
    }

    @Override
    public byte[] encode(StompFrame message) {
        StringBuilder strMessage = new StringBuilder(message.toString());
        strMessage.append('\0');
        return strMessage.toString().getBytes(java.nio.charset.StandardCharsets.UTF_8);
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/stomp/StompMessagingProtocolImpl.java---
package bgu.spl.net.impl.stomp;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import bgu.spl.net.impl.data.Database;
import bgu.spl.net.api.StompMessagingProtocol;
import bgu.spl.net.impl.data.LoginStatus;
import bgu.spl.net.srv.Connections;

public class StompMessagingProtocolImpl implements StompMessagingProtocol<StompFrame> {
    private int connectionId;
    private Connections<StompFrame> connections;
    private boolean shouldTerminate = false;
    private boolean isLoggedIn = false;
    private String currentUser = null;
    private Map<String, String> subscriptions = new ConcurrentHashMap<>();
    private static AtomicInteger messageIdCounter = new AtomicInteger(0);

    @Override
    public void start(int connectionId, Connections<StompFrame> connections) {
        this.connectionId = connectionId;
        this.connections = connections;
    }
    @Override
    public StompFrame process(StompFrame frame) {
        String command = frame.getCommand();
        // Check if user is logged in for commands other than CONNECT
        if(!isLoggedIn && !command.equals("CONNECT")) {
            sendError(frame, "User not logged in", "You must log in before sending other commands.");
        }
        else{
            switch (command) {
                case "CONNECT":
                    handleConnect(frame);
                    break;
                case "SEND":
                    handleSend(frame);
                    break;
                case "SUBSCRIBE":
                    handleSubscribe(frame);
                    break;
                case "UNSUBSCRIBE":
                    handleUnsubscribe(frame);
                    break;
                case "DISCONNECT":
                    handleDisconnect(frame);
                    break;
                default:
                    sendError(frame, "Unknown command", "The command '" + command + "' is not recognized.");
                    shouldTerminate = true;
                    break;
        }
    }
    return null;
}

    private void handleDisconnect(StompFrame frame) {
        if (!isLoggedIn) {
            sendError(frame, "Not logged in", "You must be logged in to disconnect.");
            return;
        }

        String receipt = frame.getHeader("receipt");
        if (receipt != null) {
            sendReceipt(receipt);
        }

        // Perform logout
        Database.getInstance().logout(connectionId);
        this.shouldTerminate = true;
    }
    private void handleUnsubscribe(StompFrame frame) {
        if (!isLoggedIn) {
            sendError(frame, "Not logged in", "You must be logged in to unsubscribe.");
            return;
        }

        String requestId = frame.getHeader("id");

        if (requestId == null || requestId.isEmpty()) {
            sendError(frame, "Malformed UNSUBSCRIBE", "Missing 'id' header.");
            return;
        }
        // Check if subscribed with the given id
        String destination = subscriptions.remove(requestId);
        if (destination == null) {
            sendError(frame, "Subscription not found", "No active subscription found with ID: " + requestId);
            return;
        }

        connections.unsubscribe(destination, connectionId, requestId);

        // Handle receipt if requested
        String receipt = frame.getHeader("receipt");
        if (receipt != null) {
            sendReceipt(receipt);
        }
    }
    private void handleSubscribe(StompFrame frame) {
        if (!isLoggedIn) {
            sendError(frame, "Not logged in", "You must be logged in to subscribe.");
            return;
        }

        String destination = frame.getHeader("destination");
        String requestId = frame.getHeader("id");

        if (destination == null || destination.isEmpty() || requestId == null || requestId.isEmpty()) {
            sendError(frame, "Malformed SUBSCRIBE", "Missing 'destination' or 'id' header.");            return;
        }

        // Check if already subscribed with the same id
        if (subscriptions.containsKey(requestId)) {
            sendError(frame, "Already subscribed", "You are already subscribed with id '" + requestId + "'.");
            return;
        }

        subscriptions.put(requestId, destination);
        
        connections.subscribe(destination, connectionId, requestId);

        // Handle receipt if requested
        String receipt = frame.getHeader("receipt");
        if (receipt != null) {
            sendReceipt(receipt);
        }
    }
    private void handleSend(StompFrame frame) {
        if (!isLoggedIn) {
            sendError(frame, "Not logged in", "You must be logged in to send messages.");
            return;
        }

        String destination = frame.getHeader("destination");
        if (destination == null || destination.isEmpty()) {
            sendError(frame, "Missing destination", "SEND frame must include a destination header.");
            return;
        }

        if (!subscriptions.containsValue(destination)) {
            sendError(frame, "Not subscribed", "You cannot send to '" + destination + "' without subscribing first.");
            return;
        }

        /*// Track file upload if 'file-name' header is present
        String filename = frame.getHeader("file-name"); 
        if (filename != null) {
            Database.getInstance().trackFileUpload(currentUser, filename, destination);
        }*/

        StompFrame messageFrame = new StompFrame("MESSAGE");
        messageFrame.addHeader("destination", destination);
        messageFrame.addHeader("message-id", String.valueOf(messageIdCounter.incrementAndGet()));
        // Copy the body and content (Game updates, user, team names, etc.)
        // We don't validate them, we just pass them through.
        messageFrame.setBody(frame.getBody());

        // Send the MESSAGE frame (not the SEND frame)
        connections.send(destination, messageFrame);

        // Handle receipt if requested
        String receipt = frame.getHeader("receipt");
        if (receipt != null) {
            sendReceipt(receipt);
        }
}
    private void handleConnect(StompFrame frame) {
        if(isLoggedIn) {
            sendError(frame, "Already logged in", "You are already logged in.");
            return;
        }
        String username = frame.getHeader("login");
        String passcode = frame.getHeader("passcode");
        String acceptVersion = frame.getHeader("accept-version");
        String host = frame.getHeader("host");

        if (username == null || passcode == null || host == null) {
            sendError(frame, "Missing credentials", "Login or passcode header is missing.");
            return;
        }
        
        LoginStatus status = Database.getInstance().login(connectionId, username, passcode);
        switch (status) {
            case LOGGED_IN_SUCCESSFULLY:
            case ADDED_NEW_USER:
                this.currentUser = username;
                sendConnectedFrame();
                break;
            case CLIENT_ALREADY_CONNECTED:
                sendError(frame, "Client already connected", "This client is already connected.");
                break;
            case ALREADY_LOGGED_IN:
                sendError(frame, "Already logged in", "This user is already logged in.");
                break;
            case WRONG_PASSWORD:
                sendError(frame, "Wrong password", "The passcode you entered is incorrect.");
                break;
            default:
                sendError(frame, "Login failed", "Login failed due to unknown reasons.");
                break;
        }
    }
    @Override
    public boolean shouldTerminate() {
        return shouldTerminate;
    }
    private void sendConnectedFrame() {
        this.isLoggedIn = true;
        StompFrame connectedFrame = new StompFrame("CONNECTED");
        connectedFrame.addHeader("version", "1.2");
        connections.send(connectionId, connectedFrame);
    }
/**
 * Sends a RECEIPT frame to acknowledge that a command with a receipt header was processed.
 * @param receiptId The receipt ID from the original frame's receipt header.
 */
private void sendReceipt(String receiptId) {
    StompFrame receiptFrame = new StompFrame("RECEIPT");
    receiptFrame.addHeader("receipt-id", receiptId);
    connections.send(connectionId, receiptFrame);
}

/**
 * Sends an ERROR frame in the specific format required by the assignment and closes the connection.
 * * @param faultyFrame The original frame that caused the error (used to extract receipt-id and print in body).
 * @param messageHeader A short description of the error (goes into the 'message' header).
 * @param detailedInfo A detailed explanation (goes into the body).
 */
private void sendError(StompFrame faultyFrame, String messageHeader, String detailedInfo) {
    StompFrame errorFrame = new StompFrame("ERROR");

    errorFrame.addHeader("message", messageHeader);

    if (faultyFrame != null) {
        String receipt = faultyFrame.getHeader("receipt");
        if (receipt != null) {
            errorFrame.addHeader("receipt-id", receipt);
        }
    }

    // Construct the body in the requested format
    StringBuilder body = new StringBuilder();
    body.append("The message:\n");
    body.append("-----\n");
    
    if (faultyFrame != null) {
        // Assuming your StompFrame.toString() returns the frame representation (Command + Headers + Body)
        body.append(faultyFrame.toString()); 
    } else {
        body.append("(No frame content available)");
    }
    
    body.append("\n-----\n");
    body.append(detailedInfo);
    errorFrame.setBody(body.toString());
    connections.send(connectionId, errorFrame);

    this.shouldTerminate = true;
    }
}

---File: ./server/src/main/java/bgu/spl/net/impl/stomp/StompServer.java---
package bgu.spl.net.impl.stomp;

import bgu.spl.net.srv.Server;

public class StompServer {

    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println("Usage: StompServer <port> <server-type>");
            System.out.println("server-type: tpc (Thread Per Client) or reactor");
            return;
        }

        int port = 0;
        try {
            port = Integer.parseInt(args[0]);
        } catch (NumberFormatException e) {
            System.out.println("Error: Port must be a number.");
            return;
        }

        String serverType = args[1];

        if (serverType.equals("tpc")) {
            System.err.println("DEBUG Starting Stomp Server in Thread Per Client mode");
            Server.threadPerClient(
                    port,
                    () -> new StompMessagingProtocolImpl(), // Protocol Factory 
                    () -> new StompMessageEncoderDecoder()         // Encoder Factory
            ).serve();

        } else if (serverType.equals("reactor")) {
            Server.reactor(
                    Runtime.getRuntime().availableProcessors(),
                    port,
                    () -> new StompMessagingProtocolImpl(), // Protocol Factory (Lambda)
                    () -> new StompMessageEncoderDecoder()         // Encoder Factory (Lambda)
            ).serve();

        } else {
            System.out.println("Unknown server type: " + serverType);
            System.out.println("Please use 'tpc' or 'reactor'.");
        }
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/stomp/StompTestClient.java---
import java.io.OutputStream;
import java.net.Socket;
import java.nio.charset.StandardCharsets;

public class StompTestClient {
    public static void main(String[] args) throws Exception {
        Socket socket = new Socket("localhost", 7777);
        OutputStream out = socket.getOutputStream();

        String frame =
                "CONNECT\n" +
                "accept-version :1.2\n" +
                "host:stomp.cs.bgu.ac.il\n" +
                "login:alice\n" +
                "passcode:123\n" +
                "\n";

        out.write(frame.getBytes(StandardCharsets.UTF_8));
        out.write(0); // STOMP null character
        out.flush();

        Thread.sleep(5000);
        socket.close();
    }
}


---File: ./server/src/main/java/bgu/spl/net/srv/ActorThreadPool.java---
package bgu.spl.net.srv;

import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ActorThreadPool {

    private final Map<Object, Queue<Runnable>> acts;
    private final ReadWriteLock actsRWLock;
    private final Set<Object> playingNow;
    private final ExecutorService threads;

    public ActorThreadPool(int threads) {
        this.threads = Executors.newFixedThreadPool(threads);
        acts = new WeakHashMap<>();
        playingNow = ConcurrentHashMap.newKeySet();
        actsRWLock = new ReentrantReadWriteLock();
    }

    public void submit(Object act, Runnable r) {
        synchronized (act) {
            if (!playingNow.contains(act)) {
                playingNow.add(act);
                execute(r, act);
            } else {
                pendingRunnablesOf(act).add(r);
            }
        }
    }

    public void shutdown() {
        threads.shutdownNow();
    }

    private Queue<Runnable> pendingRunnablesOf(Object act) {

        actsRWLock.readLock().lock();
        Queue<Runnable> pendingRunnables = acts.get(act);
        actsRWLock.readLock().unlock();

        if (pendingRunnables == null) {
            actsRWLock.writeLock().lock();
            acts.put(act, pendingRunnables = new LinkedList<>());
            actsRWLock.writeLock().unlock();
        }
        return pendingRunnables;
    }

    private void execute(Runnable r, Object act) {
        threads.execute(() -> {
            try {
                r.run();
            } finally {
                complete(act);
            }
        });
    }

    private void complete(Object act) {
        synchronized (act) {
            Queue<Runnable> pending = pendingRunnablesOf(act);
            if (pending.isEmpty()) {
                playingNow.remove(act);
            } else {
                execute(pending.poll(), act);
            }
        }
    }

}


---File: ./server/src/main/java/bgu/spl/net/srv/BaseServer.java---
package bgu.spl.net.srv;

import bgu.spl.net.api.MessageEncoderDecoder;
import bgu.spl.net.api.MessagingProtocol;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.function.Supplier;
import java.util.concurrent.atomic.AtomicInteger;

public abstract class BaseServer<T> implements Server<T> {

    private final int port;
    private final Supplier<MessagingProtocol<T>> protocolFactory;
    private final Supplier<MessageEncoderDecoder<T>> encdecFactory;
    private ServerSocket sock;
    private final ConnectionsImpl<T> connections = new ConnectionsImpl<>();
    private final AtomicInteger connectionIdCounter = new AtomicInteger(0);

    public BaseServer(
            int port,
            Supplier<MessagingProtocol<T>> protocolFactory,
            Supplier<MessageEncoderDecoder<T>> encdecFactory) {

        this.port = port;
        this.protocolFactory = protocolFactory;
        this.encdecFactory = encdecFactory;
		this.sock = null;
    }

    @Override
    public void serve() {

        try (ServerSocket serverSock = new ServerSocket(port)) {
			System.out.println("Server started");

            this.sock = serverSock; //just to be able to close

            while (!Thread.currentThread().isInterrupted()) {

                Socket clientSock = serverSock.accept();
                int connectionId = connectionIdCounter.incrementAndGet();

                BlockingConnectionHandler<T> handler = new BlockingConnectionHandler<>(
                        clientSock,
                        encdecFactory.get(),
                        protocolFactory.get(),
                        connectionId,
                        connections
                );
                
                connections.addConnection(connectionId, handler);
                execute(handler);
            }
        } catch (IOException ex) {
        }

        System.out.println("server closed!!!");
    }

    @Override
    public void close() throws IOException {
		if (sock != null)
			sock.close();
    }

    protected abstract void execute(BlockingConnectionHandler<T>  handler);

}


---File: ./server/src/main/java/bgu/spl/net/srv/BlockingConnectionHandler.java---
package bgu.spl.net.srv;

import bgu.spl.net.api.MessageEncoderDecoder;
import bgu.spl.net.api.StompMessagingProtocol;
import bgu.spl.net.api.MessagingProtocol;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.net.Socket;

public class BlockingConnectionHandler<T> implements Runnable, ConnectionHandler<T> {

    private final StompMessagingProtocol<T> protocol;
    private final MessageEncoderDecoder<T> encdec;
    private final Socket sock;
    private BufferedInputStream in;
    private BufferedOutputStream out;
    private volatile boolean connected = true;

    private final int connectionId;
    private final ConnectionsImpl<T> connections;

    public BlockingConnectionHandler(Socket sock, MessageEncoderDecoder<T> reader, MessagingProtocol<T> protocol, int connectionId, ConnectionsImpl<T> connections) {
        this.sock = sock;
        this.encdec = reader;

        // Cast to StompMessagingProtocol
        if (protocol instanceof StompMessagingProtocol) {
            this.protocol = (StompMessagingProtocol<T>) protocol;
        } else {
            throw new IllegalArgumentException("Protocol must implement StompMessagingProtocol");
        }
        
        this.connectionId = connectionId;
        this.connections = connections;
    }

    @Override
    public void run() {
        try (Socket sock = this.sock) { //just for automatic closing
            int read;

            in = new BufferedInputStream(sock.getInputStream());
            out = new BufferedOutputStream(sock.getOutputStream());

            // Initialize protocol with connectionId and connections
            protocol.start(connectionId, connections);

            while (!protocol.shouldTerminate() && connected && (read = in.read()) >= 0) {
                T nextMessage = encdec.decodeNextByte((byte) read);
                System.err.println("DEBUG Received message: " + nextMessage);
                if (nextMessage != null) {
                    // Process message (no response needed - protocol uses connections.send())
                    protocol.process(nextMessage);
                    /*if (response != null) {
                        out.write(encdec.encode(response));
                        out.flush();
                    }*/
                }
            }

        } catch (IOException ex) {
            ex.printStackTrace();
        }

    }

    @Override
    public void close() throws IOException {
        connected = false;
        sock.close();
    }

    @Override
    public void send(T msg) {
         try {
            if (out != null && connected) {
                synchronized (out) {
                    out.write(encdec.encode(msg));
                    out.flush();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


---File: ./server/src/main/java/bgu/spl/net/srv/ConnectionHandler.java---
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package bgu.spl.net.srv;

import java.io.Closeable;

/**
 * The ConnectionHandler interface for Message of type T
 */
public interface ConnectionHandler<T> extends Closeable {

    /**
     * Comment the following lines (both send methods) for the existing implentations to work.
     *
     */

    void send(T msg);

}


---File: ./server/src/main/java/bgu/spl/net/srv/Connections.java---
package bgu.spl.net.srv;

import java.io.IOException;

public interface Connections<T> {

    boolean send(int connectionId, T msg);

    void send(String channel, T msg);

    void disconnect(int connectionId);

    //new methods for subscribe and unsubscribe
    void subscribe(String channel, int connectionId, String subscriptionId);
    void unsubscribe(String channel, int connectionId, String subscriptionId);
    void addConnection(int connectionId, ConnectionHandler<T> handler);

}


---File: ./server/src/main/java/bgu/spl/net/srv/ConnectionsImpl.java---
package bgu.spl.net.srv;
import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import bgu.spl.net.impl.stomp.StompFrame;

public class ConnectionsImpl<T> implements Connections<T> {
    private Map<Integer, ConnectionHandler<T>> connections = new ConcurrentHashMap<>();
    //Map <"Topic" <ConnectionId, SubscriptionId>>
    private Map<String,ConcurrentHashMap<Integer, String>> topics = new ConcurrentHashMap<>();
    private static final AtomicInteger messageIdCounter = new AtomicInteger(0);

    @Override
    public boolean send(int connectionId, T msg){
        ConnectionHandler<T> handler = connections.get(connectionId);
        if(handler != null){
            handler.send(msg);
            return true;
        }
        return false;
    }

    @Override
    public void send(String channel, T msg){
        ConcurrentHashMap<Integer, String> subscribers = topics.get(channel);
        if(subscribers != null){
            Set<Integer> connectionIds = subscribers.keySet();
            for(Integer id : connectionIds){
                T msgToSend = addsubscriptionToMsg(msg, id, channel);
                send(id, msgToSend);
            }
        }
    }

    @Override
    public void disconnect(int connectionId){
        connections.remove(connectionId);//remove user from connections
        for(ConcurrentHashMap<Integer, String> subscribers : topics.values()){ //remove user from all topics he subscribed to
            subscribers.remove(connectionId);
        }
    }

    @Override
    public void subscribe(String channel, int connectionId, String subscriptionId){
        topics.putIfAbsent(channel, new ConcurrentHashMap<>());
        topics.get(channel).put(connectionId, subscriptionId);
    }

    @Override
    public void unsubscribe(String channel, int connectionId, String subscriptionId)
    {
        ConcurrentHashMap<Integer, String> subscribers = topics.get(channel);
        if(subscribers != null){
            subscribers.remove(connectionId);
            if (subscribers.isEmpty()) {
                topics.remove(channel);
            }
        }
    }
    public void addConnection(int connectionId, ConnectionHandler<T> handler) {
        System.err.println("DEBUG Adding connection with ID: " + connectionId);
        connections.put(connectionId, handler);
    }
    private T addsubscriptionToMsg(T msg, int connectionId, String channel) {
        if (msg instanceof StompFrame) {
           
            StompFrame cloned = new StompFrame((StompFrame) msg);
            
            ConcurrentHashMap<Integer, String> subscribers = topics.get(channel);
            String subscriptionId = subscribers.get(connectionId);
            if (subscriptionId != null) {
                cloned.addHeader("subscription", subscriptionId);
            }
            
            // Add message-id (server-unique)
            cloned.addHeader("message-id", String.valueOf(messageIdCounter.incrementAndGet()));

            return (T) cloned;
        }
        
        return msg;
    }
}


---File: ./server/src/main/java/bgu/spl/net/srv/NonBlockingConnectionHandler.java---
package bgu.spl.net.srv;

import bgu.spl.net.api.MessageEncoderDecoder;
import bgu.spl.net.api.MessagingProtocol;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class NonBlockingConnectionHandler<T> implements ConnectionHandler<T> {

    private static final int BUFFER_ALLOCATION_SIZE = 1 << 13; //8k
    private static final ConcurrentLinkedQueue<ByteBuffer> BUFFER_POOL = new ConcurrentLinkedQueue<>();

    private final MessagingProtocol<T> protocol;
    private final MessageEncoderDecoder<T> encdec;
    private final Queue<ByteBuffer> writeQueue = new ConcurrentLinkedQueue<>();
    private final SocketChannel chan;
    private final Reactor reactor;

    public NonBlockingConnectionHandler(
            MessageEncoderDecoder<T> reader,
            MessagingProtocol<T> protocol,
            SocketChannel chan,
            Reactor reactor) {
        this.chan = chan;
        this.encdec = reader;
        this.protocol = protocol;
        this.reactor = reactor;
    }

    public Runnable continueRead() {
        ByteBuffer buf = leaseBuffer();

        boolean success = false;
        try {
            success = chan.read(buf) != -1;
        } catch (IOException ex) {
            ex.printStackTrace();
        }

        if (success) {
            buf.flip();
            return () -> {
                try {
                    while (buf.hasRemaining()) {
                        T nextMessage = encdec.decodeNextByte(buf.get());
                        if (nextMessage != null) {
                            T response = protocol.process(nextMessage);
                            if (response != null) {
                                writeQueue.add(ByteBuffer.wrap(encdec.encode(response)));
                                reactor.updateInterestedOps(chan, SelectionKey.OP_READ | SelectionKey.OP_WRITE);
                            }
                        }
                    }
                } finally {
                    releaseBuffer(buf);
                }
            };
        } else {
            releaseBuffer(buf);
            close();
            return null;
        }

    }

    public void close() {
        try {
            chan.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    public boolean isClosed() {
        return !chan.isOpen();
    }

    public void continueWrite() {
        while (!writeQueue.isEmpty()) {
            try {
                ByteBuffer top = writeQueue.peek();
                chan.write(top);
                if (top.hasRemaining()) {
                    return;
                } else {
                    writeQueue.remove();
                }
            } catch (IOException ex) {
                ex.printStackTrace();
                close();
            }
        }

        if (writeQueue.isEmpty()) {
            if (protocol.shouldTerminate()) close();
            else reactor.updateInterestedOps(chan, SelectionKey.OP_READ);
        }
    }

    private static ByteBuffer leaseBuffer() {
        ByteBuffer buff = BUFFER_POOL.poll();
        if (buff == null) {
            return ByteBuffer.allocateDirect(BUFFER_ALLOCATION_SIZE);
        }

        buff.clear();
        return buff;
    }

    private static void releaseBuffer(ByteBuffer buff) {
        BUFFER_POOL.add(buff);
    }

    @Override
    public void send(T msg) {
        //IMPLEMENT IF NEEDED
    }
}


---File: ./server/src/main/java/bgu/spl/net/srv/Reactor.java---
package bgu.spl.net.srv;

import bgu.spl.net.api.MessageEncoderDecoder;
import bgu.spl.net.api.MessagingProtocol;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.ClosedSelectorException;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.function.Supplier;

public class Reactor<T> implements Server<T> {

    private final int port;
    private final Supplier<MessagingProtocol<T>> protocolFactory;
    private final Supplier<MessageEncoderDecoder<T>> readerFactory;
    private final ActorThreadPool pool;
    private Selector selector;

    private Thread selectorThread;
    private final ConcurrentLinkedQueue<Runnable> selectorTasks = new ConcurrentLinkedQueue<>();

    public Reactor(
            int numThreads,
            int port,
            Supplier<MessagingProtocol<T>> protocolFactory,
            Supplier<MessageEncoderDecoder<T>> readerFactory) {

        this.pool = new ActorThreadPool(numThreads);
        this.port = port;
        this.protocolFactory = protocolFactory;
        this.readerFactory = readerFactory;
    }

    @Override
    public void serve() {
	selectorThread = Thread.currentThread();
        try (Selector selector = Selector.open();
                ServerSocketChannel serverSock = ServerSocketChannel.open()) {

            this.selector = selector; //just to be able to close

            serverSock.bind(new InetSocketAddress(port));
            serverSock.configureBlocking(false);
            serverSock.register(selector, SelectionKey.OP_ACCEPT);
			System.out.println("Server started");

            while (!Thread.currentThread().isInterrupted()) {

                selector.select();
                runSelectionThreadTasks();

                for (SelectionKey key : selector.selectedKeys()) {

                    if (!key.isValid()) {
                        continue;
                    } else if (key.isAcceptable()) {
                        handleAccept(serverSock, selector);
                    } else {
                        handleReadWrite(key);
                    }
                }

                selector.selectedKeys().clear(); //clear the selected keys set so that we can know about new events

            }

        } catch (ClosedSelectorException ex) {
            //do nothing - server was requested to be closed
        } catch (IOException ex) {
            //this is an error
            ex.printStackTrace();
        }

        System.out.println("server closed!!!");
        pool.shutdown();
    }

    /*package*/ void updateInterestedOps(SocketChannel chan, int ops) {
        final SelectionKey key = chan.keyFor(selector);
        if (Thread.currentThread() == selectorThread) {
            key.interestOps(ops);
        } else {
            selectorTasks.add(() -> {
                key.interestOps(ops);
            });
            selector.wakeup();
        }
    }


    private void handleAccept(ServerSocketChannel serverChan, Selector selector) throws IOException {
        SocketChannel clientChan = serverChan.accept();
        clientChan.configureBlocking(false);
        final NonBlockingConnectionHandler<T> handler = new NonBlockingConnectionHandler<>(
                readerFactory.get(),
                protocolFactory.get(),
                clientChan,
                this);
        clientChan.register(selector, SelectionKey.OP_READ, handler);
    }

    private void handleReadWrite(SelectionKey key) {
        @SuppressWarnings("unchecked")
        NonBlockingConnectionHandler<T> handler = (NonBlockingConnectionHandler<T>) key.attachment();

        if (key.isReadable()) {
            Runnable task = handler.continueRead();
            if (task != null) {
                pool.submit(handler, task);
            }
        }

	    if (key.isValid() && key.isWritable()) {
            handler.continueWrite();
        }
    }

    private void runSelectionThreadTasks() {
        while (!selectorTasks.isEmpty()) {
            selectorTasks.remove().run();
        }
    }

    @Override
    public void close() throws IOException {
        selector.close();
    }

}


---File: ./server/src/main/java/bgu/spl/net/srv/Server.java---
package bgu.spl.net.srv;

import bgu.spl.net.api.MessageEncoderDecoder;
import bgu.spl.net.api.MessagingProtocol;
import java.io.Closeable;
import java.util.function.Supplier;

public interface Server<T> extends Closeable {

    /**
     * The main loop of the server, Starts listening and handling new clients.
     */
    void serve();

    /**
     *This function returns a new instance of a thread per client pattern server
     * @param port The port for the server socket
     * @param protocolFactory A factory that creats new MessagingProtocols
     * @param encoderDecoderFactory A factory that creats new MessageEncoderDecoder
     * @param <T> The Message Object for the protocol
     * @return A new Thread per client server
     */
    public static <T> Server<T>  threadPerClient(
            int port,
            Supplier<MessagingProtocol<T> > protocolFactory,
            Supplier<MessageEncoderDecoder<T> > encoderDecoderFactory) {

        return new BaseServer<T>(port, protocolFactory, encoderDecoderFactory) {
            @Override
            protected void execute(BlockingConnectionHandler<T>  handler) {
                new Thread(handler).start();
            }
        };

    }

    /**
     * This function returns a new instance of a reactor pattern server
     * @param nthreads Number of threads available for protocol processing
     * @param port The port for the server socket
     * @param protocolFactory A factory that creats new MessagingProtocols
     * @param encoderDecoderFactory A factory that creats new MessageEncoderDecoder
     * @param <T> The Message Object for the protocol
     * @return A new reactor server
     */
    public static <T> Server<T> reactor(
            int nthreads,
            int port,
            Supplier<MessagingProtocol<T>> protocolFactory,
            Supplier<MessageEncoderDecoder<T>> encoderDecoderFactory) {
        return new Reactor<T>(nthreads, port, protocolFactory, encoderDecoderFactory);
    }

}

#!/usr/bin/env python3
"""
Basic Python Server for STOMP Assignment  Stage 3.3

IMPORTANT:
DO NOT CHANGE the server name or the basic protocol.
Students should EXTEND this server by implementing
the methods below.
"""

import socket
import sys
import threading


SERVER_NAME = "STOMP_PYTHON_SQL_SERVER"  # DO NOT CHANGE!
DB_FILE = "stomp_server.db"              # DO NOT CHANGE!


def recv_null_terminated(sock: socket.socket) -> str:
    data = b""
    while True:
        chunk = sock.recv(1024)
        if not chunk:
            return ""
        data += chunk
        if b"\0" in data:
            msg, _ = data.split(b"\0", 1)
            return msg.decode("utf-8", errors="replace")


def init_database():
    global db_conn
     
    db_conn = sqlite3.connect(DB_FILE, check_same_thread=False)
    cursor = db_conn.cursor()
    
    # Table Users
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            username TEXT PRIMARY KEY,
            password TEXT NOT NULL,
            registration_date TEXT NOT NULL
        )
    ''')
    
    # Table login history
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS login_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT NOT NULL,
            login_time TEXT NOT NULL,
            logout_time TEXT,
            FOREIGN KEY (username) REFERENCES users(username)
        )
    ''')
    
    # Table file tracking
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS file_tracking (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT NOT NULL,
            filename TEXT NOT NULL,
            upload_time TEXT NOT NULL,
            game_channel TEXT,
            FOREIGN KEY (username) REFERENCES users(username)
        )
    ''')
    
    db_conn.commit()
    print(f"[{SERVER_NAME}] Database initialized")


def execute_sql_command(sql_command: str) -> str:
    global db_conn
    
    try:
        with db_lock:
            cursor = db_conn.cursor()
            cursor.execute(sql_command)
            db_conn.commit()
            return "SUCCESS"
    except Exception as e:
        return f"ERROR:{str(e)}"


def execute_sql_query(sql_query: str) -> str:
    global db_conn
    
    try:
        with db_lock:
            cursor = db_conn.cursor()
            cursor.execute(sql_query)
            rows = cursor.fetchall()
            
            if not rows:
                return "SUCCESS|"
            
            result = "SUCCESS|" + "|".join(str(row) for row in rows)
            return result
    except Exception as e:
        return f"ERROR:{str(e)}"


def handle_client(client_socket: socket.socket, addr):
    print(f"[{SERVER_NAME}] Client connected from {addr}")

    try:
        while True:
            message = recv_null_terminated(client_socket)
            if message == "":
                break

            print(f"[{SERVER_NAME}] Received:")
            print(message)

            client_socket.sendall(b"done\0")

    except Exception as e:
        print(f"[{SERVER_NAME}] Error handling client {addr}: {e}")
    finally:
        try:
            client_socket.close()
        except Exception:
            pass
        print(f"[{SERVER_NAME}] Client {addr} disconnected")


def start_server(host="127.0.0.1", port=7778):
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    try:
        server_socket.bind((host, port))
        server_socket.listen(5)
        print(f"[{SERVER_NAME}] Server started on {host}:{port}")
        print(f"[{SERVER_NAME}] Waiting for connections...")

        while True:
            client_socket, addr = server_socket.accept()
            t = threading.Thread(
                target=handle_client,
                args=(client_socket, addr),
                daemon=True
            )
            t.start()

    except KeyboardInterrupt:
        print(f"\n[{SERVER_NAME}] Shutting down server...")
    finally:
        try:
            server_socket.close()
        except Exception:
            pass


if __name__ == "__main__":
    port = 7778
    if len(sys.argv) > 1:
        raw_port = sys.argv[1].strip()
        try:
            port = int(raw_port)
        except ValueError:
            print(f"Invalid port '{raw_port}', falling back to default {port}")

    start_server(port=port)



<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>bgu.spl</groupId>
    <artifactId>server</artifactId>
    <version>1.0</version>
    <packaging>jar</packaging>
    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>1.8</maven.compiler.source>
        <maven.compiler.target>1.8</maven.compiler.target>
    </properties>
    <name>server</name>
</project>




CFLAGS:=-c -Wall -Weffc++ -g -std=c++11 -Iinclude
LDFLAGS:=-lboost_system -lpthread

all: StompClient

StompClient: bin/ConnectionHandler.o bin/StompClient.o bin/StompProtocol.o bin/event.o
	g++ -o bin/StompClient bin/ConnectionHandler.o bin/StompClient.o bin/StompProtocol.o bin/event.o $(LDFLAGS)

bin/ConnectionHandler.o: src/ConnectionHandler.cpp
	g++ $(CFLAGS) -o bin/ConnectionHandler.o src/ConnectionHandler.cpp

bin/StompClient.o: src/StompClient.cpp
	g++ $(CFLAGS) -o bin/StompClient.o src/StompClient.cpp

bin/StompProtocol.o: src/StompProtocol.cpp
	g++ $(CFLAGS) -o bin/StompProtocol.o src/StompProtocol.cpp

bin/event.o: src/event.cpp
	g++ $(CFLAGS) -o bin/event.o src/event.cpp

.PHONY: clean
clean:
	rm -f bin/*
---File: ./client/include/ConnectionHandler.h---
#pragma once

#include <string>
#include <iostream>
#include <boost/asio.hpp>
#include "StompProtocol.h"
#include <mutex>

using boost::asio::ip::tcp;

class ConnectionHandler {
private:
	const std::string host_;
	const short port_;
	boost::asio::io_service io_service_;   // Provides core I/O functionality
	tcp::socket socket_;

	StompProtocol protocol_;
    
    std::mutex socketMutex_;
    bool connected_;

public:
	ConnectionHandler(std::string host, short port);

	virtual ~ConnectionHandler();

	// Connect to the remote machine
	bool connect();

	// Read a fixed number of bytes from the server - blocking.
	// Returns false in case the connection is closed before bytesToRead bytes can be read.
	bool getBytes(char bytes[], unsigned int bytesToRead);

	// Send a fixed number of bytes from the client - blocking.
	// Returns false in case the connection is closed before all the data is sent.
	bool sendBytes(const char bytes[], int bytesToWrite);

	// Read an ascii line from the server
	// Returns false in case connection closed before a newline can be read.
	bool getLine(std::string &line);

	// Send an ascii line from the server
	// Returns false in case connection closed before all the data is sent.
	bool sendLine(std::string &line);

	// Get Ascii data from the server until the delimiter character
	// Returns false in case connection closed before null can be read.
	bool getFrameAscii(std::string &frame, char delimiter);

	// Send a message to the remote host.
	// Returns false in case connection is closed before all the data is sent.
	bool sendFrameAscii(const std::string &frame, char delimiter);

	// Close down the connection properly.
	void close();
	bool isConnected() const { return connected_; }
    StompProtocol& getProtocol() { return protocol_; }
}; //class ConnectionHandler


---File: ./client/include/event.h---
#pragma once

#include <string>
#include <iostream>
#include <map>
#include <vector>

class Event
{
private:
    // name of team a
    std::string team_a_name;
    // name of team b
    std::string team_b_name;
    // name of the event
    std::string name;
    // time of the event in seconds
    int time;
    // map of all the general game updates
    std::map<std::string, std::string> game_updates;
    // map of all team a updates the second type can be a string bool or int
    std::map<std::string, std::string> team_a_updates;
    // map of all team b updates
    std::map<std::string, std::string> team_b_updates;
    // description of the event
    std::string description;

public:
    Event(std::string name, std::string team_a_name, std::string team_b_name, int time, std::map<std::string, std::string> game_updates, std::map<std::string, std::string> team_a_updates, std::map<std::string, std::string> team_b_updates, std::string discription);
    Event(const std::string & frame_body);
    virtual ~Event();
    const std::string &get_team_a_name() const;
    const std::string &get_team_b_name() const;
    const std::string &get_name() const;
    int get_time() const;
    const std::map<std::string, std::string> &get_game_updates() const;
    const std::map<std::string, std::string> &get_team_a_updates() const;
    const std::map<std::string, std::string> &get_team_b_updates() const;
    const std::string &get_discription() const;
};

// an object that holds the names of the teams and a vector of events, to be returned by the parseEventsFile function
struct names_and_events {
    std::string team_a_name;
    std::string team_b_name;
    std::vector<Event> events;
};

// function that parses the json file and returns a names_and_events object
names_and_events parseEventsFile(std::string json_path);


---File: ./client/include/StompProtocol.h---
#ifndef STOMP_PROTOCOL_H
#define STOMP_PROTOCOL_H

#include <string>
#include <map>
#include <vector>
#include <mutex>
#include "event.h"

using namespace std;

class StompProtocol {
private:
    string username;
    string password;
    int receiptIdCounter;
    int subscriptionIdCounter;
    bool loggedIn;
    mutex mtx;
    
    // Maps subscription ID to topic
    map<string, string> subscriptions;
    

    // Map: user -> game -> events
    map<string, map<string, names_and_events>> gameReports;
    
    string generateReceiptId();
    string generateSubscriptionId();
    
public:
    StompProtocol();
    
    // Frame builders
    string buildConnectFrame(const string& host, 
                                  const string& user, 
                                  const string& pass);
    
    string buildSubscribeFrame(const string& topic);
    
    string buildUnsubscribeFrame(const string& subscriptionId);
    
    string buildSendFrame(const string& topic, 
                               const Event& event, 
                               const string& user);
    
    string buildDisconnectFrame();
    
    // Frame handlers
    void handleMessageFrame(const string& frame);
    
    // Game data management
    void saveGameEvent(const string& user, 
                      const string& gameName, 
                      const Event& event);
    
    void generateSummary(const string& gameName, 
                        const string& user, 
                        const string& outputFile);
    
    // State
    bool isLoggedIn() const { return loggedIn; }
    void setLoggedIn(bool status) { loggedIn = status; }

    string getSubscriptionIdByTopic(const string& topic);
    string getCurrentUsername() const { return username; }

};

#endif

---File: ./client/makefile---
CFLAGS:=-c -Wall -Weffc++ -g -std=c++11 -Iinclude
LDFLAGS:=-lboost_system -lpthread

all: StompClient

StompClient: bin/ConnectionHandler.o bin/StompClient.o bin/StompProtocol.o bin/event.o
	g++ -o bin/StompClient bin/ConnectionHandler.o bin/StompClient.o bin/StompProtocol.o bin/event.o $(LDFLAGS)

bin/ConnectionHandler.o: src/ConnectionHandler.cpp
	g++ $(CFLAGS) -o bin/ConnectionHandler.o src/ConnectionHandler.cpp

bin/StompClient.o: src/StompClient.cpp
	g++ $(CFLAGS) -o bin/StompClient.o src/StompClient.cpp

bin/StompProtocol.o: src/StompProtocol.cpp
	g++ $(CFLAGS) -o bin/StompProtocol.o src/StompProtocol.cpp

bin/event.o: src/event.cpp
	g++ $(CFLAGS) -o bin/event.o src/event.cpp

.PHONY: clean
clean:
	rm -f bin/*

---File: ./client/src/ConnectionHandler.cpp---
#include "../include/ConnectionHandler.h"

using boost::asio::ip::tcp;

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::string;

ConnectionHandler::ConnectionHandler(string host, short port) : host_(host), port_(port), io_service_(),
                                                                socket_(io_service_), connected_(false) {}

ConnectionHandler::~ConnectionHandler() {
	close();
}

bool ConnectionHandler::connect() {
	std::cout << "Starting connect to "
	          << host_ << ":" << port_ << std::endl;
	try {
		tcp::endpoint endpoint(boost::asio::ip::address::from_string(host_), port_); // the server endpoint
		boost::system::error_code error;
		socket_.connect(endpoint, error);
		if (error)
			throw boost::system::system_error(error);
		connected_ = true;
	}
	catch (std::exception &e) {
		std::cerr << "Connection failed (Error: " << e.what() << ')' << std::endl;
		return false;
	}
	return true;
}

bool ConnectionHandler::getBytes(char bytes[], unsigned int bytesToRead) {
	size_t tmp = 0;
	boost::system::error_code error;
	try {
		//lock_guard<std::mutex> lock(socketMutex_);
		while (!error && bytesToRead > tmp) {
			tmp += socket_.read_some(boost::asio::buffer(bytes + tmp, bytesToRead - tmp), error);
		}
		if (error)
			throw boost::system::system_error(error);
	} catch (std::exception &e) {
		std::cerr << "recv failed (Error: " << e.what() << ')' << std::endl;
		return false;
	}
	return true;
}

bool ConnectionHandler::sendBytes(const char bytes[], int bytesToWrite) {
	int tmp = 0;
	boost::system::error_code error;
	try {
		//std::lock_guard<std::mutex> lock(socketMutex_);
		while (!error && bytesToWrite > tmp) {
			tmp += socket_.write_some(boost::asio::buffer(bytes + tmp, bytesToWrite - tmp), error);
		}
		if (error)
			throw boost::system::system_error(error);
	} catch (std::exception &e) {
		std::cerr << "recv failed (Error: " << e.what() << ')' << std::endl;
		return false;
	}
	return true;
}

bool ConnectionHandler::getLine(std::string &line) {
	return getFrameAscii(line, '\n');
}

bool ConnectionHandler::sendLine(std::string &line) {
	return sendFrameAscii(line, '\n');
}


bool ConnectionHandler::getFrameAscii(std::string &frame, char delimiter) {
	char ch;
	try {
		do {
			if (!getBytes(&ch, 1)) {
				return false;
			}
			if (ch != '\0')
				frame.append(1, ch);
		} while (delimiter != ch);
	} catch (std::exception &e) {
		std::cerr << "recv failed2 (Error: " << e.what() << ')' << std::endl;
		return false;
	}
	//std::cout << "\n DEBUG [CLIENT RCV] <<<<<<<<<<<<<<<\n" << frame << "\n[END RCV] <<<<<<<<<<<<<<<\n" << std::endl;
	return true;
}

bool ConnectionHandler::sendFrameAscii(const std::string &frame, char delimiter) {
	//std::cout << "\n DEBUG [CLIENT SND] >>>>>>>>>>>>>>>\n" << frame << "\n[END SND] >>>>>>>>>>>>>>>\n" << std::endl;
	bool result = sendBytes(frame.c_str(), frame.length());
	if (!result) return false;
	return sendBytes(&delimiter, 1);
}

// Close down the connection properly.
void ConnectionHandler::close() {
	try {
		connected_ = false;
		socket_.close();
	} catch (...) {
		std::cout << "closing failed: connection already closed" << std::endl;
	}
}


---File: ./client/src/echoClient.cpp---
#include <stdlib.h>
#include "../include/ConnectionHandler.h"

/**
* This code assumes that the server replies the exact text the client sent it (as opposed to the practical session example)
*/
int main (int argc, char *argv[]) {
    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " host port" << std::endl << std::endl;
        return -1;
    }
    std::string host = argv[1];
    short port = atoi(argv[2]);
    
    ConnectionHandler connectionHandler(host, port);
    if (!connectionHandler.connect()) {
        std::cerr << "Cannot connect to " << host << ":" << port << std::endl;
        return 1;
    }
	
	//From here we will see the rest of the ehco client implementation:
    while (1) {
        const short bufsize = 1024;
        char buf[bufsize];
        std::cin.getline(buf, bufsize);
		std::string line(buf);
		int len=line.length();
        if (!connectionHandler.sendLine(line)) {
            std::cout << "Disconnected. Exiting...\n" << std::endl;
            break;
        }
		// connectionHandler.sendLine(line) appends '\n' to the message. Therefor we send len+1 bytes.
        std::cout << "Sent " << len+1 << " bytes to server" << std::endl;

 
        // We can use one of three options to read data from the server:
        // 1. Read a fixed number of characters
        // 2. Read a line (up to the newline character using the getline() buffered reader
        // 3. Read up to the null character
        std::string answer;
        // Get back an answer: by using the expected number of bytes (len bytes + newline delimiter)
        // We could also use: connectionHandler.getline(answer) and then get the answer without the newline char at the end
        if (!connectionHandler.getLine(answer)) {
            std::cout << "Disconnected. Exiting...\n" << std::endl;
            break;
        }
        
		len=answer.length();
		// A C string must end with a 0 char delimiter.  When we filled the answer buffer from the socket
		// we filled up to the \n char - we must make sure now that a 0 char is also present. So we truncate last character.
        answer.resize(len-1);
        std::cout << "Reply: " << answer << " " << len << " bytes " << std::endl << std::endl;
        if (answer == "bye") {
            std::cout << "Exiting...\n" << std::endl;
            break;
        }
    }
    return 0;
}


---File: ./client/src/event.cpp---
#include "../include/event.h"
#include "../include/json.hpp"
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <vector>
#include <sstream>
using json = nlohmann::json;

Event::Event(std::string team_a_name, std::string team_b_name, std::string name, int time,
             std::map<std::string, std::string> game_updates, std::map<std::string, std::string> team_a_updates,
             std::map<std::string, std::string> team_b_updates, std::string discription)
    : team_a_name(team_a_name), team_b_name(team_b_name), name(name),
      time(time), game_updates(game_updates), team_a_updates(team_a_updates),
      team_b_updates(team_b_updates), description(discription)
{
}

Event::~Event()
{
}

const std::string &Event::get_team_a_name() const
{
    return this->team_a_name;
}

const std::string &Event::get_team_b_name() const
{
    return this->team_b_name;
}

const std::string &Event::get_name() const
{
    return this->name;
}

int Event::get_time() const
{
    return this->time;
}

const std::map<std::string, std::string> &Event::get_game_updates() const
{
    return this->game_updates;
}

const std::map<std::string, std::string> &Event::get_team_a_updates() const
{
    return this->team_a_updates;
}

const std::map<std::string, std::string> &Event::get_team_b_updates() const
{
    return this->team_b_updates;
}

const std::string &Event::get_discription() const
{
    return this->description;
}

Event::Event(const std::string &frame_body) : team_a_name(""), team_b_name(""), name(""), time(0), game_updates(), team_a_updates(), team_b_updates(), description("")
{
}

names_and_events parseEventsFile(std::string json_path)
{
    std::ifstream f(json_path);
    json data = json::parse(f);

    std::string team_a_name = data["team a"];
    std::string team_b_name = data["team b"];

    // run over all the events and convert them to Event objects
    std::vector<Event> events;
    for (auto &event : data["events"])
    {
        std::string name = event["event name"];
        int time = event["time"];
        std::string description = event["description"];
        std::map<std::string, std::string> game_updates;
        std::map<std::string, std::string> team_a_updates;
        std::map<std::string, std::string> team_b_updates;
        for (auto &update : event["general game updates"].items())
        {
            if (update.value().is_string())
                game_updates[update.key()] = update.value();
            else
                game_updates[update.key()] = update.value().dump();
        }

        for (auto &update : event["team a updates"].items())
        {
            if (update.value().is_string())
                team_a_updates[update.key()] = update.value();
            else
                team_a_updates[update.key()] = update.value().dump();
        }

        for (auto &update : event["team b updates"].items())
        {
            if (update.value().is_string())
                team_b_updates[update.key()] = update.value();
            else
                team_b_updates[update.key()] = update.value().dump();
        }
        
        events.push_back(Event(team_a_name, team_b_name, name, time, game_updates, team_a_updates, team_b_updates, description));
    }
    names_and_events events_and_names{team_a_name, team_b_name, events};

    return events_and_names;
}

---File: ./client/src/StompClient.cpp---
#include <iostream>
#include <thread>
#include <string>
#include <sstream>
#include <vector>
#include "../include/ConnectionHandler.h"
#include "event.h"

void socketReaderThread(ConnectionHandler* handler) {
    while (handler->isConnected()) {
        std::string frame;
        
        if (!handler->getFrameAscii(frame, '\0')) {
            break;
        }
        std::cout << "DEBUG === RECEIVED FRAME ===\n" << frame << "\n==================\n";

        if (frame.substr(0, 9) == "CONNECTED") {
            std::cout << "Login successful" << std::endl;
            handler->getProtocol().setLoggedIn(true);
            
        } else if (frame.substr(0, 5) == "ERROR") {
            std::cerr << "Error from server:\n" << frame << std::endl;
            handler->close();
            break;
            
        } else if (frame.substr(0, 7) == "RECEIPT") {
            size_t pos = frame.find("receipt-id:");
            if (pos != std::string::npos) {
                std::string receiptId = frame.substr(pos + 11);
                receiptId = receiptId.substr(0, receiptId.find('\n'));
            }
            
        } else if (frame.substr(0, 7) == "MESSAGE") {
            handler->getProtocol().handleMessageFrame(frame);
        }
    }
}

std::vector<std::string> split(const std::string& str, char delimiter) {
    std::vector<std::string> tokens;
    std::string token;
    std::istringstream tokenStream(str);
    
    while (std::getline(tokenStream, token, delimiter)) {
        tokens.push_back(token);
    }
    
    return tokens;
}

int main(int argc, char* argv[]) {
    ConnectionHandler* handler = nullptr;
    std::thread* readerThread = nullptr;
    
    std::string line;
    
    while (std::getline(std::cin, line)) {
        std::vector<std::string> tokens = split(line, ' ');
        
        if (tokens.empty()) continue;
        
        std::string command = tokens[0];
        
        if (command == "login") {
            cout << "DEBUG Attempting to log in..." << std::endl;
            if (tokens.size() != 4) {
                std::cerr << "Usage: login host:port username password" << std::endl;
                continue;
            }
            
            if (handler != nullptr && handler->isConnected()) {
                std::cerr << "The client is already logged in, log out before trying again" << std::endl;
                continue;
            }
            
            std::string hostPort = tokens[1];
            size_t colonPos = hostPort.find(':');
            
            if (colonPos == std::string::npos) {
                std::cerr << "Invalid host:port format" << std::endl;
                continue;
            }
            
            std::string host = hostPort.substr(0, colonPos);
            short port = std::stoi(hostPort.substr(colonPos + 1));
            
            std::string username = tokens[2];
            std::string password = tokens[3];
            
            handler = new ConnectionHandler(host, port);
            
            if (!handler->connect()) {
                delete handler;
                handler = nullptr;
                continue;
            }
            readerThread = new std::thread(socketReaderThread, handler);

            std::string connectFrame = handler->getProtocol().buildConnectFrame(host, username, password);
            handler->sendFrameAscii(connectFrame, '\0');            
        }
        else if (command == "join") {
            std::cout << "DEBUG Processing join command" << std::endl;  

            if (tokens.size() != 2) {
                std::cerr << "Usage: join game_name" << std::endl;
                continue;
            }
            
            if (handler == nullptr || !handler->isConnected()) {
                std::cerr << "Not connected to server" << std::endl;
                continue;
            }
            if (!handler->getProtocol().isLoggedIn()) {
                std::cerr << "Not logged in. Please wait for login to complete." << std::endl;
                continue;
            }
            std::string gameName = tokens[1];
            std::string topic = "/" + gameName;
            
            std::string subscribeFrame = handler->getProtocol().buildSubscribeFrame(topic);
            std::cout << "DEBUG === SENDING SUBSCRIBE ===\n" << subscribeFrame << "\n==================\n";

            handler->sendFrameAscii(subscribeFrame, '\0');
            
            std::cout << "Joined channel " << gameName << std::endl;
        }
        
        else if (command == "exit") {
            if (tokens.size() != 2) {
                std::cerr << "Usage: exit game_name" << std::endl;
                continue;
            }
            
            if (handler == nullptr || !handler->isConnected()) {
                std::cerr << "Not connected to server" << std::endl;
                continue;
            }
            
            std::string gameName = tokens[1];
            
            std::string topic = "/" + gameName;
            std::string subId = handler->getProtocol().getSubscriptionIdByTopic(topic);
            if (subId == "") {
                std::cerr << "Error: You are not subscribed to " << gameName << std::endl;
                continue;
            }
            std::string unsubscribeFrame = handler->getProtocol().buildUnsubscribeFrame(subId);
            handler->sendFrameAscii(unsubscribeFrame, '\0');
            
            std::cout << "Exited channel " << gameName << std::endl;
        }
        
        else if (command == "report") {
            if (tokens.size() != 2) {
                std::cerr << "Usage: report filename" << std::endl;
                continue;
            }
            
            if (handler == nullptr || !handler->isConnected()) {
                std::cerr << "Not connected to server" << std::endl;
                continue;
            }
            
            std::string filename = tokens[1];
            
            names_and_events nae = parseEventsFile(filename);
            
            std::string gameName = nae.team_a_name + "_" + nae.team_b_name;
            std::string topic = "/" + gameName;
            
            for (const Event& event : nae.events) {
                std::string sendFrame = handler->getProtocol().buildSendFrame(
                    topic, event, handler->getProtocol().getCurrentUsername()
                );
                handler->sendFrameAscii(sendFrame, '\0');
                
                handler->getProtocol().saveGameEvent(handler->getProtocol().getCurrentUsername(), gameName, event);
            }
        }
        else if (command == "summary") {
            if (tokens.size() != 4) {
                std::cerr << "Usage: summary game_name user outputfile" << std::endl;
                continue;
            }
            
            std::string gameName = tokens[1];
            std::string user = tokens[2];
            std::string outputFile = tokens[3];
            
            handler->getProtocol().generateSummary(gameName, user, outputFile);
        }
        else if (command == "logout") {
            if (handler == nullptr || !handler->isConnected()) {
                std::cerr << "Not connected to server" << std::endl;
                continue;
            }
            
            std::string disconnectFrame = handler->getProtocol().buildDisconnectFrame();
            handler->sendFrameAscii(disconnectFrame, '\0');
            
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
            
            handler->close();
            
            if (readerThread != nullptr) {
                readerThread->join();
                delete readerThread;
                readerThread = nullptr;
            }
            
            delete handler;
            handler = nullptr;
            
            std::cout << "Logged out" << std::endl;
        }
        else {
            std::cerr << "Unknown command: " << command << std::endl;
        }
    }
    
    if (handler != nullptr) {
        handler->close();
        if (readerThread != nullptr) {
            readerThread->join();
            delete readerThread;
        }
        delete handler;
    }
    
    return 0;
}

---File: ./client/src/StompProtocol.cpp---
#include "StompProtocol.h"
#include <sstream>
#include <fstream>
#include <iostream>
#include <algorithm>

using namespace std;

StompProtocol::StompProtocol() 
    : username(""), password(""), receiptIdCounter(0), 
      subscriptionIdCounter(0), loggedIn(false) {}

string StompProtocol::generateReceiptId() {
    lock_guard<mutex> lock(mtx);
    return to_string(++receiptIdCounter);
}

string StompProtocol::generateSubscriptionId() {
    lock_guard<mutex> lock(mtx);
    return to_string(++subscriptionIdCounter);
}

string StompProtocol::buildConnectFrame(const string& host, 
                                        const string& user, 
                                        const string& pass) {
    username = user;
    password = pass;
    
    string frame = "";
    frame.append("CONNECT\n");
    frame.append("accept-version:1.2\n");
    frame.append("host:stomp.cs.bgu.ac.il\n");
    frame.append("login:").append(user).append("\n");
    frame.append("passcode:").append(pass).append("\n");
    frame.append("\n");
    
    return frame;
}

string StompProtocol::buildSubscribeFrame(const string& topic) {
    string subId = generateSubscriptionId();
    string receiptId = generateReceiptId();
    
    {
        lock_guard<mutex> lock(mtx);
        subscriptions[subId] = topic;
    }
    
    string frame = "";
    frame.append("SUBSCRIBE\n");
    frame.append("destination:").append(topic).append("\n");
    frame.append("id:").append(subId).append("\n");
    frame.append("receipt:").append(receiptId).append("\n");
    frame.append("\n");
    
    return frame;
}

string StompProtocol::buildUnsubscribeFrame(const string& subId) {
    string receiptId = generateReceiptId();
    
    string frame = "";
    frame.append("UNSUBSCRIBE\n");
    frame.append("id:").append(subId).append("\n");
    frame.append("receipt:").append(receiptId).append("\n");
    frame.append("\n");
    
    {
        lock_guard<mutex> lock(mtx);
        subscriptions.erase(subId);
    }
    
    return frame;
}

string StompProtocol::buildSendFrame(const string& topic, 
                                     const Event& event, 
                                     const string& user) {
    string frame = "";
    
    frame.append("SEND\n");
    frame.append("destination:").append(topic).append("\n");
    frame.append("\n");
    frame.append("user: ").append(user).append("\n");
    frame.append("team a: ").append(event.get_team_a_name()).append("\n");
    frame.append("team b: ").append(event.get_team_b_name()).append("\n");
    frame.append("event name: ").append(event.get_name()).append("\n");
    frame.append("time: ").append(to_string(event.get_time())).append("\n");
    
    frame.append("\n");
    
    frame.append("general game updates:\n");
    for (auto& kv : event.get_game_updates()) {
        frame.append(kv.first).append(": ").append(kv.second).append("\n");
    }
    
    frame.append("team a updates:\n");
    for (auto& kv : event.get_team_a_updates()) {
        frame.append(kv.first).append(": ").append(kv.second).append("\n");
    }
    
    frame.append("team b updates:\n");
    for (auto& kv : event.get_team_b_updates()) {
        frame.append(kv.first).append(": ").append(kv.second).append("\n");
    }
    
    // BODY - description
    frame.append("description:\n").append(event.get_discription()).append("\n");
    
    return frame;
}

string StompProtocol::buildDisconnectFrame() {
    string receiptId = generateReceiptId();
    
    string frame = "";
    frame.append("DISCONNECT\n");
    frame.append("receipt:").append(receiptId).append("\n");
    frame.append("\n");
    
    return frame;
}

void StompProtocol::handleMessageFrame(const string& frame) {
    istringstream iss(frame);
    string line;
    map<string, string> headers;
    
    // 1. Parse Headers
    getline(iss, line); // Skip command
    while (getline(iss, line) && !line.empty() && line != "\r") {
        size_t colonPos = line.find(':');
        if (colonPos != string::npos) {
            string key = line.substr(0, colonPos);
            string value = line.substr(colonPos + 1);
            // Trim (semplificato)
            if (!value.empty() && value[0] == ' ') value = value.substr(1);
            if (!value.empty() && value.back() == '\r') value.pop_back();
            headers[key] = value;
        }
    }
    
    // 2. Extract Body
    string bodyStream = "";
    while (getline(iss, line)) {
        if (!line.empty() && line.back() == '\r') line.pop_back(); // Remove CR
        bodyStream.append(line).append("\n");
    }
    
    // 3. Parse Body for Data (User, Team, Time, Updates)
    std::string user = "";
    std::string teamA = "";
    std::string teamB = "";
    std::string eventName = "";
    int time = 0;
    
    std::map<std::string, std::string> gameUpdates;
    std::map<std::string, std::string> teamAUpdates;
    std::map<std::string, std::string> teamBUpdates;
    std::string description = "";
    
    std::istringstream bodyStream2(bodyStream);
    std::string section = "";
    
    while (std::getline(bodyStream2, line)) {
        if (!line.empty() && line.back() == '\r') line.pop_back();

        // --- Parsing Metadata fields from Body ---
        if (line.find("user: ") == 0) user = line.substr(6);
        else if (line.find("team a: ") == 0) teamA = line.substr(8);
        else if (line.find("team b: ") == 0) teamB = line.substr(8);
        else if (line.find("event name: ") == 0) eventName = line.substr(12);
        else if (line.find("time: ") == 0) {
            try { time = std::stoi(line.substr(6)); } catch (...) { time = 0; }
        }
        // --- Parsing Sections ---
        else if (line == "general game updates:") section = "general";
        else if (line == "team a updates:") section = "team_a";
        else if (line == "team b updates:") section = "team_b";
        else if (line == "description:") {
            section = "description";
            // Read everything else as description
            std::string descLine;
            while (std::getline(bodyStream2, descLine)) {
                if (!descLine.empty() && descLine.back() == '\r') descLine.pop_back();
                description.append(descLine).append("\n");
            }
            if (!description.empty() && description.back() == '\n') description.pop_back();
            break; 
        }
        // --- Parsing Updates Key-Values ---
        else if (!line.empty() && line.find(':') != std::string::npos) {
            size_t colonPos = line.find(':');
            std::string key = line.substr(0, colonPos);
            std::string value = line.substr(colonPos + 1);
            if (!value.empty() && value[0] == ' ') value = value.substr(1);
            
            if (section == "general") gameUpdates[key] = value;
            else if (section == "team_a") teamAUpdates[key] = value;
            else if (section == "team_b") teamBUpdates[key] = value;
        }
    }
    
    std::string gameName = teamA + "_" + teamB;

    // 4. Save and Print
    Event event(teamA, teamB, eventName, time, 
                gameUpdates, teamAUpdates, teamBUpdates, description);
    
    saveGameEvent(user, gameName, event);
    
    // Print to console formatted
    std::cout << user << " - " << gameName << ":\n";
    std::cout << eventName << "\n";
    std::cout << description << "\n" << std::endl;
}

void StompProtocol::saveGameEvent(const string& user, 
                                  const string& gameName, 
                                  const Event& event) {
    lock_guard<mutex> lock(mtx);
    
    if (gameReports[user].find(gameName) == gameReports[user].end()) {
        gameReports[user][gameName] = names_and_events();
        
        // Extract team names from gameName (format: "USA_Canada")
        size_t underscorePos = gameName.find('_');
        if (underscorePos != string::npos) {
            gameReports[user][gameName].team_a_name = gameName.substr(0, underscorePos);
            gameReports[user][gameName].team_b_name = gameName.substr(underscorePos + 1);
        }
    }
    
    // Add event
    gameReports[user][gameName].events.push_back(event);
}

void StompProtocol::generateSummary(const string& gameName, 
                                    const string& user, 
                                    const string& outputFile) {
    ofstream out(outputFile);
    
    if (!out.is_open()) {
        cerr << "Cannot open file: " << outputFile << endl;
        return;
    }
    
    // Find reports for this game and user
    auto userIt = gameReports.find(user);
    if (userIt == gameReports.end()) {
        out << "No reports found for user " << user << endl;
        out.close();
        cout << "Summary written to " << outputFile << endl;
        return;
    }
    
    auto gameIt = userIt->second.find(gameName);
    if (gameIt == userIt->second.end()) {
        out << "No reports found for game " << gameName << endl;
        out.close();
        cout << "Summary written to " << outputFile << endl;
        return;
    }
    
    names_and_events& nae = gameIt->second;
    
    // Header (assignment format)
    out << nae.team_a_name << " vs " << nae.team_b_name << "\n";
    out << "Game stats:\n";
    out << "General stats:\n";
    
    // Aggregate general stats from all events
    map<string, string> generalStats;
    for (const Event& event : nae.events) {
        for (auto& kv : event.get_game_updates()) {
            generalStats[kv.first] = kv.second;  // Last value wins
        }
    }
    
    // Print general stats (lexicographic order)
    for (auto& kv : generalStats) {
        out << kv.first << ": " << kv.second << "\n";
    }
    
    // Team A stats
    out << nae.team_a_name << " stats:\n";
    map<string, string> teamAStats;
    for (const Event& event : nae.events) {
        for (auto& kv : event.get_team_a_updates()) {
            teamAStats[kv.first] = kv.second;
        }
    }
    for (auto& kv : teamAStats) {
        out << kv.first << ": " << kv.second << "\n";
    }
    
    // Team B stats
    out << nae.team_b_name << " stats:\n";
    map<string, string> teamBStats;
    for (const Event& event : nae.events) {
        for (auto& kv : event.get_team_b_updates()) {
            teamBStats[kv.first] = kv.second;
        }
    }
    for (auto& kv : teamBStats) {
        out << kv.first << ": " << kv.second << "\n";
    }
    
    // Game event reports
    out << "\nGame event reports:\n";
    
    // Sort events by time (handling halftime)
    vector<Event> sortedEvents = nae.events;
    sort(sortedEvents.begin(), sortedEvents.end(), 
         [](const Event& a, const Event& b) {
             // If one is "halftime", handle specially
             bool aBeforeHalftime = true;
             bool bBeforeHalftime = true;
             
             // Check if events have "before halftime" in game_updates
             auto aUpdates = a.get_game_updates();
             auto bUpdates = b.get_game_updates();
             
             if (aUpdates.find("before halftime") != aUpdates.end()) {
                 aBeforeHalftime = (aUpdates.at("before halftime") == "true");
             }
             
             if (bUpdates.find("before halftime") != bUpdates.end()) {
                 bBeforeHalftime = (bUpdates.at("before halftime") == "true");
             }
             
             // If one is before halftime and the other is after
             if (aBeforeHalftime && !bBeforeHalftime) return true;
             if (!aBeforeHalftime && bBeforeHalftime) return false;
             
             // Otherwise sort by time
             return a.get_time() < b.get_time();
         });
    
    // Print events
    for (const Event& event : sortedEvents) {
        out << event.get_time() << " - " << event.get_name() << ":\n";
        out << event.get_discription() << "\n\n";
    }
    
    out.close();
    cout << "Summary written to " << outputFile << endl;
}
string StompProtocol::getSubscriptionIdByTopic(const string& topic) {
    lock_guard<mutex> lock(mtx);
    
    for (auto const& [id, subTopic] : subscriptions) {
        if (subTopic == topic) {
            return id; 
        }
    }
    return ""; 
}

---File: ./data/sql_server.py---
#!/usr/bin/env python3
"""
Basic Python Server for STOMP Assignment  Stage 3.3

IMPORTANT:
DO NOT CHANGE the server name or the basic protocol.
Students should EXTEND this server by implementing
the methods below.
"""

import socket
import sys
import threading


SERVER_NAME = "STOMP_PYTHON_SQL_SERVER"  # DO NOT CHANGE!
DB_FILE = "stomp_server.db"              # DO NOT CHANGE!


def recv_null_terminated(sock: socket.socket) -> str:
    data = b""
    while True:
        chunk = sock.recv(1024)
        if not chunk:
            return ""
        data += chunk
        if b"\0" in data:
            msg, _ = data.split(b"\0", 1)
            return msg.decode("utf-8", errors="replace")


def init_database():
    global db_conn
     
    db_conn = sqlite3.connect(DB_FILE, check_same_thread=False)
    cursor = db_conn.cursor()
    
    # Table Users
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            username TEXT PRIMARY KEY,
            password TEXT NOT NULL,
            registration_date TEXT NOT NULL
        )
    ''')
    
    # Table login history
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS login_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT NOT NULL,
            login_time TEXT NOT NULL,
            logout_time TEXT,
            FOREIGN KEY (username) REFERENCES users(username)
        )
    ''')
    
    # Table file tracking
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS file_tracking (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT NOT NULL,
            filename TEXT NOT NULL,
            upload_time TEXT NOT NULL,
            game_channel TEXT,
            FOREIGN KEY (username) REFERENCES users(username)
        )
    ''')
    
    db_conn.commit()
    print(f"[{SERVER_NAME}] Database initialized")


def execute_sql_command(sql_command: str) -> str:
    global db_conn
    
    try:
        with db_lock:
            cursor = db_conn.cursor()
            cursor.execute(sql_command)
            db_conn.commit()
            return "SUCCESS"
    except Exception as e:
        return f"ERROR:{str(e)}"


def execute_sql_query(sql_query: str) -> str:
    global db_conn
    
    try:
        with db_lock:
            cursor = db_conn.cursor()
            cursor.execute(sql_query)
            rows = cursor.fetchall()
            
            if not rows:
                return "SUCCESS|"
            
            result = "SUCCESS|" + "|".join(str(row) for row in rows)
            return result
    except Exception as e:
        return f"ERROR:{str(e)}"


def handle_client(client_socket: socket.socket, addr):
    print(f"[{SERVER_NAME}] Client connected from {addr}")

    try:
        while True:
            message = recv_null_terminated(client_socket)
            if message == "":
                break

            print(f"[{SERVER_NAME}] Received:")
            print(message)

            client_socket.sendall(b"done\0")

    except Exception as e:
        print(f"[{SERVER_NAME}] Error handling client {addr}: {e}")
    finally:
        try:
            client_socket.close()
        except Exception:
            pass
        print(f"[{SERVER_NAME}] Client {addr} disconnected")


def start_server(host="127.0.0.1", port=7778):
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    try:
        server_socket.bind((host, port))
        server_socket.listen(5)
        print(f"[{SERVER_NAME}] Server started on {host}:{port}")
        print(f"[{SERVER_NAME}] Waiting for connections...")

        while True:
            client_socket, addr = server_socket.accept()
            t = threading.Thread(
                target=handle_client,
                args=(client_socket, addr),
                daemon=True
            )
            t.start()

    except KeyboardInterrupt:
        print(f"\n[{SERVER_NAME}] Shutting down server...")
    finally:
        try:
            server_socket.close()
        except Exception:
            pass


if __name__ == "__main__":
    port = 7778
    if len(sys.argv) > 1:
        raw_port = sys.argv[1].strip()
        try:
            port = int(raw_port)
        except ValueError:
            print(f"Invalid port '{raw_port}', falling back to default {port}")

    start_server(port=port)


---File: ./server/src/main/java/bgu/spl/net/api/MessageEncoderDecoder.java---
package bgu.spl.net.api;

public interface MessageEncoderDecoder<T> {

    /**
     * add the next byte to the decoding process
     *
     * @param nextByte the next byte to consider for the currently decoded
     * message
     * @return a message if this byte completes one or null if it doesnt.
     */
    T decodeNextByte(byte nextByte);

    /**
     * encodes the given message to bytes array
     *
     * @param message the message to encode
     * @return the encoded bytes
     */
    byte[] encode(T message);

}


---File: ./server/src/main/java/bgu/spl/net/api/MessagingProtocol.java---
package bgu.spl.net.api;

public interface MessagingProtocol<T> {
 
    /**
     * process the given message 
     * @param msg the received message
     * @return the response to send or null if no response is expected by the client
     */
    T process(T msg);
 
    /**
     * @return true if the connection should be terminated
     */
    boolean shouldTerminate();
 
}

---File: ./server/src/main/java/bgu/spl/net/api/StompMessagingProtocol.java---
package bgu.spl.net.api;

import bgu.spl.net.srv.Connections;

public interface StompMessagingProtocol<T> extends MessagingProtocol<T> {
	/**
	 * Used to initiate the current client protocol with it's personal connection ID and the connections implementation
	**/
    void start(int connectionId, Connections<T> connections);
    
    //void process(T message);
	
	/**
     * @return true if the connection should be terminated
     */
    boolean shouldTerminate();
}


---File: ./server/src/main/java/bgu/spl/net/impl/data/Database.java---
package bgu.spl.net.impl.data;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.concurrent.ConcurrentHashMap;

public class Database {
	private final ConcurrentHashMap<String, User> userMap;
	private final ConcurrentHashMap<Integer, User> connectionsIdMap;
	private final String sqlHost;
	private final int sqlPort;

	private Database() {
		userMap = new ConcurrentHashMap<>();
		connectionsIdMap = new ConcurrentHashMap<>();
		// SQL server connection details
		this.sqlHost = "127.0.0.1";
		this.sqlPort = 7778;
	}

	public static Database getInstance() {
		return Instance.instance;
	}

	/**
	 * Execute SQL query and return result
	 * @param sql SQL query string
	 * @return Result string from SQL server
	 */
	private String executeSQL(String sql) {
		try (Socket socket = new Socket(sqlHost, sqlPort);
			 PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
			 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {
			
			// Send SQL with null terminator
			out.print(sql + '\0');
			out.flush();
			
			// Read response until null terminator
			StringBuilder response = new StringBuilder();
			int ch;
			while ((ch = in.read()) != -1 && ch != '\0') {
				response.append((char) ch);
			}
			
			return response.toString();
			
		} catch (Exception e) {
			System.err.println("SQL Error: " + e.getMessage());
			return "ERROR:" + e.getMessage();
		}
	}

	/**
	 * Escape SQL special characters to prevent SQL injection
	 */
	private String escapeSql(String str) {
		if (str == null) return "";
		return str.replace("'", "''");
	}

	public void addUser(User user) {
		userMap.putIfAbsent(user.name, user);
		connectionsIdMap.putIfAbsent(user.getConnectionId(), user);
	}

	public LoginStatus login(int connectionId, String username, String password) {
		if (connectionsIdMap.containsKey(connectionId)) {
			return LoginStatus.CLIENT_ALREADY_CONNECTED;
		}
		if (addNewUserCase(connectionId, username, password)) {
			// Log new user registration in SQL
			String sql = String.format(
				"INSERT INTO users (username, password, registration_date) VALUES ('%s', '%s', datetime('now'))",
				escapeSql(username), escapeSql(password)
			);
			executeSQL(sql);
			
			// Log login
			logLogin(username);
			return LoginStatus.ADDED_NEW_USER;
		} else {
			LoginStatus status = userExistsCase(connectionId, username, password);
			if (status == LoginStatus.LOGGED_IN_SUCCESSFULLY) {
				// Log successful login in SQL
				logLogin(username);
			}
			return status;
		}
	}

	private void logLogin(String username) {
		String sql = String.format(
			"INSERT INTO login_history (username, login_time) VALUES ('%s', datetime('now'))",
			escapeSql(username)
		);
		executeSQL(sql);
	}

	private LoginStatus userExistsCase(int connectionId, String username, String password) {
		User user = userMap.get(username);
		synchronized (user) {
			if (user.isLoggedIn()) {
				return LoginStatus.ALREADY_LOGGED_IN;
			} else if (!user.password.equals(password)) {
				return LoginStatus.WRONG_PASSWORD;
			} else {
				user.login();
				user.setConnectionId(connectionId);
				connectionsIdMap.put(connectionId, user);
				return LoginStatus.LOGGED_IN_SUCCESSFULLY;
			}
		}
	}

	private boolean addNewUserCase(int connectionId, String username, String password) {
		if (!userMap.containsKey(username)) {
			synchronized (userMap) {
				if (!userMap.containsKey(username)) {
					User user = new User(connectionId, username, password);
					user.login();
					addUser(user);
					return true;
				}
			}
		}
		return false;
	}

	public void logout(int connectionsId) {
		User user = connectionsIdMap.get(connectionsId);
		if (user != null) {
			// Log logout in SQL
			String sql = String.format(
				"UPDATE login_history SET logout_time=datetime('now') " +
				"WHERE username='%s' AND logout_time IS NULL " +
				"ORDER BY login_time DESC LIMIT 1",
				escapeSql(user.name)
			);
			executeSQL(sql);
			
			user.logout();
			connectionsIdMap.remove(connectionsId);
		}
	}

	/**
	 * Track file upload in SQL database
	 * @param username User who uploaded the file
	 * @param filename Name of the file
	 * @param gameChannel Game channel the file was reported to
	 */
	public void trackFileUpload(String username, String filename, String gameChannel) {
		String sql = String.format(
			"INSERT INTO file_tracking (username, filename, upload_time, game_channel) " +
			"VALUES ('%s', '%s', datetime('now'), '%s')",
			escapeSql(username), escapeSql(filename), escapeSql(gameChannel)
		);
		executeSQL(sql);
	}

	/**
	 * Generate and print server report using SQL queries
	 */
	public void printReport() {
		System.out.println(repeat("=", 80));
		System.out.println("SERVER REPORT - Generated at: " + java.time.LocalDateTime.now());
		System.out.println(repeat("=", 80));
		
		// List all users
		System.out.println("\n1. REGISTERED USERS:");
		System.out.println(repeat("-", 80));
		String usersSQL = "SELECT username, registration_date FROM users ORDER BY registration_date";
		String usersResult = executeSQL(usersSQL);
		if (usersResult.startsWith("SUCCESS")) {
			String[] parts = usersResult.split("\\|");
			if (parts.length > 1) {
				for (int i = 1; i < parts.length; i++) {
					System.out.println("   " + parts[i]);
				}
			} else {
				System.out.println("   No users registered");
			}
		}
		
		// Login history for each user
		System.out.println("\n2. LOGIN HISTORY:");
		System.out.println(repeat("-", 80));
		String loginSQL = "SELECT username, login_time, logout_time FROM login_history ORDER BY username, login_time DESC";
		String loginResult = executeSQL(loginSQL);
		if (loginResult.startsWith("SUCCESS")) {
			String[] parts = loginResult.split("\\|");
			if (parts.length > 1) {
				String currentUser = "";
				for (int i = 1; i < parts.length; i++) {
					String[] fields = parts[i].replace("(", "").replace(")", "").replace("'", "").split(", ");
					if (fields.length >= 3) {
						if (!fields[0].equals(currentUser)) {
							currentUser = fields[0];
							System.out.println("\n   User: " + currentUser);
						}
						System.out.println("      Login:  " + fields[1]);
						System.out.println("      Logout: " + (fields[2].equals("None") ? "Still logged in" : fields[2]));
					}
				}
			} else {
				System.out.println("   No login history");
			}
		}
		
		// File uploads for each user
		System.out.println("\n3. FILE UPLOADS:");
		System.out.println(repeat("-", 80));
		String filesSQL = "SELECT username, filename, upload_time, game_channel FROM file_tracking ORDER BY username, upload_time DESC";
		String filesResult = executeSQL(filesSQL);
		if (filesResult.startsWith("SUCCESS")) {
			String[] parts = filesResult.split("\\|");
			if (parts.length > 1) {
				String currentUser = "";
				for (int i = 1; i < parts.length; i++) {
					String[] fields = parts[i].replace("(", "").replace(")", "").replace("'", "").split(", ");
					if (fields.length >= 4) {
						if (!fields[0].equals(currentUser)) {
							currentUser = fields[0];
							System.out.println("\n   User: " + currentUser);
						}
						System.out.println("      File: " + fields[1]);
						System.out.println("      Time: " + fields[2]);
						System.out.println("      Game: " + fields[3]);
						System.out.println();
					}
				}
			} else {
				System.out.println("   No files uploaded");
			}
		}
		
	System.out.println(repeat("=", 80));
}

private String repeat(String str, int times) {
	StringBuilder sb = new StringBuilder();
	for (int i = 0; i < times; i++) {
		sb.append(str);
	}
	return sb.toString();
}

private static class Instance {
	static Database instance = new Database();
}}

---File: ./server/src/main/java/bgu/spl/net/impl/data/LoginStatus.java---
package bgu.spl.net.impl.data;

public enum LoginStatus {
	CLIENT_ALREADY_CONNECTED, ADDED_NEW_USER, ALREADY_LOGGED_IN, LOGGED_IN_SUCCESSFULLY, WRONG_PASSWORD
}


---File: ./server/src/main/java/bgu/spl/net/impl/data/User.java---
package bgu.spl.net.impl.data;

public class User {
	public final String name;
	public final String password;
	private int connectionId;
	private boolean isLoggedIn = false;

	public User(int connectionId, String name, String password) {
		this.connectionId = connectionId;
		this.name = name;
		this.password = password;
	}

	public boolean isLoggedIn() {
		return isLoggedIn;
	}

	public void login() {
		isLoggedIn = true;
	}

	public void logout() {
		isLoggedIn = false;
	}

	public int getConnectionId() {
		return connectionId;
	}

	public void setConnectionId(int connectionId) {
		this.connectionId = connectionId;
	}


}


---File: ./server/src/main/java/bgu/spl/net/impl/echo/EchoClient.java---
package bgu.spl.net.impl.echo;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;

public class EchoClient {

    public static void main(String[] args) throws IOException {

        if (args.length == 0) {
            args = new String[]{"localhost", "hello"};
        }

        if (args.length < 2) {
            System.out.println("you must supply two arguments: host, message");
            System.exit(1);
        }

        //BufferedReader and BufferedWriter automatically using UTF-8 encoding
        try (Socket sock = new Socket(args[0], 7777);
                BufferedReader in = new BufferedReader(new InputStreamReader(sock.getInputStream()));
                BufferedWriter out = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()))) {

            System.out.println("sending message to server");
            out.write(args[1]);
            out.newLine();
            out.flush();

            System.out.println("awaiting response");
            String line = in.readLine();
            System.out.println("message from server: " + line);
        }
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/echo/EchoProtocol.java---
package bgu.spl.net.impl.echo;

import bgu.spl.net.api.MessagingProtocol;
import java.time.LocalDateTime;

public class EchoProtocol implements MessagingProtocol<String> {

    private boolean shouldTerminate = false;

    @Override
    public String process(String msg) {
        shouldTerminate = "bye".equals(msg);
        System.out.println("[" + LocalDateTime.now() + "]: " + msg);
        return createEcho(msg);
    }

    private String createEcho(String message) {
        String echoPart = message.substring(Math.max(message.length() - 2, 0), message.length());
        return message + " .. " + echoPart + " .. " + echoPart + " ..";
    }

    @Override
    public boolean shouldTerminate() {
        return shouldTerminate;
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/echo/EchoServer.java---
package bgu.spl.net.impl.echo;

import bgu.spl.net.srv.Server;

public class EchoServer {

    public static void main(String[] args) {

        // you can use any server... 
        Server.threadPerClient(
                7777, //port
                () -> new EchoProtocol(), //protocol factory
                LineMessageEncoderDecoder::new //message encoder decoder factory
        ).serve();

        // Server.reactor(
        //         Runtime.getRuntime().availableProcessors(),
        //         7777, //port
        //         () -> new EchoProtocol<>(), //protocol factory
        //         LineMessageEncoderDecoder::new //message encoder decoder factory
        // ).serve();
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/echo/LineMessageEncoderDecoder.java---
package bgu.spl.net.impl.echo;

import bgu.spl.net.api.MessageEncoderDecoder;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;

public class LineMessageEncoderDecoder implements MessageEncoderDecoder<String> {

    private byte[] bytes = new byte[1 << 10]; //start with 1k
    private int len = 0;

    @Override
    public String decodeNextByte(byte nextByte) {
        //notice that the top 128 ascii characters have the same representation as their utf-8 counterparts
        //this allow us to do the following comparison
        if (nextByte == '\n') {
            return popString();
        }

        pushByte(nextByte);
        return null; //not a line yet
    }

    @Override
    public byte[] encode(String message) {
        return (message + "\n").getBytes(); //uses utf8 by default
    }

    private void pushByte(byte nextByte) {
        if (len >= bytes.length) {
            bytes = Arrays.copyOf(bytes, len * 2);
        }

        bytes[len++] = nextByte;
    }

    private String popString() {
        //notice that we explicitly requesting that the string will be decoded from UTF-8
        //this is not actually required as it is the default encoding in java.
        String result = new String(bytes, 0, len, StandardCharsets.UTF_8);
        len = 0;
        return result;
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/newsfeed/FetchNewsCommand.java---
package bgu.spl.net.impl.newsfeed;

import bgu.spl.net.impl.rci.Command;
import java.io.Serializable;

public class FetchNewsCommand implements Command<NewsFeed> {

    private String channel;

    public FetchNewsCommand(String channel) {
        this.channel = channel;
    }

    @Override
    public Serializable execute(NewsFeed feed) {
        return feed.fetch(channel);
    }

}


---File: ./server/src/main/java/bgu/spl/net/impl/newsfeed/NewsFeed.java---
package bgu.spl.net.impl.newsfeed;

import java.util.ArrayList;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

public class NewsFeed {

    private ConcurrentHashMap<String, ConcurrentLinkedQueue<String>> channels = new ConcurrentHashMap<>();

    public ArrayList<String> fetch(String channel) {
        ConcurrentLinkedQueue<String> queue = channels.get(channel);
        if (queue == null) {
            return new ArrayList<>(0); //empty
        } else {
            return new ArrayList<>(queue); //copy of the queue, arraylist is serializable
        }
    }

    public void publish(String channel, String news) {
        ConcurrentLinkedQueue<String> queue = channels.computeIfAbsent(channel, k -> new ConcurrentLinkedQueue<>());
        queue.add(news);
    }

    public void clear() {
        channels.clear();
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/newsfeed/NewsFeedClientMain.java---
package bgu.spl.net.impl.newsfeed;

import bgu.spl.net.impl.rci.RCIClient;

public class NewsFeedClientMain {

    public static void main(String[] args) throws Exception {
        if (args.length == 0) {
            args = new String[]{"127.0.0.1"};
        }

//        System.out.println("running clients");
        runFirstClient(args[0]);
        runSecondClient(args[0]);
        runThirdClient(args[0]);
    }

    private static void runFirstClient(String host) throws Exception {
        try (RCIClient c = new RCIClient(host, 7777)) {
            c.send(new PublishNewsCommand(
                    "jobs",
                    "System Programmer, knowledge in C++, Java and Python required. call 0x134693F"));

            c.receive(); //ok

            c.send(new PublishNewsCommand(
                    "headlines",
                    "new SPL assignment is out soon!!"));

            c.receive(); //ok

            c.send(new PublishNewsCommand(
                    "headlines",
                    "THE CAKE IS A LIE!"));

            c.receive(); //ok
        }

    }

    private static void runSecondClient(String host) throws Exception {
        try (RCIClient c = new RCIClient(host, 7777)) {
            c.send(new FetchNewsCommand("jobs"));
            System.out.println("second client received: " + c.receive());
        }
    }

    private static void runThirdClient(String host) throws Exception {
        try (RCIClient c = new RCIClient(host, 7777)) {
            c.send(new FetchNewsCommand("headlines"));
            System.out.println("third client received: " + c.receive());
        }
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/newsfeed/NewsFeedServerMain.java---
package bgu.spl.net.impl.newsfeed;

import bgu.spl.net.impl.rci.ObjectEncoderDecoder;
import bgu.spl.net.impl.rci.RemoteCommandInvocationProtocol;
import bgu.spl.net.srv.Server;

public class NewsFeedServerMain {

    public static void main(String[] args) {
        NewsFeed feed = new NewsFeed(); //one shared object

        // you can use any server... 
        Server.threadPerClient(
                7777, //port
                () -> new RemoteCommandInvocationProtocol<>(feed), //protocol factory
                ObjectEncoderDecoder::new //message encoder decoder factory
        ).serve();

        // Server.reactor(
        //         Runtime.getRuntime().availableProcessors(),
        //         7777, //port
        //         () ->  new RemoteCommandInvocationProtocol<>(feed), //protocol factory
        //         ObjectEncoderDecoder::new //message encoder decoder factory
        // ).serve();
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/newsfeed/PublishNewsCommand.java---
package bgu.spl.net.impl.newsfeed;

import bgu.spl.net.impl.rci.Command;
import java.io.Serializable;

public class PublishNewsCommand implements Command<NewsFeed> {
 
    private String channel;
    private String news;
 
    public PublishNewsCommand(String channel, String news) {
        this.channel = channel;
        this.news = news;
    }
 
    @Override
    public Serializable execute(NewsFeed feed) {
        feed.publish(channel, news);
        return "OK";
    }
 
}

---File: ./server/src/main/java/bgu/spl/net/impl/rci/Command.java---
package bgu.spl.net.impl.rci;

import java.io.Serializable;

public interface Command<T> extends Serializable {

    Serializable execute(T arg);
}


---File: ./server/src/main/java/bgu/spl/net/impl/rci/ObjectEncoderDecoder.java---
package bgu.spl.net.impl.rci;

import bgu.spl.net.api.MessageEncoderDecoder;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.nio.ByteBuffer;

public class ObjectEncoderDecoder implements MessageEncoderDecoder<Serializable> {

    private final ByteBuffer lengthBuffer = ByteBuffer.allocate(4);
    private byte[] objectBytes = null;
    private int objectBytesIndex = 0;

    @Override
    public Serializable decodeNextByte(byte nextByte) {
        if (objectBytes == null) { //indicates that we are still reading the length
            lengthBuffer.put(nextByte);
            if (!lengthBuffer.hasRemaining()) { //we read 4 bytes and therefore can take the length
                lengthBuffer.flip();
                objectBytes = new byte[lengthBuffer.getInt()];
                objectBytesIndex = 0;
                lengthBuffer.clear();
            }
        } else {
            objectBytes[objectBytesIndex] = nextByte;
            if (++objectBytesIndex == objectBytes.length) {
                Serializable result = deserializeObject();
                objectBytes = null;
                return result;
            }
        }

        return null;
    }

    @Override
    public byte[] encode(Serializable message) {
        return serializeObject(message);
    }

    private Serializable deserializeObject() {
        try {
            ObjectInput in = new ObjectInputStream(new ByteArrayInputStream(objectBytes));
            return (Serializable) in.readObject();
        } catch (Exception ex) {
            throw new IllegalArgumentException("cannot desrialize object", ex);
        }

    }

    private byte[] serializeObject(Serializable message) {
        try {
            ByteArrayOutputStream bytes = new ByteArrayOutputStream();

            //placeholder for the object size
            for (int i = 0; i < 4; i++) {
                bytes.write(0);
            }

            ObjectOutput out = new ObjectOutputStream(bytes);
            out.writeObject(message);
            out.flush();
            byte[] result = bytes.toByteArray();

            //now write the object size
            ByteBuffer.wrap(result).putInt(result.length - 4);
            return result;

        } catch (Exception ex) {
            throw new IllegalArgumentException("cannot serialize object", ex);
        }
    }

}


---File: ./server/src/main/java/bgu/spl/net/impl/rci/RCIClient.java---
package bgu.spl.net.impl.rci;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.Closeable;
import java.io.IOException;
import java.io.Serializable;
import java.net.Socket;

public class RCIClient implements Closeable {

    private final ObjectEncoderDecoder encdec;
    private final Socket sock;
    private final BufferedInputStream in;
    private final BufferedOutputStream out;

    public RCIClient(String host, int port) throws IOException {
        sock = new Socket(host, port);
        encdec = new ObjectEncoderDecoder();
        in = new BufferedInputStream(sock.getInputStream());
        out = new BufferedOutputStream(sock.getOutputStream());
    }

    public void send(Command<?> cmd) throws IOException {
        out.write(encdec.encode(cmd));
        out.flush();
    }

    public Serializable receive() throws IOException {
        int read;
        while ((read = in.read()) >= 0) {
            Serializable msg = encdec.decodeNextByte((byte) read);
            if (msg != null) {
                return msg;
            }
        }

        throw new IOException("disconnected before complete reading message");
    }

    @Override
    public void close() throws IOException {
        out.close();
        in.close();
        sock.close();
    }

}


---File: ./server/src/main/java/bgu/spl/net/impl/rci/RemoteCommandInvocationProtocol.java---
package bgu.spl.net.impl.rci;

import bgu.spl.net.api.MessagingProtocol;
import java.io.Serializable;

public class RemoteCommandInvocationProtocol<T> implements MessagingProtocol<Serializable> {

    private T arg;

    public RemoteCommandInvocationProtocol(T arg) {
        this.arg = arg;
    }

    @Override
    public Serializable process(Serializable msg) {
        return ((Command) msg).execute(arg);
    }

    @Override
    public boolean shouldTerminate() {
        return false;
    }

}


---File: ./server/src/main/java/bgu/spl/net/impl/stomp/StompFrame.java---
package bgu.spl.net.impl.stomp;

import java.util.HashMap;
import java.util.Map;

public class StompFrame {
    private String command;
    private Map<String,String> headers = new HashMap<>();
    private String body;

    public StompFrame(String commands) {
        this.command = commands;
    }
    public StompFrame(StompFrame other) {
        this.command = other.command;
        this.headers = new HashMap<>(other.headers);
        this.body = other.body;
    }
    public String getCommand() {
        return command;
    }
    public void addHeader(String key, String value) {
        headers.put(key, value);
    }
    public String getHeader(String key) {
        return headers.get(key);
    }
    public void setBody(String body) {
        this.body = body;
    }
    public String getBody() {
        return this.body;
    }

    public static StompFrame fromString(String rawMessage) {
        StompFrame ret = null;
        int i = 0;

        if (rawMessage == null || rawMessage.length() == 0) {
            return null;
        }

        String[] lines = rawMessage.split("\n");

        // COMMAND
        ret = new StompFrame(lines[i].trim());
        i++;

        // HEADERS - until end of lines or an empty line
        for (i = 1; i < lines.length && !lines[i].isEmpty(); i++) {
            String[] parts = lines[i].split(":", 2);
            // Add new Header to frame
            if (parts.length == 2) {
                ret.addHeader(parts[0].trim(), parts[1].trim());
            }
        }

        // BODY - build body until end of message
        StringBuilder bodyBuilder = new StringBuilder();

        // if we got to an empty line
        if (i != lines.length) {
            i++; // continuing after empty line
            for (; i < lines.length; i++) {
                bodyBuilder.append(lines[i]);

                // add new line
                if (i < lines.length - 1) {
                    bodyBuilder.append("\n");
                }
            }
        }

        ret.setBody(bodyBuilder.toString());

        return ret;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();

        // 1. Command
        sb.append(command).append("\n");

        // 2. Headers
        for (Map.Entry<String, String> header : headers.entrySet()) {
            sb.append(header.getKey())
                    .append(":")
                    .append(header.getValue())
                    .append("\n");
        }

        // 3. Empty Line - SEPARATION
        sb.append("\n");

        // 4. Body
        if (body != null && !body.isEmpty()) {
            sb.append(body);
        }

        return sb.toString();
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/stomp/StompMessageEncoderDecoder.java---
package bgu.spl.net.impl.stomp;

import bgu.spl.net.api.MessageEncoderDecoder;

public class StompMessageEncoderDecoder implements MessageEncoderDecoder<StompFrame> {
    private byte[] bytes = new byte[1024];
    private int len = 0;
    private static final int MAX_MESSAGE_SIZE = 1 << 20;
    @Override
    public StompFrame decodeNextByte(byte nextByte) {
        if(nextByte == '\0'){
            System.err.println("\n DEBUG: Decoder found NULL char. Buffer len: " + len);
            return popMessage();
        }
        pushByte(nextByte);
        return null;
    }

    private void pushByte(byte nextByte) {
        if (len >= MAX_MESSAGE_SIZE) {
            throw new RuntimeException("Message size limit exceeded");
        }
        // if needed, resize the array
        if (len >= bytes.length) {
            //double the size of the array
            bytes = java.util.Arrays.copyOf(bytes, len * 2);
        }
        bytes[len++] = nextByte;   
    }
    // when we get here we have a full message
    private StompFrame popMessage() {
        String message = new String(bytes,0,len, java.nio.charset.StandardCharsets.UTF_8);
        len = 0;
        return StompFrame.fromString(message);
    }

    @Override
    public byte[] encode(StompFrame message) {
        StringBuilder strMessage = new StringBuilder(message.toString());
        strMessage.append('\0');
        return strMessage.toString().getBytes(java.nio.charset.StandardCharsets.UTF_8);
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/stomp/StompMessagingProtocolImpl.java---
package bgu.spl.net.impl.stomp;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import bgu.spl.net.impl.data.Database;
import bgu.spl.net.api.StompMessagingProtocol;
import bgu.spl.net.impl.data.LoginStatus;
import bgu.spl.net.srv.Connections;

public class StompMessagingProtocolImpl implements StompMessagingProtocol<StompFrame> {
    private int connectionId;
    private Connections<StompFrame> connections;
    private boolean shouldTerminate = false;
    private boolean isLoggedIn = false;
    private String currentUser = null;
    private Map<String, String> subscriptions = new ConcurrentHashMap<>();
    private static AtomicInteger messageIdCounter = new AtomicInteger(0);

    @Override
    public void start(int connectionId, Connections<StompFrame> connections) {
        this.connectionId = connectionId;
        this.connections = connections;
    }
    @Override
    public StompFrame process(StompFrame frame) {
        System.out.println(" DEBUG [SERVER RCV from " + connectionId + "]:\n" + frame.toString());
        System.out.println("----------------------------------------");
        String command = frame.getCommand();
        // Check if user is logged in for commands other than CONNECT
        if(!isLoggedIn && !command.equals("CONNECT")) {
            sendError(frame, "User not logged in", "You must log in before sending other commands.");
        }
        else{
            switch (command) {
                case "CONNECT":
                    handleConnect(frame);
                    break;
                case "SEND":
                    handleSend(frame);
                    break;
                case "SUBSCRIBE":
                    handleSubscribe(frame);
                    break;
                case "UNSUBSCRIBE":
                    handleUnsubscribe(frame);
                    break;
                case "DISCONNECT":
                    handleDisconnect(frame);
                    break;
                default:
                    sendError(frame, "Unknown command", "The command '" + command + "' is not recognized.");
                    shouldTerminate = true;
                    break;
        }
    }
    return null;
}

    private void handleDisconnect(StompFrame frame) {
        if (!isLoggedIn) {
            sendError(frame, "Not logged in", "You must be logged in to disconnect.");
            return;
        }

        String receipt = frame.getHeader("receipt");
        if (receipt != null) {
            sendReceipt(receipt);
        }

        // Perform logout
        Database.getInstance().logout(connectionId);
        this.shouldTerminate = true;
    }
    private void handleUnsubscribe(StompFrame frame) {
        if (!isLoggedIn) {
            sendError(frame, "Not logged in", "You must be logged in to unsubscribe.");
            return;
        }

        String requestId = frame.getHeader("id");

        if (requestId == null || requestId.isEmpty()) {
            sendError(frame, "Malformed UNSUBSCRIBE", "Missing 'id' header.");
            return;
        }
        // Check if subscribed with the given id
        String destination = subscriptions.remove(requestId);
        if (destination == null) {
            sendError(frame, "Subscription not found", "No active subscription found with ID: " + requestId);
            return;
        }

        connections.unsubscribe(destination, connectionId, requestId);

        // Handle receipt if requested
        String receipt = frame.getHeader("receipt");
        if (receipt != null) {
            sendReceipt(receipt);
        }
    }
    private void handleSubscribe(StompFrame frame) {
        System.err.println("DEBUG Handling SUBSCRIBE frame");
        if (!isLoggedIn) {
            sendError(frame, "Not logged in", "You must be logged in to subscribe.");
            return;
        }

        String destination = frame.getHeader("destination");
        String requestId = frame.getHeader("id");

        if (destination == null || destination.isEmpty() || requestId == null || requestId.isEmpty()) {
            sendError(frame, "Malformed SUBSCRIBE", "Missing 'destination' or 'id' header.");            return;
        }

        // Check if already subscribed with the same id
        if (subscriptions.containsKey(requestId)) {
            sendError(frame, "Already subscribed", "You are already subscribed with id '" + requestId + "'.");
            return;
        }

        subscriptions.put(requestId, destination);
        
        connections.subscribe(destination, connectionId, requestId);

        // Handle receipt if requested
        String receipt = frame.getHeader("receipt");
        if (receipt != null) {
            sendReceipt(receipt);
        }
    }
    private void handleSend(StompFrame frame) {
        if (!isLoggedIn) {
            sendError(frame, "Not logged in", "You must be logged in to send messages.");
            return;
        }

        String destination = frame.getHeader("destination");
        if (destination == null || destination.isEmpty()) {
            sendError(frame, "Missing destination", "SEND frame must include a destination header.");
            return;
        }

        if (!subscriptions.containsValue(destination)) {
            sendError(frame, "Not subscribed", "You cannot send to '" + destination + "' without subscribing first.");
            return;
        }

        /*// Track file upload if 'file-name' header is present
        String filename = frame.getHeader("file-name"); 
        if (filename != null) {
            Database.getInstance().trackFileUpload(currentUser, filename, destination);
        }*/

        StompFrame messageFrame = new StompFrame("MESSAGE");
        messageFrame.addHeader("destination", destination);
        messageFrame.addHeader("message-id", String.valueOf(messageIdCounter.incrementAndGet()));
        // Copy the body and content (Game updates, user, team names, etc.)
        // We don't validate them, we just pass them through.
        messageFrame.setBody(frame.getBody());

        // Send the MESSAGE frame (not the SEND frame)
        connections.send(destination, messageFrame);

        // Handle receipt if requested
        String receipt = frame.getHeader("receipt");
        if (receipt != null) {
            sendReceipt(receipt);
        }
}
    private void handleConnect(StompFrame frame) {
        if(isLoggedIn) {
            sendError(frame, "Already logged in", "You are already logged in.");
            return;
        }
        String username = frame.getHeader("login");
        String passcode = frame.getHeader("passcode");
        String acceptVersion = frame.getHeader("accept-version");
        String host = frame.getHeader("host");

        if (username == null || passcode == null || host == null) {
            sendError(frame, "Missing credentials", "Login or passcode header is missing.");
            return;
        }
        
        LoginStatus status = Database.getInstance().login(connectionId, username, passcode);
        switch (status) {
            case LOGGED_IN_SUCCESSFULLY:
            case ADDED_NEW_USER:
                this.currentUser = username;
                sendConnectedFrame();
                break;
            case CLIENT_ALREADY_CONNECTED:
                sendError(frame, "Client already connected", "This client is already connected.");
                break;
            case ALREADY_LOGGED_IN:
                sendError(frame, "Already logged in", "This user is already logged in.");
                break;
            case WRONG_PASSWORD:
                sendError(frame, "Wrong password", "The passcode you entered is incorrect.");
                break;
            default:
                sendError(frame, "Login failed", "Login failed due to unknown reasons.");
                break;
        }
    }
    @Override
    public boolean shouldTerminate() {
        return shouldTerminate;
    }
    private void sendConnectedFrame() {
        this.isLoggedIn = true;
        StompFrame connectedFrame = new StompFrame("CONNECTED");
        connectedFrame.addHeader("version", "1.2");
        connections.send(connectionId, connectedFrame);
    }
/**
 * Sends a RECEIPT frame to acknowledge that a command with a receipt header was processed.
 * @param receiptId The receipt ID from the original frame's receipt header.
 */
private void sendReceipt(String receiptId) {
    StompFrame receiptFrame = new StompFrame("RECEIPT");
    receiptFrame.addHeader("receipt-id", receiptId);
    connections.send(connectionId, receiptFrame);
}

/**
 * Sends an ERROR frame in the specific format required by the assignment and closes the connection.
 * * @param faultyFrame The original frame that caused the error (used to extract receipt-id and print in body).
 * @param messageHeader A short description of the error (goes into the 'message' header).
 * @param detailedInfo A detailed explanation (goes into the body).
 */
private void sendError(StompFrame faultyFrame, String messageHeader, String detailedInfo) {
    StompFrame errorFrame = new StompFrame("ERROR");

    errorFrame.addHeader("message", messageHeader);

    if (faultyFrame != null) {
        String receipt = faultyFrame.getHeader("receipt");
        if (receipt != null) {
            errorFrame.addHeader("receipt-id", receipt);
        }
    }

    // Construct the body in the requested format
    StringBuilder body = new StringBuilder();
    body.append("The message:\n");
    body.append("-----\n");
    
    if (faultyFrame != null) {
        // Assuming your StompFrame.toString() returns the frame representation (Command + Headers + Body)
        body.append(faultyFrame.toString()); 
    } else {
        body.append("(No frame content available)");
    }
    
    body.append("\n-----\n");
    body.append(detailedInfo);
    errorFrame.setBody(body.toString());
    connections.send(connectionId, errorFrame);
    
    if (isLoggedIn) {
        Database.getInstance().logout(connectionId);
        isLoggedIn = false;
        currentUser = null;
    }
    this.shouldTerminate = true;
    connections.disconnect(connectionId);
}
}

---File: ./server/src/main/java/bgu/spl/net/impl/stomp/StompServer.java---
package bgu.spl.net.impl.stomp;

import bgu.spl.net.srv.Server;

public class StompServer {

    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println("Usage: StompServer <port> <server-type>");
            System.out.println("server-type: tpc (Thread Per Client) or reactor");
            return;
        }

        int port = 0;
        try {
            port = Integer.parseInt(args[0]);
        } catch (NumberFormatException e) {
            System.out.println("Error: Port must be a number.");
            return;
        }

        String serverType = args[1];

        if (serverType.equals("tpc")) {
            System.err.println("DEBUG Starting Stomp Server in Thread Per Client mode");
            Server.threadPerClient(
                    port,
                    () -> new StompMessagingProtocolImpl(), // Protocol Factory 
                    () -> new StompMessageEncoderDecoder()         // Encoder Factory
            ).serve();

        } else if (serverType.equals("reactor")) {
            Server.reactor(
                    Runtime.getRuntime().availableProcessors(),
                    port,
                    () -> new StompMessagingProtocolImpl(), // Protocol Factory (Lambda)
                    () -> new StompMessageEncoderDecoder()         // Encoder Factory (Lambda)
            ).serve();

        } else {
            System.out.println("Unknown server type: " + serverType);
            System.out.println("Please use 'tpc' or 'reactor'.");
        }
    }
}


---File: ./server/src/main/java/bgu/spl/net/impl/stomp/StompTestClient.java---
import java.io.OutputStream;
import java.net.Socket;
import java.nio.charset.StandardCharsets;

public class StompTestClient {
    public static void main(String[] args) throws Exception {
        Socket socket = new Socket("localhost", 7777);
        OutputStream out = socket.getOutputStream();

        String frame =
                "CONNECT\n" +
                "accept-version :1.2\n" +
                "host:stomp.cs.bgu.ac.il\n" +
                "login:alice\n" +
                "passcode:123\n" +
                "\n";

        out.write(frame.getBytes(StandardCharsets.UTF_8));
        out.write(0); // STOMP null character
        out.flush();

        Thread.sleep(5000);
        socket.close();
    }
}


---File: ./server/src/main/java/bgu/spl/net/srv/ActorThreadPool.java---
package bgu.spl.net.srv;

import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ActorThreadPool {

    private final Map<Object, Queue<Runnable>> acts;
    private final ReadWriteLock actsRWLock;
    private final Set<Object> playingNow;
    private final ExecutorService threads;

    public ActorThreadPool(int threads) {
        this.threads = Executors.newFixedThreadPool(threads);
        acts = new WeakHashMap<>();
        playingNow = ConcurrentHashMap.newKeySet();
        actsRWLock = new ReentrantReadWriteLock();
    }

    public void submit(Object act, Runnable r) {
        synchronized (act) {
            if (!playingNow.contains(act)) {
                playingNow.add(act);
                execute(r, act);
            } else {
                pendingRunnablesOf(act).add(r);
            }
        }
    }

    public void shutdown() {
        threads.shutdownNow();
    }

    private Queue<Runnable> pendingRunnablesOf(Object act) {

        actsRWLock.readLock().lock();
        Queue<Runnable> pendingRunnables = acts.get(act);
        actsRWLock.readLock().unlock();

        if (pendingRunnables == null) {
            actsRWLock.writeLock().lock();
            acts.put(act, pendingRunnables = new LinkedList<>());
            actsRWLock.writeLock().unlock();
        }
        return pendingRunnables;
    }

    private void execute(Runnable r, Object act) {
        threads.execute(() -> {
            try {
                r.run();
            } finally {
                complete(act);
            }
        });
    }

    private void complete(Object act) {
        synchronized (act) {
            Queue<Runnable> pending = pendingRunnablesOf(act);
            if (pending.isEmpty()) {
                playingNow.remove(act);
            } else {
                execute(pending.poll(), act);
            }
        }
    }

}


---File: ./server/src/main/java/bgu/spl/net/srv/BaseServer.java---
package bgu.spl.net.srv;

import bgu.spl.net.api.MessageEncoderDecoder;
import bgu.spl.net.api.MessagingProtocol;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.function.Supplier;
import java.util.concurrent.atomic.AtomicInteger;

public abstract class BaseServer<T> implements Server<T> {

    private final int port;
    private final Supplier<MessagingProtocol<T>> protocolFactory;
    private final Supplier<MessageEncoderDecoder<T>> encdecFactory;
    private ServerSocket sock;
    private final ConnectionsImpl<T> connections = new ConnectionsImpl<>();
    private final AtomicInteger connectionIdCounter = new AtomicInteger(0);

    public BaseServer(
            int port,
            Supplier<MessagingProtocol<T>> protocolFactory,
            Supplier<MessageEncoderDecoder<T>> encdecFactory) {

        this.port = port;
        this.protocolFactory = protocolFactory;
        this.encdecFactory = encdecFactory;
		this.sock = null;
    }

    @Override
    public void serve() {

        try (ServerSocket serverSock = new ServerSocket(port)) {
			System.out.println("Server started");

            this.sock = serverSock; //just to be able to close

            while (!Thread.currentThread().isInterrupted()) {

                Socket clientSock = serverSock.accept();
                int connectionId = connectionIdCounter.incrementAndGet();

                BlockingConnectionHandler<T> handler = new BlockingConnectionHandler<>(
                        clientSock,
                        encdecFactory.get(),
                        protocolFactory.get(),
                        connectionId,
                        connections
                );
                
                connections.addConnection(connectionId, handler);
                execute(handler);
            }
        } catch (IOException ex) {
        }

        System.out.println("server closed!!!");
    }

    @Override
    public void close() throws IOException {
		if (sock != null)
			sock.close();
    }

    protected abstract void execute(BlockingConnectionHandler<T>  handler);

}


---File: ./server/src/main/java/bgu/spl/net/srv/BlockingConnectionHandler.java---
package bgu.spl.net.srv;

import bgu.spl.net.api.MessageEncoderDecoder;
import bgu.spl.net.api.StompMessagingProtocol;
import bgu.spl.net.api.MessagingProtocol;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.net.Socket;

public class BlockingConnectionHandler<T> implements Runnable, ConnectionHandler<T> {

    private final StompMessagingProtocol<T> protocol;
    private final MessageEncoderDecoder<T> encdec;
    private final Socket sock;
    private BufferedInputStream in;
    private BufferedOutputStream out;
    private volatile boolean connected = true;

    private final int connectionId;
    private final ConnectionsImpl<T> connections;

    public BlockingConnectionHandler(Socket sock, MessageEncoderDecoder<T> reader, MessagingProtocol<T> protocol, int connectionId, ConnectionsImpl<T> connections) {
        this.sock = sock;
        this.encdec = reader;

        // Cast to StompMessagingProtocol
        if (protocol instanceof StompMessagingProtocol) {
            this.protocol = (StompMessagingProtocol<T>) protocol;
        } else {
            throw new IllegalArgumentException("Protocol must implement StompMessagingProtocol");
        }
        
        this.connectionId = connectionId;
        this.connections = connections;
    }

    @Override
    public void run() {
        try (Socket sock = this.sock) { //just for automatic closing
            int read;

            in = new BufferedInputStream(sock.getInputStream());
            out = new BufferedOutputStream(sock.getOutputStream());

            // Initialize protocol with connectionId and connections
            protocol.start(connectionId, connections);
            System.err.println("DEBUG: Handler started for ID " + connectionId);

            while (!protocol.shouldTerminate() && connected && (read = in.read()) >= 0) {
                // --- DEBUG: Stampa ogni byte ricevuto ---
                // Se il byte  \0 scriviamo [NULL], se  \n scriviamo [LF], altrimenti il char
                if (read == 0) System.err.print("[NULL]");//DEBUG
                else if (read == 10) System.err.print("[LF]");//DEBUG
                else if (read == 13) System.err.print("[CR]");//DEBUG
                else System.err.print((char)read);//DEBUG
                // ----------------------------------------
                T nextMessage = encdec.decodeNextByte((byte) read);
                if (nextMessage != null) {
                    // Process message (no response needed - protocol uses connections.send())
                    protocol.process(nextMessage);
                    /*if (response != null) {
                        out.write(encdec.encode(response));
                        out.flush();
                    }*/
                }
            }

        } catch (IOException ex) {
            ex.printStackTrace();
        }
        catch(RuntimeException ex){
            System.err.println("\nCRITICAL ERROR in Handler: " + ex.getMessage());
            ex.printStackTrace();
        }

    }

    @Override
    public void close() throws IOException {
        connected = false;
        sock.close();
    }

    @Override
    public void send(T msg) {
         try {
            if (out != null && connected) {
                synchronized (out) {
                    System.out.println(" DEBUG [SERVER SND]: " + msg.toString()); // Decommenta se serve
                    out.write(encdec.encode(msg));
                    out.flush();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


---File: ./server/src/main/java/bgu/spl/net/srv/ConnectionHandler.java---
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package bgu.spl.net.srv;

import java.io.Closeable;

/**
 * The ConnectionHandler interface for Message of type T
 */
public interface ConnectionHandler<T> extends Closeable {

    /**
     * Comment the following lines (both send methods) for the existing implentations to work.
     *
     */

    void send(T msg);

}


---File: ./server/src/main/java/bgu/spl/net/srv/Connections.java---
package bgu.spl.net.srv;

import java.io.IOException;

public interface Connections<T> {

    boolean send(int connectionId, T msg);

    void send(String channel, T msg);

    void disconnect(int connectionId);

    //new methods for subscribe and unsubscribe
    void subscribe(String channel, int connectionId, String subscriptionId);
    void unsubscribe(String channel, int connectionId, String subscriptionId);
    void addConnection(int connectionId, ConnectionHandler<T> handler);

}


---File: ./server/src/main/java/bgu/spl/net/srv/ConnectionsImpl.java---
package bgu.spl.net.srv;
import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import bgu.spl.net.impl.stomp.StompFrame;

public class ConnectionsImpl<T> implements Connections<T> {
    private Map<Integer, ConnectionHandler<T>> connections = new ConcurrentHashMap<>();
    //Map <"Topic" <ConnectionId, SubscriptionId>>
    private Map<String,ConcurrentHashMap<Integer, String>> topics = new ConcurrentHashMap<>();
    private static final AtomicInteger messageIdCounter = new AtomicInteger(0);

    @Override
    public boolean send(int connectionId, T msg){
        ConnectionHandler<T> handler = connections.get(connectionId);
        if(handler != null){
            handler.send(msg);
            return true;
        }
        return false;
    }

    @Override
    public void send(String channel, T msg){
        ConcurrentHashMap<Integer, String> subscribers = topics.get(channel);
        if(subscribers != null){
            Set<Integer> connectionIds = subscribers.keySet();
            for(Integer id : connectionIds){
                T msgToSend = addsubscriptionToMsg(msg, id, channel);
                send(id, msgToSend);
            }
        }
    }

    @Override
    public void disconnect(int connectionId){
        connections.remove(connectionId);//remove user from connections
        for(ConcurrentHashMap<Integer, String> subscribers : topics.values()){ //remove user from all topics he subscribed to
            subscribers.remove(connectionId);
        }
    }

    @Override
    public void subscribe(String channel, int connectionId, String subscriptionId){
        topics.putIfAbsent(channel, new ConcurrentHashMap<>());
        topics.get(channel).put(connectionId, subscriptionId);
    }

    @Override
    public void unsubscribe(String channel, int connectionId, String subscriptionId)
    {
        ConcurrentHashMap<Integer, String> subscribers = topics.get(channel);
        if(subscribers != null){
            subscribers.remove(connectionId);
            if (subscribers.isEmpty()) {
                topics.remove(channel);
            }
        }
    }
    public void addConnection(int connectionId, ConnectionHandler<T> handler) {
        System.err.println("DEBUG Adding connection with ID: " + connectionId);
        connections.put(connectionId, handler);
    }
    private T addsubscriptionToMsg(T msg, int connectionId, String channel) {
        if (msg instanceof StompFrame) {
           
            StompFrame cloned = new StompFrame((StompFrame) msg);
            
            ConcurrentHashMap<Integer, String> subscribers = topics.get(channel);
            String subscriptionId = subscribers.get(connectionId);
            if (subscriptionId != null) {
                cloned.addHeader("subscription", subscriptionId);
            }
            
            // Add message-id (server-unique)
            cloned.addHeader("message-id", String.valueOf(messageIdCounter.incrementAndGet()));

            return (T) cloned;
        }
        
        return msg;
    }
}


---File: ./server/src/main/java/bgu/spl/net/srv/NonBlockingConnectionHandler.java---
package bgu.spl.net.srv;

import bgu.spl.net.api.MessageEncoderDecoder;
import bgu.spl.net.api.MessagingProtocol;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class NonBlockingConnectionHandler<T> implements ConnectionHandler<T> {

    private static final int BUFFER_ALLOCATION_SIZE = 1 << 13; //8k
    private static final ConcurrentLinkedQueue<ByteBuffer> BUFFER_POOL = new ConcurrentLinkedQueue<>();

    private final MessagingProtocol<T> protocol;
    private final MessageEncoderDecoder<T> encdec;
    private final Queue<ByteBuffer> writeQueue = new ConcurrentLinkedQueue<>();
    private final SocketChannel chan;
    private final Reactor reactor;

    public NonBlockingConnectionHandler(
            MessageEncoderDecoder<T> reader,
            MessagingProtocol<T> protocol,
            SocketChannel chan,
            Reactor reactor) {
        this.chan = chan;
        this.encdec = reader;
        this.protocol = protocol;
        this.reactor = reactor;
    }

    public Runnable continueRead() {
        ByteBuffer buf = leaseBuffer();

        boolean success = false;
        try {
            success = chan.read(buf) != -1;
        } catch (IOException ex) {
            ex.printStackTrace();
        }

        if (success) {
            buf.flip();
            return () -> {
                try {
                    while (buf.hasRemaining()) {
                        T nextMessage = encdec.decodeNextByte(buf.get());
                        if (nextMessage != null) {
                            T response = protocol.process(nextMessage);
                            if (response != null) {
                                writeQueue.add(ByteBuffer.wrap(encdec.encode(response)));
                                reactor.updateInterestedOps(chan, SelectionKey.OP_READ | SelectionKey.OP_WRITE);
                            }
                        }
                    }
                } finally {
                    releaseBuffer(buf);
                }
            };
        } else {
            releaseBuffer(buf);
            close();
            return null;
        }

    }

    public void close() {
        try {
            chan.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    public boolean isClosed() {
        return !chan.isOpen();
    }

    public void continueWrite() {
        while (!writeQueue.isEmpty()) {
            try {
                ByteBuffer top = writeQueue.peek();
                chan.write(top);
                if (top.hasRemaining()) {
                    return;
                } else {
                    writeQueue.remove();
                }
            } catch (IOException ex) {
                ex.printStackTrace();
                close();
            }
        }

        if (writeQueue.isEmpty()) {
            if (protocol.shouldTerminate()) close();
            else reactor.updateInterestedOps(chan, SelectionKey.OP_READ);
        }
    }

    private static ByteBuffer leaseBuffer() {
        ByteBuffer buff = BUFFER_POOL.poll();
        if (buff == null) {
            return ByteBuffer.allocateDirect(BUFFER_ALLOCATION_SIZE);
        }

        buff.clear();
        return buff;
    }

    private static void releaseBuffer(ByteBuffer buff) {
        BUFFER_POOL.add(buff);
    }

    @Override
    public void send(T msg) {
        //IMPLEMENT IF NEEDED
    }
}


---File: ./server/src/main/java/bgu/spl/net/srv/Reactor.java---
package bgu.spl.net.srv;

import bgu.spl.net.api.MessageEncoderDecoder;
import bgu.spl.net.api.MessagingProtocol;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.ClosedSelectorException;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.function.Supplier;

public class Reactor<T> implements Server<T> {

    private final int port;
    private final Supplier<MessagingProtocol<T>> protocolFactory;
    private final Supplier<MessageEncoderDecoder<T>> readerFactory;
    private final ActorThreadPool pool;
    private Selector selector;

    private Thread selectorThread;
    private final ConcurrentLinkedQueue<Runnable> selectorTasks = new ConcurrentLinkedQueue<>();

    public Reactor(
            int numThreads,
            int port,
            Supplier<MessagingProtocol<T>> protocolFactory,
            Supplier<MessageEncoderDecoder<T>> readerFactory) {

        this.pool = new ActorThreadPool(numThreads);
        this.port = port;
        this.protocolFactory = protocolFactory;
        this.readerFactory = readerFactory;
    }

    @Override
    public void serve() {
	selectorThread = Thread.currentThread();
        try (Selector selector = Selector.open();
                ServerSocketChannel serverSock = ServerSocketChannel.open()) {

            this.selector = selector; //just to be able to close

            serverSock.bind(new InetSocketAddress(port));
            serverSock.configureBlocking(false);
            serverSock.register(selector, SelectionKey.OP_ACCEPT);
			System.out.println("Server started");

            while (!Thread.currentThread().isInterrupted()) {

                selector.select();
                runSelectionThreadTasks();

                for (SelectionKey key : selector.selectedKeys()) {

                    if (!key.isValid()) {
                        continue;
                    } else if (key.isAcceptable()) {
                        handleAccept(serverSock, selector);
                    } else {
                        handleReadWrite(key);
                    }
                }

                selector.selectedKeys().clear(); //clear the selected keys set so that we can know about new events

            }

        } catch (ClosedSelectorException ex) {
            //do nothing - server was requested to be closed
        } catch (IOException ex) {
            //this is an error
            ex.printStackTrace();
        }

        System.out.println("server closed!!!");
        pool.shutdown();
    }

    /*package*/ void updateInterestedOps(SocketChannel chan, int ops) {
        final SelectionKey key = chan.keyFor(selector);
        if (Thread.currentThread() == selectorThread) {
            key.interestOps(ops);
        } else {
            selectorTasks.add(() -> {
                key.interestOps(ops);
            });
            selector.wakeup();
        }
    }


    private void handleAccept(ServerSocketChannel serverChan, Selector selector) throws IOException {
        SocketChannel clientChan = serverChan.accept();
        clientChan.configureBlocking(false);
        final NonBlockingConnectionHandler<T> handler = new NonBlockingConnectionHandler<>(
                readerFactory.get(),
                protocolFactory.get(),
                clientChan,
                this);
        clientChan.register(selector, SelectionKey.OP_READ, handler);
    }

    private void handleReadWrite(SelectionKey key) {
        @SuppressWarnings("unchecked")
        NonBlockingConnectionHandler<T> handler = (NonBlockingConnectionHandler<T>) key.attachment();

        if (key.isReadable()) {
            Runnable task = handler.continueRead();
            if (task != null) {
                pool.submit(handler, task);
            }
        }

	    if (key.isValid() && key.isWritable()) {
            handler.continueWrite();
        }
    }

    private void runSelectionThreadTasks() {
        while (!selectorTasks.isEmpty()) {
            selectorTasks.remove().run();
        }
    }

    @Override
    public void close() throws IOException {
        selector.close();
    }

}


---File: ./server/src/main/java/bgu/spl/net/srv/Server.java---
package bgu.spl.net.srv;

import bgu.spl.net.api.MessageEncoderDecoder;
import bgu.spl.net.api.MessagingProtocol;
import java.io.Closeable;
import java.util.function.Supplier;

public interface Server<T> extends Closeable {

    /**
     * The main loop of the server, Starts listening and handling new clients.
     */
    void serve();

    /**
     *This function returns a new instance of a thread per client pattern server
     * @param port The port for the server socket
     * @param protocolFactory A factory that creats new MessagingProtocols
     * @param encoderDecoderFactory A factory that creats new MessageEncoderDecoder
     * @param <T> The Message Object for the protocol
     * @return A new Thread per client server
     */
    public static <T> Server<T>  threadPerClient(
            int port,
            Supplier<MessagingProtocol<T> > protocolFactory,
            Supplier<MessageEncoderDecoder<T> > encoderDecoderFactory) {

        return new BaseServer<T>(port, protocolFactory, encoderDecoderFactory) {
            @Override
            protected void execute(BlockingConnectionHandler<T>  handler) {
                new Thread(handler).start();
            }
        };

    }

    /**
     * This function returns a new instance of a reactor pattern server
     * @param nthreads Number of threads available for protocol processing
     * @param port The port for the server socket
     * @param protocolFactory A factory that creats new MessagingProtocols
     * @param encoderDecoderFactory A factory that creats new MessageEncoderDecoder
     * @param <T> The Message Object for the protocol
     * @return A new reactor server
     */
    public static <T> Server<T> reactor(
            int nthreads,
            int port,
            Supplier<MessagingProtocol<T>> protocolFactory,
            Supplier<MessageEncoderDecoder<T>> encoderDecoderFactory) {
        return new Reactor<T>(nthreads, port, protocolFactory, encoderDecoderFactory);
    }

}


